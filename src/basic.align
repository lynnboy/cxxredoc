[section#basic.align
    [:en] Alignment
    [:zh_CN] 
]

[para]
[:en]
[%alignment requirement[!implementation-defined]]
Object types have [+alignment requirements] ([#basic.fundamental],
[#basic.compound]) which place restrictions on the addresses at which an object
of that type may be allocated.

[:en]
An [+alignment] is an [%@impldef alignment] implementation-defined integer value
representing the number of bytes between successive addresses at which a given
object can be allocated.

[:en]
An object type imposes an alignment requirement on every object of that type;
stricter alignment can be requested using the alignment specifier
([#dcl.align]).

[para]
[:en]
[%fundamental alignment]
[%alignment[!fundamental]]
A [+fundamental alignment] is represented by an alignment less than or equal to
the greatest alignment supported by the implementation in all contexts, which is
equal to [`alignof(std::max_align_t)] ([#support.types]).

[:en]
The alignment required for a type might be different when it is used as the type
of a complete object and when it is used as the type of a subobject.

[enter:example]

[codeblock]
struct B { long double d; };
struct D : virtual B { char c; };
[codeblock:end]

[:en]
When [`D] is the type of a complete object, it will have a subobject of type
[`B], so it must be aligned appropriately for a [`long double].

[:en]
If [`D] appears as a subobject of another object that also has [`B] as a virtual
base class, the [`B] subobject might be part of a different subobject, reducing
the alignment requirements on the [`D] subobject.
[exit:example]

[:en]
The result of the [`alignof] operator reflects the alignment requirement of the
type in the complete-object case.

[para]
[:en]
[%extended alignment]
[%alignment[!extended]]
[%over-aligned type]
[%type[!over-aligned]]
An [+extended alignment] is represented by an alignment greater than
[`alignof(std::max_align_t)].

[:en]
It is implementation-defined whether any extended alignments are supported and
the contexts in which they are supported ([#dcl.align]).

[:en]
A type having an extended alignment requirement is an [~over-aligned type].

[enter:note]
[:en]
every over-aligned type is or contains a class type to which extended alignment
applies (possibly through a non-static data member).
[exit:note]

[para]
[:en]
Alignments are represented as values of the type [`std::size_t].

[:en]
Valid alignments include only those values returned by an [`alignof] expression
for the fundamental types plus an additional [%@impldef alignment additional
values] implementation-defined set of values, which may be empty.

[:en]
Every alignment value shall be a non-negative integral power of two.

[para]
[:en]
Alignments have an order from [+weaker] to [+stronger] or [+stricter]
alignments.

[:en]
Stricter alignments have larger alignment values.

[:en]
An address that satisfies an alignment requirement also satisfies any weaker
valid alignment requirement.

[para]
[:en]
The alignment requirement of a complete type can be queried using an [`alignof]
expression ([#expr.alignof]).

[:en]
Furthermore, the narrow character types ([#basic.fundamental]) shall have the
weakest alignment requirement.

[enter:note]
[:en]
This enables the narrow character types to be used as the underlying type for an
aligned memory area ([#dcl.align]).
[exit:note]

[para]
[:en]
Comparing alignments is meaningful and provides the obvious results:

[list]
[item]
[:en]
Two alignments are equal when their numeric values are equal.
[item]
[:en]
Two alignments are different when their numeric values are not equal.
[item]
[:en]
When an alignment is larger than another it represents a stricter alignment.
[list:end]

[para]
[enter:note]
[:en]
The runtime pointer alignment function ([#ptr.align]) can be used to obtain an
aligned pointer within a buffer; the aligned-storage templates in the library
([#meta.trans.other]) can be used to obtain aligned storage.
[exit:note]

[para]
[:en]
If a request for a specific extended alignment in a specific context is not
supported by an implementation, the program is ill-formed.

[:en]
Additionally, a request for runtime allocation of dynamic storage for which the
requested alignment cannot be honored shall be treated as an allocation failure.
