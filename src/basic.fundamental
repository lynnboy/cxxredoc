[section#basic.fundamental
    [:en] Fundamental types
    [:zh_CN] 
]

[para]
[:en]
[%type[!fundamental]]
[%type[!integral]]
[%type[!floating point]]
[%type[!implementation-defined [`sizeof]]]
[%type[!Boolean]]
[%type[![`char]]]
[%type[!character]]
[%type[!narrow character]]
Objects declared as characters ([`char]) shall be large enough to store any
member of the implementation[=']s basic character set.

[:en]
If a character from this set is stored in a character object, the integral value
of that character object is equal to the value of the single character literal
form of that character.

[:en]
It is [%@impldef signedness of [`char]] implementation-defined whether a [`char]
object can hold negative values.

[:en]
[%[`char][!implementation-defined sign of]]
[%type[![`signed char]]]
[%type[![`unsigned char]]]
Characters can be explicitly declared [`unsigned] or [`signed].

[:en]
[%character[![`signed]]]
Plain [`char], [`signed char], and [`unsigned char] are three distinct types,
collectively called [+narrow character types].

[:en]
A [`char], a [`signed char], and an [`unsigned char] occupy the same amount of
storage and have the same alignment requirements ([#basic.align]); that is, they
have the same object representation.

[:en]
For narrow character types, all bits of the object representation participate in
the value representation.

[:en]
For unsigned narrow character types, each possible bit pattern of the value
representation represents a distinct number.

[:en]
These requirements do not hold for other types.

[:en]
In any particular implementation, a plain [`char] object can take on either the
same values as a [`signed char] or an [`unsigned char]; which one is [%@impldef
representation of [`char]] implementation-defined.

[:en]
For each value [$i] of type [`unsigned char] in the range 0 to 255 inclusive,
there exists a value [$j] of type [`char] such that the result of an integral
conversion ([#conv.integral]) from [$i] to [`char] is [$j], and the result of an
integral conversion from [$j] to [`unsigned char] is [$i].

[para]
[:en]
[%type[!standard signed integer]]
[%standard signed integer type]
There are five [+standard signed integer types]:

[:en]
[%type[![`signed char]]]
[%type[![`short]]]
[%type[![`int]]]
[%type[![`long]]]
[%type[![`long long]]]
["[`signed char]], ["[`short int]], ["[`int]], ["[`long int]], and ["[`long long
int]].

[:en]
In this list, each type provides at least as much storage as those preceding it
in the list.

[:en]
[%type[!extended signed integer]]
[%extended signed integer type]
[%type[!signed integer]]
[%signed integer type]
There may also be [%@impldef extended signed integer types]
implementation-defined [+extended signed integer types].

[:en]
The standard and extended signed integer types are collectively called [+signed
integer types].

[:en]
[%integral type[!implementation-defined [`sizeof]]]
Plain [`int]s have the natural size suggested by the architecture of the
execution environment%

[footnote]
[:en]
[`int] must also be large enough to contain any value in the range
[=crange[INT_MIN,INT_MAX]], as defined in the header [`<climits>].
[footnote:end]

[:en@~]
; the other signed integer types are provided to meet special needs.

[para]
[:en]
[%type[![`unsigned]]]
For each of the standard signed integer types, there exists a corresponding (but
different)
[%type[!standard unsigned integer]]
[%standard unsigned integer type]
[+standard unsigned integer type]:
[%type[![`unsigned char]]]
[%type[![`unsigned short]]]
[%type[![`unsigned int]]]
[%type[![`unsigned long]]]
[%type[![`unsigned long long]]]
["[`unsigned char]], ["[`unsigned short int]], ["[`unsigned int]], ["[`unsigned
long int]], and ["[`unsigned long long int]], each of which occupies the same
amount of storage and has the same alignment requirements ([#basic.align]) as
the corresponding signed integer type

[footnote]
[:en]
See [#dcl.type.simple] regarding the correspondence between types and the
sequences of [~type-specifier]s that designate them.
[footnote:end]

[:en@~]
; that is, each signed integer type has the same object representation as
its corresponding unsigned integer type.

[:en]
[%type[!extended unsigned integer]]
[%extended unsigned integer type]
[%type[!unsigned integer]]
[%unsigned integer type]
Likewise, for each of the extended signed integer types there exists a
corresponding [+extended unsigned integer type] with the same amount of storage
and alignment requirements.

[:en]
The standard and extended unsigned integer types are collectively called
[+unsigned integer types].

[:en]
The range of non-negative values of a [+signed integer] type is a subrange of
the corresponding [+unsigned integer] type, and the value representation of each
corresponding signed/unsigned type shall be the same.

[:en]
[%type[!standard integer]]
[%standard integer type]
[%type[!extended integer]]
[%extended integer type]
The standard signed integer types and standard unsigned integer types are
collectively called the [+standard integer types], and the extended signed
integer types and extended unsigned integer types are collectively called the
[+extended integer types].

[:en]
The signed and unsigned integer types shall satisfy the constraints given in the
C standard, section 5.2.4.2.1.

[para]
[:en]
[%arithmetic[![`unsigned]]]
Unsigned integers shall obey the laws of arithmetic modulo [$2[^n]] where [$n]
is the number of bits in the value representation of that particular size of
integer.

[footnote]
[:en]
This implies that unsigned arithmetic does not overflow because a result that
cannot be represented by the resulting unsigned integer type is reduced modulo
the number that is one greater than the largest value that can be represented by
the resulting unsigned integer type.
[footnote:end]

[para]
[:en]
[%type[![`char16_t]]]
[%type[![`char32_t]]]
[%[`wchar_t][!implementation-defined]]
[%type[![`wchar_t]]]
[%type[!underlying [`wchar_t]]]
Type [`wchar_t] is a distinct type whose values can represent distinct codes for
all members of the largest extended character set specified among the supported
locales ([#locale]).

[:en]
Type [`wchar_t] shall have the same size, signedness, and alignment requirements
([#basic.align]) as one of the other integral types, called its [def underlying
type].

[:en]
Types [`char16_t] and [`char32_t] denote distinct types with the same size,
signedness, and alignment as [`uint_least16_t] and [`uint_least32_t],
respectively, in [`<cstdint>], called the underlying types.

[para]
[:en]
[%Boolean type]
Values of type [`bool] are either [`true] or [`false].

[footnote]
[:en]
Using a [`bool] value in ways described by this International Standard as
["undefined,] such as by examining the value of an uninitialized automatic
object, might cause it to behave as if it is neither [`true] nor [`false].
[footnote:end]

[enter:note]
[:en]
There are no [`signed], [`unsigned], [`short], or [`long bool] types or values.
[exit:note]

[:en]
Values of type [`bool] participate in integral promotions ([#conv.prom]).

[para]
[:en]
Types [`bool], [`char], [`char16_t], [`char32_t], [`wchar_t], and the signed and
unsigned integer types are collectively called
[%integral type]
[+integral] types.

[footnote]
[:en]
Therefore, enumerations ([#dcl.enum]) are not integral; however, enumerations
can be promoted to integral types as specified in [#conv.prom].
[footnote:end]

[:en]
A synonym for integral type is
[%integer type]
[+integer type].

[:en]
The representations of integral types shall define values by use of a pure
binary numeration system.

[footnote]
[:en]
A positional representation for integers that uses the binary digits 0 and 1, in
which the values represented by successive bits are additive, begin with 1, and
are multiplied by successive integral power of 2, except perhaps for the bit
with the highest position.

[:en]
(Adapted from the [cite American National Dictionary for Information Processing
Systems].)
[footnote:end]

[enter:example]
[:en]
this International Standard permits 2[=']s complement, 1[=']s complement and
signed magnitude representations for integral types.
[exit:example]

[para]
[:en]
[%floating point type]
There are three [+floating point] types:
[%type[![`float]]]
[`float],
[%type[![`double]]]
[`double], and
[%type[![`long double]]]
[`long double].

[:en]
The type [`double] provides at least as much precision as [`float], and the type
[`long double] provides at least as much precision as [`double].

[:en]
The set of values of the type [`float] is a subset of the set of values of the
type [`double]; the set of values of the type [`double] is a subset of the set
of values of the type [`long] [`double].

[:en]
The value representation of floating-point types is [%@impldef value
representation of floating-point types] implementation-defined.
[%floating point type[!implementation-defined]]

[:en]
[%type[!arithmetic]]
[+Integral] and [+floating] types are collectively called [+arithmetic] types.

[:en]
[%[`numeric_limits][!specializations for arithmetic types]]
Specializations of the standard template [`std::numeric_limits]
([#support.limits]) shall specify the maximum and minimum values of each
arithmetic type for an implementation.

[para]
[:en]
[%type[![`void]]]
The [`void] type has an empty set of values.

[:en]
The [`void] type is an incomplete type that cannot be completed.

[:en]
It is used as the return type for functions that do not return a value.

[:en]
Any expression can be explicitly converted to type [$cv] [`void] ([#expr.cast]).

[:en]
An expression of type [`void] shall be used only as an expression statement
([#stmt.expr]), as an operand of a comma expression ([#expr.comma]), as a second
or third operand of [`?:] ([#expr.cond]), as the operand of [`typeid],
[`noexcept], or [`decltype], as the expression in a return statement
([#stmt.return]) for a function with the return type [`void], or as the operand
of an explicit conversion to type [$cv] [`void].

[para]
[:en]
A value of type [`std::nullptr_t] is a null pointer constant ([#conv.ptr]).

[:en]
Such values participate in the pointer and the pointer to member conversions
([#conv.ptr], [#conv.mem]).

[:en]
[`sizeof(std::nullptr_t)] shall be equal to [`sizeof(void*)].

[para]
[enter:note]
 
[:en]
Even if the implementation defines two or more basic types to have the same
value representation, they are nevertheless different types.
[exit:note]
