[section#basic.scope.temp
    [:en] Template parameter scope
    [:zh_CN] 作用域
]

[para]
[:en]
[%template parameter scope]
[%scope[!template parameter]]
The declarative region of the name of a template parameter of a template
[~template-parameter] is the smallest [~template-parameter-list] in which the
name was introduced.

[para]
[:en]
The declarative region of the name of a template parameter of a template is the
smallest [~template-declaration] in which the name was introduced.

[:en]
Only template parameter names belong to this declarative region; any other kind
of name introduced by the [~declaration] of a [~template-declaration] is instead
introduced into the same declarative region where it would be introduced as a
result of a non-template declaration of the same name.

[enter:example]

[codeblock]
namespace N {
  template<class T> struct A { };               // #1
  template<class U> void f(U) { }               // #2
  struct B {
    template<class V> friend int g(struct C*);  // #3
  };
}
[codeblock:end]

[:en]
The declarative regions of [`T], [`U] and [`V] are the [~template-declaration]s
on lines [`#1], [`#2] and [`#3], respectively.

[:en]
But the names [`A], [`f], [`g] and [`C] all belong to the same declarative
region [=--] namely, the [~namespace-body] of [`N].

[:en]
([`g] is still considered to belong to this declarative region in spite of its
being hidden during qualified and unqualified name lookup.)
[exit:example]

[para]
[:en]
The potential scope of a template parameter name begins at its point of
declaration ([#basic.scope.pdecl]) and ends at the end of its declarative
region.

[enter:note]
[:en]
This implies that a [~template-parameter] can be used in the declaration of
subsequent [~template-parameter]s and their default arguments but cannot be used
in preceding [~template-parameter]s or their default arguments.

[:en]
For example,

[codeblock]
template<class T, T* p, class U = T> class X { /* ... */ };
template<class T> void f(T* p = new T);
[codeblock:end]

[:en]
This also implies that a [~template-parameter] can be used in the specification
of base classes.

[:en]
For example,

[codeblock]
template<class T> class X : public Array<T> { /* ... */ };
template<class T> class Y : public T { /* ... */ };
[codeblock:end]

[:en]
The use of a template parameter as a base class implies that a class used as a
template argument must be defined and not just declared when the class template
is instantiated.
[exit:note]

[para]
[:en]
The declarative region of the name of a template parameter is nested within the
immediately-enclosing declarative region.

[enter:note]
[:en]
As a result, a [~template-parameter] hides any entity with the same name in an
enclosing scope ([#basic.scope.hiding]).

[enter:example]

[codeblock]
typedef int N;
template<N X, typename N, template<N Y> class T> struct A;
[codeblock:end]

[:en]
Here, [`X] is a non-type template parameter of type [`int] and [`Y] is a
non-type template parameter of the same type as the second template parameter of
[`A].
[exit:example]
[exit:note]

[para]
[enter:note]
[:en]
Because the name of a template parameter cannot be redeclared within its
potential scope ([#temp.local]), a template parameter[=']s scope is often its
potential scope.

[:en]
However, it is still possible for a template parameter name to be hidden; see
[#temp.local].
[exit:note]
