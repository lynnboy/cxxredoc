[section:chapter#class.access
    [:en] Member access control
]

[%:begin#access.control
    [:en] access control
]

[:en]
[%protection[see access control]]
[%[`private][see access control[![`private]]]]
[%[`protected][see access control[![`protected]]]]
[%[`public][see access control[! [`public]]]]

[para]
[:en]
A member of a class can be

[list]
[item]
[:en@~]
[%access control[![`private]]]
[`private]; that is, its name can be used only by members and friends of the
class in which it is declared.

[item]
[:en@~]
[%access control[![`protected]]]
[`protected]; that is, its name can be used only by members and friends of the
class in which it is declared, by classes derived from that class, and by their
friends (see [#class.protected]).

[item]
[:en@~]
[%access control[![`public]]]
[`public]; that is, its name can be used anywhere without access restriction.
[list:end]

[para]
[:en]
A member of a class can also access all the names to which the class has access.

[:en]
A local class of a member function may access the same names that the member
function itself may access.

[footnote]
[:en]
Access permissions are thus transitive and cumulative to nested and local
classes.
[footnote:end]

[para]
[:en]
[%access control[!member name]]
[%default access control[see access control [!default]]]
[%access control[!default]]
Members of a class defined with the keyword [`class] are [`private] by default.

[:en]
Members of a class defined with the keywords [`struct] or [`union] are [`public]
by default.

[enter:example]
[codeblock]
class X {
  int a;            // [:en] [`X::a] is private by default
};

struct S {
  int a;            // [:en] [`S::a] is public by default
};
[codeblock:end]
[exit:example]

[para]
[:en]
Access control is applied uniformly to all names, whether the names are referred
to from declarations or expressions.

[enter:note]
[:en]
Access control applies to names nominated by [`friend] declarations
([#class.friend]) and [~using-declaration]s ([#namespace.udecl]).
[exit:note]

[:en]
In the case of overloaded function names, access control is applied to the
function selected by overload resolution.

[enter:note]
[:en]
Because access control applies to names, if access control is applied to a
typedef name, only the accessibility of the typedef name itself is considered.

[:en]
The accessibility of the entity referred to by the typedef is not considered.

[:en]
For example,

[codeblock]
class A {
  class B { };
public:
  typedef B BB;
};

void f() {
  A::BB x;          // [:en] OK, typedef name [`A::BB] is public
  A::B y;           // [:en] access error, [`A::B] is private
}
[codeblock:end]
[exit:note]

[para]
[:en]
It should be noted that it is [+access] to members and base classes that is
controlled, not their [+visibility].

[:en]
Names of members are still visible, and implicit conversions to base classes are
still considered, when those members and base classes are inaccessible.

[:en]
The interpretation of a given construct is established without regard to access
control.

[:en]
If the interpretation established makes use of inaccessible member names or base
classes, the construct is ill-formed.

[para]
[:en]
All access controls in Clause [#class.access] affect the ability to access a
class member name from the declaration of a particular entity, including parts
of the declaration preceding the name of the entity being declared and, if the
entity is a class, the definitions of members of the class appearing outside the
class[=']s [~member-specification].

[enter:note]
[:en]
this access also applies to implicit references to constructors, conversion
functions, and destructors.
[exit:note]

[enter:example]
[codeblock]
class A {
  typedef int I;    // [:en] private member
  I f();
  friend I g(I);
  static I x;
  template<int> struct Q;
  template<int> friend struct R;
protected:
    struct B { };
};

A::I A::f() { return 0; }
A::I g(A::I p = A::x);
A::I g(A::I p) { return 0; }
A::I A::x = 0;
template<A::I> struct A::Q { };
template<A::I> struct R { };

struct D: A::B, A { };
[codeblock:end]

[para]
[:en]
Here, all the uses of [`A::I] are well-formed because [`A::f], [`A::x], and
[`A::Q] are members of class [`A] and [`g] and [`R] are friends of class [`A].

[:en]
This implies, for example, that access checking on the first use of [`A::I] must
be deferred until it is determined that this use of [`A::I] is as the return
type of a member of class [`A].

[:en]
Similarly, the use of [`A::B] as a [~base-specifier] is well-formed because [`D]
is derived from [`A], so checking of [~base-specifier]s must be deferred until
the entire [~base-specifier-list] has been seen.
[exit:example]

[para]
[:en]
[%argument[!access checking and default]]
[%access control[!default argument]]
The names in a default argument ([#dcl.fct.default]) are bound at the point of
declaration, and access is checked at that point rather than at any points of
use of the default argument.

[:en]
Access checking for default arguments in function templates and in member
functions of class templates is performed as described in [#temp.inst].

[para]
[:en]
The names in a default [~template-argument] ([#temp.param]) have their access
checked in the context in which they appear rather than at any points of use of
the default [~template-argument].

[enter:example]
[codeblock]
class B { };
template <class T> class C {
protected:
  typedef T TT;
};

template <class U, class V = typename U::TT>
class D : public U { };

D <C<B> >* d;       // [:en] access error, C::TT is protected
[codeblock:end]
[exit:example]

[include class.access.spec]

[include class.access.base]

[include class.friend]

[include class.protected]

[include class.access.virt]

[include class.paths]

[include class.access.nest]

[%:end#access.control]
