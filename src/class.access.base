[section#class.access.base
    [:en] Accessibility of base classes and base class members
]

[:en]
[%access control[!base class]]
[%access specifier]
[%base class[![`private]]]
[%base class[![`protected]]]
[%base class[![`public]]]

[para]
[:en]
If a class is declared to be a base class (Clause [#class.derived]) for another
class using the [`public] access specifier, the [`public] members of the base
class are accessible as [`public] members of the derived class and [`protected]
members of the base class are accessible as [`protected] members of the derived
class.

[:en]
If a class is declared to be a base class for another class using the
[`protected] access specifier, the [`public] and [`protected] members of the
base class are accessible as [`protected] members of the derived class.

[:en]
If a class is declared to be a base class for another class using the [`private]
access specifier, the [`public] and [`protected] members of the base class are
accessible as [`private] members of the derived class

[footnote]
[:en]
As specified previously in Clause [#class.access], private members of a base
class remain inaccessible even to derived classes unless [`friend] declarations
within the base class definition are used to grant access explicitly.
[footnote:end]

[:en@~]
.

[para]
[:en]
In the absence of an [~access-specifier] for a base class, [`public] is assumed
when the derived class is defined with the [~class-key] [`struct] and [`private]
is assumed when the class is defined with the [~class-key] [`class].

[enter:example]
[codeblock]
class B { /* ... */ };
class D1 : private B { /* ... */ };
class D2 : public B { /* ... */ };
class D3 : B { /* ... */ };     // [:en] [`B] private by default
struct D4 : public B { /* ... */ };
struct D5 : private B { /* ... */ };
struct D6 : B { /* ... */ };    // [:en] [`B] public by default
class D7 : protected B { /* ... */ };
struct D8 : protected B { /* ... */ };
[codeblock:end]

[:en]
Here [`B] is a public base of [`D2], [`D4], and [`D6], a private base of [`D1],
[`D3], and [`D5], and a protected base of [`D7] and [`D8].
[exit:example]

[para]
[enter:note]
[:en]
A member of a private base class might be inaccessible as an inherited member
name, but accessible directly.

[:en]
Because of the rules on pointer conversions ([#conv.ptr]) and explicit casts
([#expr.cast]), a conversion from a pointer to a derived class to a pointer to
an inaccessible base class might be ill-formed if an implicit conversion is
used, but well-formed if an explicit cast is used.

[:en]
For example,

[codeblock]
class B {
public:
  int mi;                       // [:en] non-static member
  static int si;                // [:en] static member
};
class D : private B {
};
class DD : public D {
  void f();
};

void DD::f() {
  mi = 3;                       // [:en] error: [`mi] is private in [`D]
  si = 3;                       // [:en] error: [`si] is private in [`D]
  ::B  b;
  b.mi = 3;                     // [:en] OK ([`b.mi] is different from [`this->mi])
  b.si = 3;                     // [:en] OK ([`b.si] is different from [`this->si])
  ::B::si = 3;                  // OK
  ::B* bp1 = this;              // [:en] error: [`B] is a private base class
  ::B* bp2 = (::B*)this;        // [:en] OK with cast
  bp2->mi = 3;                  // [:en] OK: access through a pointer to [`B].
}
[codeblock:end]
[exit:note]

[para]
[:en]
A base class [`B] of [`N] is [+accessible] at [$R], if

[list]
[item]
[:en@~]
an invented public member of [`B] would be a public member of [`N], or

[item]
[:en]
[$R] occurs in a member or friend of class [`N], and an invented public member
of [`B] would be a private or protected member of [`N], or

[item]
[:en]
[$R] occurs in a member or friend of a class [`P] derived from [`N], and an
invented public member of [`B] would be a private or protected member of [`P],
or

[item]
[:en]
there exists a class [`S] such that [`B] is a base class of [`S] accessible at
[$R] and [`S] is a base class of [`N] accessible at [$R].
[list:end]

[enter:example]
[codeblock]
class B {
public:
  int m;
};

class S: private B {
  friend class N;
};

class N: private S {
  void f() {
    B* p = this;    // [:en] OK because class [`S] satisfies the fourth condition
                    // [:en@~] above: [`B] is a base class of [`N] accessible in [`f()] because
                    // [:en@~] [`B] is an accessible base class of [`S] and [`S] is an accessible
                    // [:en@~] base class of [`N].
  }
};
[codeblock:end]
[exit:example]

[para]
[:en]
If a base class is accessible, one can implicitly convert a pointer to a derived
class to a pointer to that base class ([#conv.ptr], [#conv.mem]).

[enter:note]
[:en]
It follows that members and friends of a class [`X] can implicitly convert an
[`X*] to a pointer to a private or protected immediate base class of [`X].
[exit:note]

[:en]
The access to a member is affected by the class in which the member is named.

[:en]
This naming class is the class in which the member name was looked up and found.

[enter:note]
[:en]
This class can be explicit, e.g., when a [~qualified-id] is used, or implicit,
e.g., when a class member access operator ([#expr.ref]) is used (including cases
where an implicit ["[`this->]] is added).

[:en]
If both a class member access operator and a [~qualified-id] are used to name
the member (as in [`p->T::m]), the class naming the member is the class denoted
by the [~nested-name-specifier] of the [~qualified-id] (that is, [`T]).
[exit:note]

[:en]
A member [`m] is accessible at the point [$R] when named in class [`N] if

[list]
[item]
[:en]
[`m] as a member of [`N] is public, or

[item]
[:en]
[`m] as a member of [`N] is private, and [$R] occurs in a member or friend of
class [`N], or

[item]
[:en]
[`m] as a member of [`N] is protected, and [$R] occurs in a member or friend of
class [`N], or in a member or friend of a class [`P] derived from [`N], where
[`m] as a member of [`P] is public, private, or protected, or

[item]
there exists a base class [`B] of [`N] that is accessible at [$R], and [`m] is
accessible at [$R] when named in class [`B].

[enter:example]
[codeblock]
class B;
class A {
private:
  int i;
  friend void f(B*);
};
class B : public A { };
void f(B* p) {
  p->i = 1;         // [:en] OK: [`B*] can be implicitly converted to [`A*],
                    // [:en@~] and [`f] has access to [`i] in [`A]
}
[codeblock:end]
[exit:example]
[list:end]

[para]
[:en]
If a class member access operator, including an implicit ["[`this->],] is used
to access a non-static data member or non-static member function, the reference
is ill-formed if the left operand (considered as a pointer in the ["[`.]]
operator case) cannot be implicitly converted to a pointer to the naming class
of the right operand.

[enter:note]
[:en]
This requirement is in addition to the requirement that the member be accessible
as named.
[exit:note]
