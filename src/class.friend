[section#class.friend
    [:en] Friends
]

[%[:en] friend function[!access and]]
[%[:en] access control[!friend function]]

[para]
[:en]
A friend of a class is a function or class that is given permission to use the
private and protected member names from the class.

[:en]
A class specifies its friends, if any, by way of friend declarations.

[:en]
Such declarations give special access rights to the friends, but they do not
make the nominated friends members of the befriending class.

[enter:example]
[:en]
the following example illustrates the differences between members and friends:

[:en]
[%friend function[!member function and]]
[%example[!friend function]]
[%example[!member function]]

[codeblock]
class X {
  int a;
  friend void friend_set(X*, int);
public:
  void member_set(int);
};

void friend_set(X* p, int i) { p->a = i; }
void X::member_set(int i) { a = i; }

void f() {
  X obj;
  friend_set(&obj,10);
  obj.member_set(10);
}
[codeblock:end]
[exit:example]

[para]
[:en]
[%friend[!class access and]]
Declaring a class to be a friend implies that the names of private and protected
members from the class granting friendship can be accessed in the
[~base-specifier]s and member declarations of the befriended class.

[enter:example]
[codeblock]
class A {
  class B { };
  friend class X;
};

struct X : A::B {   // [:en] OK: [`A::B] accessible to friend
  A::B mx;          // [:en] OK: [`A::B] accessible to member of friend
  class Y {
    A::B my;        // [:en] OK: [`A::B] accessible to nested member of friend
  };
};
[codeblock:end]
[exit:example]

[enter:example]
[codeblock]
class X {
  enum { a=100 };
  friend class Y;
};

class Y {
  int v[X::a];      // [:en] OK, [`Y] is a friend of [`X]
};

class Z {
  int v[X::a];      // [:en] error: [`X::a] is private
};
[codeblock:end]
[exit:example]

[:en]
A class shall not be defined in a friend declaration.

[para:~]
[enter:example]
[codeblock]
class A {
  friend class B { }; // [:en] error: cannot define class in friend declaration
};
[codeblock:end]
[exit:example]

[para]
[:en]
A [`friend] declaration that does not declare a function
shall have one of the following forms:

[syntax:explanation]
[| [`friend] [~elaborated-type-specifier] [`;] ]
[| [`friend] [~simple-type-specifier] [`;] ]
[| [`friend] [~typename-specifier] [`;] ]
[syntax:end]

[enter:note]
[:en]
A [`friend] declaration may be the [+declaration] in a [~template-declaration]
(Clause [#temp], [#temp.friend]).
[exit:note]

[:en]
If the type specifier in a [`friend] declaration designates a (possibly
cv-qualified) class type, that class is declared as a friend; otherwise, the
[`friend] declaration is ignored.

[enter:example]
[codeblock]
class C;
typedef C Ct;

class X1 {
  friend C;         // [:en] OK: [`class C] is a friend
};

class X2 {
  friend Ct;        // [:en] OK: [`class C] is a friend
  friend D;         // [:en] error: no type-name [`D] in scope
  friend class D;   // [:en] OK: elaborated-type-specifier declares new class
};

template <typename T> class R {
  friend T;
};

R<C> rc;            // [:en] [`class C] is a friend of [`R<C>]
R<int> Ri;          // [:en] OK: [`"friend int;"] is ignored
[codeblock:end]
[exit:example]

[para]
[:en]
[%friend function[!linkage of]]
A function first declared in a friend declaration has the linkage of the
namespace of which it is a member ([#basic.link]).

[:en]
Otherwise, the function retains its previous linkage ([#dcl.stc]).

[para]
[:en]
[%declaration[!overloaded name and [`friend]]]
When a [`friend] declaration refers to an overloaded name or operator, only the
function specified by the parameter types becomes a friend.

[:en]
A member function of a class [`X] can be a friend of a class [`Y].

[:en]
[%member function[!friend]]

[enter:example]
[codeblock]
class Y {
  friend char* X::foo(int);
  friend X::X(char);            // [:en] constructors can be friends
  friend X::~X();               // [:en] destructors can be friends
};
[codeblock:end]
[exit:example]

[para]
[:en]
[%friend function[!inline]]
A function can be defined in a friend declaration of a class if and only if the
class is a non-local class ([#class.local]), the function name is unqualified,
and the function has namespace scope.
[enter:example]

[codeblock]
class M {
  friend void f() { }           // [:en] definition of global [`f], a friend of [`M],
                                // [:en@~] not the definition of a member function
};
[codeblock:end]
[exit:example]

[para]
[:en]
Such a function is implicitly [`inline].

[:en]
A [`friend] function defined in a class is in the (lexical) scope of the class
in which it is defined.

[:en]
A friend function defined outside the class is not ([#basic.lookup.unqual]).

[para]
[:en]
No [~storage-class-specifier] shall appear in the [~decl-specifier-seq] of a
friend declaration.

[para]
[:en]
[%friend[!access specifier and]]
A name nominated by a friend declaration shall be accessible in the scope of the
class containing the friend declaration.

[:en]
The meaning of the friend declaration is the same whether the friend declaration
appears in the [`private], [`protected] or [`public] ([#class.mem]) portion of
the class [~member-specification].

[para]
[:en]
[%friend[!inheritance and]]
Friendship is neither inherited nor transitive.

[enter:example]
[codeblock]
class A {
  friend class B;
  int a;
};

class B {
  friend class C;
};

class C  {
  void f(A* p) {
    p->a++;         // [:en] error: [`C] is not a friend of [`A]
                    // [:en@~] despite being a friend of a friend
  }
};

class D : public B  {
  void f(A* p) {
    p->a++;         // [:en] error: [`D] is not a friend of [`A]
                    // [:en@~] despite being derived from a friend
  }
};
[codeblock:end]
[exit:example]

[para]
[:en]
[%local class[!friend]]
[%friend[!local class and]]
If a friend declaration appears in a local class ([#class.local]) and the name
specified is an unqualified name, a prior declaration is looked up without
considering scopes that are outside the innermost enclosing non-class scope.

[:en]
For a friend function declaration, if there is no prior declaration, the program
is ill-formed.

[:en]
For a friend class declaration, if there is no prior declaration, the class that
is specified belongs to the innermost enclosing non-class scope, but if it is
subsequently referenced, its name is not found by name lookup until a matching
declaration is provided in the innermost enclosing non-class scope.

[enter:example]
[codeblock]
class X;
void a();
void f() {
  class Y;
  extern void b();
  class A {
  friend class X;   // [:en] OK, but [`X] is a local class, not [`::X]
  friend class Y;   // OK
  friend class Z;   // [:en] OK, introduces local class [`Z]
  friend void a();  // [:en] error, [`::a] is not considered
  friend void b();  // OK
  friend void c();  // [:en] error
  };
  X* px;            // [:en] OK, but [`::X] is found
  Z* pz;            // [:en] error, no [`Z] is found
}
[codeblock:end]
[exit:example]
