[section#class.member.lookup
    [:en] Member name lookup
]
[%lookup[!member name]]
[%ambiguity[!base class member]]
[%ambiguity[!member access]]

[para]
[:en]
Member name lookup determines the meaning of a name ([~id-expression]) in a
class scope ([#basic.scope.class]).

[:en]
Name lookup can result in an [+ambiguity], in which case the program is
ill-formed.

[:en]
For an [~id-expression], name lookup begins in the class scope of [`this]; for a
[~qualified-id], name lookup begins in the scope of the
[~nested-name-specifier].

[:en]
Name lookup takes place before access control ([#basic.lookup], Clause
[#class.access]).

[para]
[:en]
The following steps define the result of name lookup for a member name [`f] in a
class scope [`C].

[para]
[:en]
The [+lookup set] for [`f] in [`C], called [$S(f,C)], consists of two component
sets: the [+declaration set], a set of members named [`f]; and the [+subobject
set], a set of subobjects where declarations of these members (possibly
including [~using-declaration]s) were found.

[:en]
In the declaration set, [~using-declaration]s are replaced by the set of
designated members that are not hidden or overridden by members of the derived
class ([#namespace.udecl]), and type declarations (including
injected-class-names) are replaced by the types they designate.

[:en]
[$S(f,C)] is calculated as follows:

[para]
[:en]
If [`C] contains a declaration of the name [`f], the declaration set contains
every declaration of [`f] declared in [`C] that satisfies the requirements of
the language construct in which the lookup occurs.

[enter:note]
[:en]
Looking up a name in an [~elaborated-type-specifier] ([#basic.lookup.elab]) or
[~base-specifier] (Clause [#class.derived]), for instance, ignores all non-type
declarations, while looking up a name in a [~nested-name-specifier]
([#basic.lookup.qual]) ignores function, variable, and enumerator declarations.

[:en]
As another example, looking up a name in a [~using-declaration]
([#namespace.udecl]) includes the declaration of a class or enumeration that
would ordinarily be hidden by another declaration of that name in the same
scope.
[exit:note]

[:en]
If the resulting declaration set is not empty, the subobject set contains [`C]
itself, and calculation is complete.

[para]
[:en]
Otherwise (i.e., [`C] does not contain a declaration of [`f] or the resulting
declaration set is empty), [$S(f,C)] is initially empty.

[:en]
If [`C] has base classes, calculate the lookup set for [`f] in each direct base
class subobject [$B[_i]], and merge each such lookup set [$S(f,B[_i])] in turn
into [$S(f,C)].

[para]
[:en]
The following steps define the result of merging lookup set [$S(f,B[_i])]
into the intermediate [$S(f,C)]:

[list]
[item]
[:en]
If each of the subobject members of [$S(f,B[_i])] is a base class subobject of
at least one of the subobject members of [$S(f,C)], or if [$S(f,B[_i])] is
empty, [$S(f,C)] is unchanged and the merge is complete.

[:en]
Conversely, if each of the subobject members of [$S(f,C)] is a base class
subobject of at least one of the subobject members of [$S(f,B[_i])], or if
[$S(f,C)] is empty, the new [$S(f,C)] is a copy of [$S(f,B[_i])].

[item]
[:en]
Otherwise, if the declaration sets of [$S(f,B[_i])] and [$S(f,C)] differ, the
merge is ambiguous: the new [$S(f,C)] is a lookup set with an invalid
declaration set and the union of the subobject sets.

[:en]
In subsequent merges, an invalid declaration set is considered different from
any other.

[item]
[:en]
Otherwise, the new [$S(f,C)] is a lookup set with the shared set of declarations
and the union of the subobject sets.
[list:end]

[para]
[:en]
The result of name lookup for [`f] in [`C] is the declaration
set of [$S(f,C)].

[:en]
If it is an invalid set, the program is ill-formed.

[enter:example]
[codeblock]
struct A { int x; };                    // S(x,A) = { { [`A::x] }, { [`A] } }
struct B { float x; };                  // S(x,B) = { { [`B::x] }, { [`B] } }
struct C: public A, public B { };       // [:en] S(x,C) = { invalid, { [`A] in [`C], [`B] in [`C] } }
struct D: public virtual C { };         // S(x,D) = S(x,C)
struct E: public virtual C { char x; }; // S(x,E) = { { [`E::x] }, { [`E] } }
struct F: public D, public E { };       // S(x,F) = S(x,E)
int main() {
  F f;
  f.x = 0;                              // [:en] OK, lookup finds [`E::x]
}
[codeblock:end]

[:en]
[$S(x,F)] is unambiguous because the [`A] and [`B] base subobjects of [`D] are
also base subobjects of [`E], so [$S(x,D)] is discarded in the first merge step.
[exit:example]

[para]
[:en]
[%access control[!overloading resolution and]]
If the name of an overloaded function is unambiguously found, overloading
resolution ([#over.match]) also takes place before access control.

[:en]
[%example[!scope resolution operator]]
[%example[!explicit qualification]]
[%overloading[!resolution[!scoping ambiguity]]]
Ambiguities can often be resolved by qualifying a name with its class name.

[enter:example]
[codeblock]
struct A {
  int f();
};

[codeblock:end]
[codeblock]
struct B {
  int f();
};

[codeblock:end]
[codeblock]
struct C : A, B {
  int f() { return A::f() + B::f(); }
};
[codeblock:end]
[exit:example]

[para]
[enter:note]
[:en]
A static member, a nested type or an enumerator defined in a base class [`T] can
unambiguously be found even if an object has more than one base class subobject
of type [`T].

[:en]
Two base class subobjects share the non-static member subobjects of their common
virtual base classes.
[exit:note]

[enter:example]
[codeblock]
struct V {
  int v;
};
struct A {
  int a;
  static int   s;
  enum { e };
};
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };

void f(D* pd) {
  pd->v++;          // [:en] OK: only one [`v] (virtual)
  pd->s++;          // [:en] OK: only one [`s] (static)
  int i = pd->e;    // [:en] OK: only one [`e] (enumerator)
  pd->a++;          // [:en] error, ambiguous: two [`a]s in [`D]
}
[codeblock:end]
[exit:example]

[para]
[enter:note]
[:en]
[%dominance[!virtual base class]]
When virtual base classes are used, a hidden declaration can be reached along a
path through the subobject lattice that does not pass through the hiding
declaration.

[:en]
This is not an ambiguity.

[:en]
The identical use with non-virtual base classes is an ambiguity; in that case
there is no unique instance of the name that hides all the others.
[exit:note]

[enter:example]
[codeblock]
struct V { int f();  int x; };
struct W { int g();  int y; };
struct B : virtual V, W {
  int f();  int x;
  int g();  int y;
};
struct C : virtual V, W { };

struct D : B, C { void glorp(); };
[codeblock:end]

[figure:graphviz@dot#fig:name
    [:en] Name lookup
    [:zh_CN] 
]
digraph virt {
    graph [nodesep=1.5, rankdir=BT];

    W1 [label = "W", shape=plaintext, height=.1, fontsize=24];
    V [shape=plaintext, height=.1, fontsize=24];
    W2 [label = "W", shape=plaintext, height=.1, fontsize=24];
    B [shape=plaintext, height=.1, fontsize=24];
    C [shape=plaintext, height=.1, fontsize=24];
    D [shape=plaintext, height=.1, fontsize=24];

    D -> B;
    D -> C;
    B -> V;
    C -> V;
    B -> W1;
    C -> W2;
}
[figure:end]

[para]
[enter:note]
[:en]
The names declared in [`V] and the left-hand instance of [`W] are hidden by
those in [`B], but the names declared in the right-hand instance of [`W] are not
hidden at all.
[exit:note]

[codeblock]
void D::glorp() {
  x++;              // [:en] OK: [`B::x] hides [`V::x]
  f();              // [:en] OK: [`B::f()] hides [`V::f()]
  y++;              // [:en] error: [`B::y] and [`C][=']s [`W::y]
  g();              // [:en] error: [`B::g()] and [`C][=']s [`W::g()]
}
[codeblock:end]
[exit:example]

[%  [:en] ambiguity[!class conversion]]

[para]
[:en]
An explicit or implicit conversion from a pointer to or an expression
designating an object of a derived class to a pointer or reference to one of its
base classes shall unambiguously refer to a unique object representing the base
class.

[enter:example]
[codeblock]
struct V { };
struct A { };
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };

void g() {
  D d;
  B* pb = &d;
  A* pa = &d;       // [:en] error, ambiguous: [`C][=']s [`A] or [`B][=']s [`A]?
  V* pv = &d;       // [:en] OK: only one [`V] subobject
}
[codeblock:end]
[exit:example]

[para]
[enter:note]
[:en]
Even if the result of name lookup is unambiguous, use of a name found in
multiple subobjects might still be ambiguous ([#conv.mem], [#expr.ref],
[#class.access.base]).
[exit:note]

[enter:example]
[codeblock]
struct B1 {
  void f();
  static void f(int);
  int i;
};
struct B2 {
  void f(double);
};
struct I1: B1 { };
struct I2: B1 { };

struct D: I1, I2, B2 {
  using B1::f;
  using B2::f;
  void g() {
    f();                        // [:en] Ambiguous conversion of [`this]
    f(0);                       // [:en] Unambiguous (static)
    f(0.0);                     // [:en] Unambiguous (only one [`B2])
    int B1::* mpB1 = &D::i;     // [:en] Unambiguous
    int D::* mpD = &D::i;       // [:en] Ambiguous conversion
  }
};
[codeblock:end][exit:example]
