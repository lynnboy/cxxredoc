[section#class.mi
    [:en] Multiple base classes
]

[:en]
[%multiple inheritance]
[%base class]

[para]
[:en]
A class can be derived from any number of base classes.

[enter:note]
[:en]
The use of more than one direct base class is often called multiple inheritance.
[exit:note]

[enter:example]
[codeblock]
class A { /* ... */ };
class B { /* ... */ };
class C { /* ... */ };
class D : public A, public B, public C { /* ... */ };
[codeblock:end]
[exit:example]

[para]
[:en]
[%layout[!class object]]
[%initialization[!order of]]
[enter:note]

[:en]
The order of derivation is not significant except as specified by the semantics
of initialization by constructor ([#class.base.init]), cleanup ([#class.dtor]),
and storage layout ([#class.mem], [#class.access.spec]).
[exit:note]

[para]
[:en]
A class shall not be specified as a direct base class of a derived class more
than once.

[enter:note]
[:en]
A class can be an indirect base class more than once and can be a direct and an
indirect base class.

[:en]
There are limited things that can be done with such a class.

[:en]
The non-static data members and member functions of the direct base class cannot
be referred to in the scope of the derived class. However, the static members,
enumerations and types can be unambiguously referred to.
[exit:note]

[enter:example]
[codeblock]
class X { /* ... */ };
class Y : public X, public X { /* ... */ };             // [:en] ill-formed

class L { public: int next;  /* ... */ };
class A : public L { /* ... */ };
class B : public L { /* ... */ };
class C : public A, public B { void f(); /* ... */ };   // [:en] well-formed
class D : public A, public L { void f(); /* ... */ };   // [:en] well-formed
[codeblock:end]
[exit:example]

[para]
[:en]
[%virtual base class]
A base class specifier that does not contain the keyword [`virtual], specifies a
[~non-virtual] base class.

A base class specifier that contains the keyword [`virtual], specifies a
[+virtual] base class.

For each distinct occurrence of a non-virtual base class in the class lattice of
the most derived class, the most derived object ([#intro.object]) shall contain
a corresponding distinct base class subobject of that type.

For each distinct base class that is specified virtual, the most derived object
shall contain a single base class subobject of that type.

[enter:example]
[:en]
for an object of class type [`C], each distinct occurrence of a (non-virtual)
base class [`L] in the class lattice of [`C] corresponds one-to-one with a
distinct [`L] subobject within the object of type [`C].

[:en]
Given the class [`C] defined above, an object of class [`C] will have two
subobjects of class [`L] as shown below.

[figure:graphviz@dot#fig:nonvirt
    [:en] Non-virtual base
    [:zh_CN] 
]
digraph nonvirt {
    graph [nodesep=1.5, rankdir=BT];

    L1 [label = "L", shape=plaintext, height=.1, fontsize=24];
    L2 [label = "L", shape=plaintext, height=.1, fontsize=24];
    A [shape=plaintext, height=.1, fontsize=24];
    B [shape=plaintext, height=.1, fontsize=24];
    C [shape=plaintext, height=.1, fontsize=24];

    C -> B;
    C -> A;
    B -> L2;
    A -> L1;
}
[figure:end]

[para]
[:en]
In such lattices, explicit qualification can be used to specify which subobject
is meant.

[:en]
The body of function [`C::f] could refer to the member [`next] of each [`L]
subobject:

[codeblock]
void C::f() { A::next = B::next; }      // [:en] well-formed
[codeblock:end]

[:en]
Without the [`A::] or [`B::] qualifiers, the definition of [`C::f] above would
be ill-formed because of ambiguity ([#class.member.lookup]).

[para]
[:en]
For another example,

[codeblock]
class V { /* ... */ };
class A : virtual public V { /* ... */ };
class B : virtual public V { /* ... */ };
class C : public A, public B { /* ... */ };
[codeblock:end]

[:en@~]
for an object [`c] of class type [`C], a single subobject of type [`V] is shared
by every base subobject of [`c] that has a [`virtual] base class of type [`V].

[:en]
Given the class [`C] defined above, an object of class [`C] will have one
subobject of class [`V], as shown below.

[:en]
[%DAG[!multiple inheritance]]
[%DAG[!virtual base class]]
[figure:graphviz@dot#fig:virt
    [:en] Virtual base
    [:zh_CN] 
]
digraph virt {
    graph [nodesep=1.5, rankdir=BT];

    V [shape=plaintext, height=.1, fontsize=24];
    A [shape=plaintext, height=.1, fontsize=24];
    B [shape=plaintext, height=.1, fontsize=24];
    C [shape=plaintext, height=.1, fontsize=24];

    C -> B;
    C -> A;
    B -> V;
    A -> V;
}
[figure:end]

[para]
[:en]
A class can have both virtual and non-virtual base classes of a given type.

[codeblock]
class B { /* ... */ };
class X : virtual public B { /* ... */ };
class Y : virtual public B { /* ... */ };
class Z : public B { /* ... */ };
class AA : public X, public Y, public Z { /* ... */ };
[codeblock:end]

[:en]
For an object of class [`AA], all [`virtual] occurrences of base class [`B] in
the class lattice of [`AA] correspond to a single [`B] subobject within the
object of type [`AA], and every other occurrence of a (non-virtual) base class
[`B] in the class lattice of [`AA] corresponds one-to-one with a distinct [`B]
subobject within the object of type [`AA].

[:en]
Given the class [`AA] defined above, class [`AA] has two subobjects of class
[`B]: [`Z][=']s [`B] and the virtual [`B] shared by [`X] and [`Y], as shown
below.

[%DAG[!virtual base class]]
[%DAG[!non-virtual base class]]
[%DAG[!multiple inheritance]]
[figure:graphviz@dot#fig:virtnonvirt
    [:en] Virtual and non-virtual base
    [:zh_CN] 
]
digraph virtnonvirt {
    graph [nodesep=1.5, rankdir=BT];

    B1 [label = "B", shape=plaintext, height=.1, fontsize=24];
    B2 [label = "B", shape=plaintext, height=.1, fontsize=24];
    AA [shape=plaintext, height=.1, fontsize=24];
    X [shape=plaintext, height=.1, fontsize=24];
    Y [shape=plaintext, height=.1, fontsize=24];
    Z [shape=plaintext, height=.1, fontsize=24];

    subgraph {
    AA -> X;
    AA -> Y;
    X  -> B1;
    Y  -> B1;
    }

    AA -> Z [weight=0];
    Z  -> B2;
}
[figure:end]

[exit:example]
