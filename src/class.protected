[section#class.protected
    [:en] Protected member access
]

[%[:en] access control[![`protected]]]

[para]
[:en]
An additional access check beyond those described earlier in Clause
[#class.access] is applied when a non-static data member or non-static member
function is a protected member of its naming class ([#class.access.base])

[footnote]
[:en]
This additional check does not apply to other members, e.g., static data members
or enumerator member constants.
[footnote:end]

[:en]
As described earlier, access to a protected member is granted because the
reference occurs in a friend or member of some class [`C].

[:en]
If the access is to form a pointer to member ([#expr.unary.op]), the
[~nested-name-specifier] shall denote [`C] or a class derived from [`C].

[:en]
All other accesses involve a (possibly implicit) object expression
([#expr.ref]).

[:en]
In this case, the class of the object expression shall be [`C] or a class
derived from [`C].

[enter:example]
[codeblock]
class B {
protected:
  int i;
  static int j;
};

class D1 : public B {
};

class D2 : public B {
  friend void fr(B*,D1*,D2*);
  void mem(B*,D1*);
};

void fr(B* pb, D1* p1, D2* p2) {
  pb->i = 1;                    // [:en] ill-formed
  p1->i = 2;                    // [:en] ill-formed
  p2->i = 3;                    // [:en] OK (access through a [`D2])
  p2->B::i = 4;                 // [:en] OK (access through a [`D2], even though
                                // [:en@~] naming class is [`B])
  int B::* pmi_B = &B::i;       // [:en] ill-formed
  int B::* pmi_B2 = &D2::i;     // [:en] OK (type of [`&D2::i] is [`int B::*])
  B::j = 5;                     // [:en] OK (because refers to static member)
  D2::j = 6;                    // [:en] OK (because refers to static member)
}

void D2::mem(B* pb, D1* p1) {
  pb->i = 1;                    // [:en] ill-formed
  p1->i = 2;                    // [:en] ill-formed
  i = 3;                        // [:en] OK (access through [`this])
  B::i = 4;                     // [:en] OK (access through [`this], qualification ignored)
  int B::* pmi_B = &B::i;       // [:en] ill-formed
  int B::* pmi_B2 = &D2::i;     // OK
  j = 5;                        // [:en] OK (because [`j] refers to static member)
  B::j = 6;                     // [:en] OK (because [`B::j] refers to static member)
}

void g(B* pb, D1* p1, D2* p2) {
  pb->i = 1;                    // [:en] ill-formed
  p1->i = 2;                    // [:en] ill-formed
  p2->i = 3;                    // [:en] ill-formed
}
[codeblock:end]
[exit:example]
