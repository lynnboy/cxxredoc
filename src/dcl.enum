[section#dcl.enum
    [:en] Enumeration declarations
]

[:en]
[%enumeration]
[%[`{}][![`enum] declaration]]
[%[`enum][!type of]]

[para]
[:en]
An enumeration is a distinct type ([#basic.compound]) with named constants.

[:en]
Its name becomes an [~enum-name], within its scope.

[syntax]
[rule enum-name [:zh_CN] ]
    [| identifier ]
[rule:end]

[rule enum-specifier [:zh_CN] ]
    [| enum-head [`{] [~:opt enumerator-list] [`}] ]
    [| enum-head [`{] enumerator-list [`,] [`}] ]
[rule:end]

[rule enum-head [:zh_CN] ]
    [| enum-key [~:opt attribute-specifier-seq] [~:opt identifier] [~:opt enum-base] ]
    [| enum-key [~:opt attribute-specifier-seq] nested-name-specifier identifier
        [~:opt enum-base] ]
[rule:end]

[rule opaque-enum-declaration [:zh_CN] ]
    [| enum-key [~:opt attribute-specifier-seq] identifier [~:opt enum-base] [`;] ]
[rule:end]

[rule enum-key [:zh_CN] ]
    [| [`enum] ]
    [| [`enum class] ]
    [| [`enum struct] ]
[rule:end]

[rule enum-base [:zh_CN] ]
    [| [`:] type-specifier-seq ]
[rule:end]

[rule enumerator-list [:zh_CN] ]
    [| enumerator-definition ]
    [| enumerator-list [`,] enumerator-definition ]
[rule:end]

[rule enumerator-definition [:zh_CN] ]
    [| enumerator ]
    [| enumerator [`=] constant-expression ]
[rule:end]

[rule enumerator [:zh_CN] ]
    [| identifier [~:opt attribute-specifier-seq] ]
[rule:end]
[syntax:end]

[:en]
The optional [~attribute-specifier-seq] in the [~enum-head] and the
[~opaque-enum-declaration] appertains to the enumeration; the attributes in that
[~attribute-specifier-seq] are thereafter considered attributes of the
enumeration whenever it is named.

[:en]
A [`:] following ["[`enum] [~identifier]] is parsed as part of an [~enum-base].

[enter:note]
[:en]
This resolves a potential ambiguity between the declaration of an enumeration
with an [~enum-base] and the declaration of an unnamed bit-field of enumeration
type.

[enter:example]
[codeblock]
   struct S {
     enum E : int {};
     enum E : int {};  // [:en] error: redeclaration of enumeration
   };
[codeblock:end]

[exit:example]
[exit:note]

[para]
[:en]
[%constant[!enumeration]]
[%enumeration]
[%enumeration[!unscoped]]
[%enumeration[!scoped]]
The enumeration type declared with an [~enum-key] of only [`enum] is an
[+unscoped enumeration], and its [~enumerator]s are [+unscoped enumerators].

[:en]
The [~enum-key]s [`enum class] and [`enum struct] are semantically equivalent;
an enumeration type declared with one of these is a [+scoped enumeration], and
its [~enumerator]s are [+scoped enumerators].

[:en]
The optional [~identifier] shall not be omitted in the declaration of a scoped
enumeration.

[:en]
The [~type-specifier-seq] of an [~enum-base] shall name an integral type; any
cv-qualification is ignored.

[:en]
An [~opaque-enum-declaration] declaring an unscoped enumeration shall not omit
the [~enum-base].

[:en]
The identifiers in an [~enumerator-list] are declared as constants, and can
appear wherever constants are required.

[:en]
[%enumerator[!value of]]
An [~enumerator-definition] with [`=] gives the associated [~enumerator] the
value indicated by the [~constant-expression].

[:en]
If the first [~enumerator] has no [~initializer], the value of the corresponding
constant is zero. An [~enumerator-definition] without an [~initializer] gives
the [~enumerator] the value obtained by increasing the value of the previous
[~enumerator] by one.

[enter:example]
[codeblock]
enum { a, b, c=0 };
enum { d, e, f=e+2 };
[codeblock:end]

[:en]
defines [`a], [`c], and [`d] to be zero, [`b] and
[`e] to be [`1], and [`f] to be [`3].
[exit:example]

[:en]
The optional [~attribute-specifier-seq] in an [~enumerator] appertains to that
enumerator.

[para]
[:en]
An [~opaque-enum-declaration] is either a redeclaration of an enumeration in the
current scope or a declaration of a new enumeration.

[enter:note]
[:en]
An enumeration declared by an [~opaque-enum-declaration] has fixed underlying
type and is a complete type.

[:en]
The list of enumerators can be provided in a later redeclaration with an
[~enum-specifier].
[exit:note]

[:en]
A scoped enumeration shall not be later redeclared as unscoped or with a
different underlying type.

[:en]
An unscoped enumeration shall not be later redeclared as scoped and each
redeclaration shall include an [~enum-base] specifying the same underlying type
as in the original declaration.

[para]
[:en]
If the [~enum-key] is followed by a [~nested-name-specifier], the
[~enum-specifier] shall refer to an enumeration that was previously declared
directly in the class or namespace to which the [~nested-name-specifier] refers
(i.e., neither inherited nor introduced by a [~using-declaration]), and the
[~enum-specifier] shall appear in a namespace enclosing the previous
declaration.

[para]
[:en]
[%[`enum][!type of]]
[%[`enum][!underlying type]]
Each enumeration defines a type that is different from all other types.

[:en]
Each enumeration also has an underlying type.

[:en]
The underlying type can be explicitly specified using an [~enum-base].

[:en]
For a scoped enumeration type, the underlying type is [`int] if it is not
explicitly specified. In both of these cases, the underlying type is said to be
[+fixed].

[:en]
Following the closing brace of an [~enum-specifier], each enumerator has the
type of its enumeration.

[:en]
If the underlying type is fixed, the type of each enumerator prior to the
closing brace is the underlying type and the [~constant-expression] in the
[~enumerator-definition] shall be a converted constant expression of the
underlying type ([#expr.const]).

[:en]
If the underlying type is not fixed, the type of each enumerator prior to the
closing brace is determined as follows:

[list]
[item]
[:en]
If an initializer is specified for an enumerator, the [~constant-expression]
shall be an integral constant expression ([#expr.const]).

[:en]
If the expression has unscoped enumeration type, the enumerator has the
underlying type of that enumeration type, otherwise it has the same type as the
expression.

[item]
[:en]
If no initializer is specified for the first enumerator, its type is an
unspecified signed integral type.

[item]
[:en]
Otherwise the type of the enumerator is the same as that of the preceding
enumerator unless the incremented value is not representable in that type, in
which case the type is an unspecified integral type sufficient to contain the
incremented value.

[:en]
If no such type exists, the program is ill-formed.
[list:end]

[para]
[:en]
An enumeration whose underlying type is fixed is an incomplete type from its
point of declaration ([#basic.scope.pdecl]) to immediately after its
[~enum-base] (if any), at which point it becomes a complete type.

[:en]
An enumeration whose underlying type is not fixed is an incomplete type from its
point of declaration to immediately after the closing [`}] of its
[~enum-specifier], at which point it becomes a complete type.

[para]
[:en]
For an enumeration whose underlying type is not fixed, the underlying type is an
integral type that can represent all the enumerator values defined in the
enumeration.

[:en]
If no integral type can represent all the enumerator values, the enumeration is
ill-formed.

[:en]
It is [%@impldef underlying type for enumeration] which integral type is used as
the underlying type except that the underlying type shall not be larger than
[`int] unless the value of an enumerator cannot fit in an [`int] or [`unsigned
int].

[:en]
If the [~enumerator-list] is empty, the underlying type is as if the enumeration
had a single enumerator with value 0.

[para]
[:en]
For an enumeration whose underlying type is fixed, the values of the enumeration
are the values of the underlying type.

[:en]
Otherwise, for an enumeration where [$e[_min]] is the smallest enumerator and
[$e[_max]] is the largest, the values of the enumeration are the values in the
range [$b[_min]] to [$b[_max]], defined as follows:

[:en]
Let [$K] be 1 for a two[=']s complement representation and 0 for a one[=']s
complement or sign-magnitude representation.

[$b[_max]] is the smallest value greater than or equal to [$max(|e[_min]| - K,
|e[_max]|)] and equal to [$2[^M]-1], where [$M] is a non-negative integer.

[$b[_min]] is zero if [$e[_min]] is non-negative and [$-(b[_max]+K)] otherwise.

[:en]
The size of the smallest bit-field large enough to hold all the values of the
enumeration type is [$max(M,1)] if [$b[_min]] is zero and [$M+1] otherwise.

[:en]
It is possible to define an enumeration that has values not defined by any of
its enumerators.

[:en]
If the [~enumerator-list] is empty, the values of the enumeration are as if the
enumeration had a single enumerator with value 0.

[footnote]
[:en]
This set of values is used to define promotion and conversion semantics for the
enumeration type.

[:en]
It does not preclude an expression of enumeration type from having a value that
falls outside this range.
[footnote:end]

[para]
[:en]
Two enumeration types are [def layout-compatible] if they have the same
[+underlying type].

[para]
[:en]
The value of an enumerator or an object of an unscoped enumeration type is
converted to an integer by integral promotion ([#conv.prom]).

[enter:example]
[%example[!enumeration]]
[codeblock]
  enum color { red, yellow, green=20, blue };
  color col = red;
  color* cp = &col;
  if (*cp == blue)              // ...
[codeblock:end]

[:en]
makes [`color] a type describing various colors, and then declares [`col] as an
object of that type, and [`cp] as a pointer to an object of that type.

[:en]
The possible values of an object of type [`color] are [`red], [`yellow],
[`green], [`blue]; these values can be converted to the integral values [`0],
[`1], [`20], and [`21].

[:en]
Since enumerations are distinct types, objects of type [`color] can be assigned
only values of type [`color].

[codeblock]
color c = 1;                    // [:en] error: type mismatch,
                                // [:en@~] no conversion from [`int] to [`color]

int i = yellow;                 // [:en] OK: [`yellow] converted to integral value [`1]
                                // [:en@~] integral promotion
[codeblock:end]

[:en]
Note that this implicit [`enum] to [`int] conversion is not provided for a
scoped enumeration:

[codeblock]
enum class Col { red, yellow, green };
int x = Col::red;               // [:en] error: no [`Col] to [`int] conversion
Col y = Col::red;
if (y) { }                      // [:en] error: no [`Col] to [`bool] conversion
[codeblock:end]

[exit:example]

[para]
[%class[!scope of enumerator]]
Each [~enum-name] and each unscoped [~enumerator] is declared in the scope that
immediately contains the [~enum-specifier].

[:en]
Each scoped [~enumerator] is declared in the scope of the enumeration.

[:en]
These names obey the scope rules defined for all names in ([#basic.scope]) and
([#basic.lookup]).

[enter:example]
[codeblock]
enum direction { left='l', right='r' }; 

void g()  { 
  direction d;                  // OK 
  d = left;                     // OK 
  d = direction::right;         // OK 
} 

enum class altitude { high='h', low='l' }; 

void h()  { 
  altitude a;                   // OK 
  a = high;                     // [:en] error: high not in scope 
  a = altitude::low;            // OK 
}
[codeblock:end]
[exit:example]

[:en]
[%member[!enumerator]]
An enumerator declared in class scope can be referred to using the class member
access operators ([`::], [`.] (dot) and [`->] (arrow)), see [#expr.ref].

[enter:example]
[codeblock]
struct X {
  enum direction { left='l', right='r' };
  int f(int i) { return i==left ? 0 : i==right ? 1 : 2; }
};

void g(X* p) {
  direction d;                  // [:en] error: [`direction] not in scope
  int i;
  i = p->f(left);               // [:en] error: [`left] not in scope
  i = p->f(X::right);           // OK
  i = p->f(p->left);            // OK
  // ...
}
[codeblock:end]
[exit:example]
