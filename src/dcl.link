[section#dcl.link
    [:en] Linkage specifications
]

[%:begin#specification.linkage
    [:en] specification [!linkage]
]

[para]
[:en]
All function types, function names with external linkage, and variable names
with external linkage have a [+language linkage].

[enter:note]
[:en]
Some of the properties associated with an entity with language linkage are
specific to each implementation and are not described here.

[:en]
For example, a particular language linkage may be associated with a particular
form of representing names of objects and functions with external linkage, or
with a particular calling convention, etc.
[exit:note]

[:en]
The default language linkage of all function types, function names, and variable
names is [=Cpp] language linkage.

[:en]
Two function types with different language linkages are distinct types even if
they are otherwise identical.

[para]
[:en]
Linkage ([#basic.link]) between [=Cpp] and  non-[=Cpp] code fragments can be
achieved using a [~linkage-specification]:

[:en]
[%[~linkage-specification]]
[%specification[!linkage[![`extern]]]]

[syntax]
[rule linkage-specification [:zh_CN] ]
    [| [`extern] string-literal [`{] [~:opt declaration-seq] [`}] ]
    [| [`extern] string-literal declaration ]
[rule:end]
[syntax:end]

[:en]
The [~string-literal] indicates the required language linkage.

[:en]
This International Standard specifies the semantics for the [~string-literal]s
[`"C"] and [`"C++"].

[:en]
Use of a [~string-literal] other than [`"C"] or [`"C++"] is
conditionally-supported, with [%@impldef semantics of linkage specifiers]
semantics.

[enter:note]
[:en]
Therefore, a linkage-specification with a [~string-literal] that is unknown to
the implementation requires a diagnostic.
[exit:note]

[enter:note]
[:en]
It is recommended that the spelling of the [~string-literal] be taken from the
document defining that language.

[:en]
For example, [`Ada] (not [`ADA]) and [`Fortran] or [`FORTRAN], depending on the
vintage.
[exit:note]

[para]
[:en]
[%specification[!linkage[!implementation-defined]]]
Every implementation shall provide for linkage to functions written in the C
programming language, [%C[!linkage to]] [`"C"], and linkage to [=Cpp] functions,
[`"C++"].

[enter:example]
[codeblock]
complex sqrt(complex);          // [:en] [=Cpp] linkage by default
extern "C" {
  double sqrt(double);          // [:en] C linkage
}
[codeblock:end]
[exit:example]

[para]
[:en]
[%specification[!linkage[!nesting]]]
Linkage specifications nest.

[:en]
When linkage specifications nest, the innermost one determines the language
linkage.

[:en]
A linkage specification does not establish a scope.

[:en]
A [~linkage-specification] shall occur only in namespace scope ([#basic.scope]).

[:en]
In a [~linkage-specification], the specified language linkage applies to the
function types of all function declarators, function names with external
linkage, and variable names with external linkage declared within the
[~linkage-specification].

[enter:example]
[codeblock]
extern "C" void f1(void(*pf)(int));
                                // [:en] the name [`f1] and its function type have C language
                                // [:en@~] linkage; [`pf] is a pointer to a C function
extern "C" typedef void FUNC();
FUNC f2;                        // [:en] the name [`f2] has [=Cpp] language linkage and the
                                // [:en@~] function[=']s type has C language linkage
extern "C" FUNC f3;             // [:en] the name of function [`f3] and the function[=']s type
                                // [:en@~] have C language linkage
void (*pf2)(FUNC*);             // [:en] the name of the variable [`pf2] has [=Cpp] linkage and
                                // [:en@~] the type of [`pf2] is pointer to [=Cpp] function that
                                // [:en@~] takes one parameter of type pointer to C function
extern "C" {
  static void f4();             // [:en] the name of the function f4 has
                                // [:en@~] internal linkage (not C language
                                // [:en@~] linkage) and the function[=']s type
                                // [:en@~] has C language linkage.
}

extern "C" void f5() {
  extern void f4();             // [:en] OK: Name linkage (internal)
                                // [:en@~] and function type linkage (C
                                // [:en@~] language linkage) obtained from
                                // [:en@~] previous declaration.
}

extern void f4();               // [:en] OK: Name linkage (internal)
                                // [:en@~] and function type linkage (C
                                // [:en@~] language linkage) obtained from
                                // [:en@~] previous declaration.

void f6() {
  extern void f4();             // [:en] OK: Name linkage (internal)
                                // [:en@~] and function type linkage (C
                                // [:en@~] language linkage) obtained from
                                // [:en@~] previous declaration.
}
[codeblock:end]
[exit:example]

[:en]
[%class[!linkage specification]]
A C language linkage is ignored in determining the language linkage of the names
of class members and the function type of class member functions.

[enter:example]
[codeblock]
extern "C" typedef void FUNC_c();
class C {
  void mf1(FUNC_c*);            // [:en] the name of the function [`mf1] and the member
                                // [:en@~] function[=']s type have [=Cpp] language linkage; the
                                // [:en@~] parameter has type pointer to C function
  FUNC_c mf2;                   // [:en] the name of the function [`mf2] and the member
                                // [:en@~] function[=']s type have [=Cpp] language linkage
  static FUNC_c* q;             // [:en] the name of the data member [`q] has [=Cpp] language
                                // [:en@~] linkage and the data member[=']s type is pointer to
                                // [:en@~] C function
};

extern "C" {
  class X {
    void mf();                  // [:en] the name of the function [`mf] and the member
                                // [:en@~] function[=']s type have [=Cpp] language linkage
    void mf2(void(*)());        // [:en] the name of the function [`mf2] has [=Cpp] language
                                // [:en@~] linkage; the parameter has type pointer to
                                // [:en@~] C function
  };
}
[codeblock:end]
[exit:example]

[para]
[:en]
If two declarations declare functions with the same name and
[~parameter-type-list] ([#dcl.fct]) to be members of the same namespace or
declare objects with the same name to be members of the same namespace and the
declarations give the names different language linkages, the program is
ill-formed; no diagnostic is required if the declarations appear in different
translation units.

[:en]
[%consistency[!linkage specification]]
Except for functions with [=Cpp] linkage, a function declaration without a
linkage specification shall not precede the first linkage specification for that
function.

[:en]
A function can be declared without a linkage specification after an explicit
linkage specification has been seen; the linkage explicitly specified in the
earlier declaration is not affected by such a function declaration.

[para]
[:en]
[%function[!linkage specification overloaded]]
At most one function with a particular name can have C language linkage.

[:en]
Two declarations for a function with C language linkage with the same function
name (ignoring the namespace names that qualify it) that appear in different
namespace scopes refer to the same function.

[:en]
Two declarations for a variable with C language linkage with the same name
(ignoring the namespace names that qualify it) that appear in different
namespace scopes refer to the same variable.

[:en]
An entity with C language linkage shall not be declared with the same name as a
variable in global scope, unless both declarations denote the same entity; no
diagnostic is required if the declarations appear in different translation
units.

[:en]
A variable with C language linkage shall not be declared with the same name as a
function with C language linkage (ignoring the namespace names that qualify the
respective names); no diagnostic is required if the declarations appear in
different translation units.

[enter:note]
[:en]
Only one definition for an entity with a given name with C language linkage may
appear in the program (see [#basic.def.odr]); this implies that such an entity
must not be defined in more than one namespace scope.
[exit:note]

[enter:example]
[codeblock]
int x;
namespace A {
  extern "C" int f();
  extern "C" int g() { return 1; }
  extern "C" int h();
  extern "C" int x();               // [:en] ill-formed: same name as global-space object [`x]
}

namespace B {
  extern "C" int f();               // [:en] [`A::f] and [`B::f] refer to the same function
  extern "C" int g() { return 1; }  // [:en] ill-formed, the function [`g]
                                    // [:en@~] with C language linkage has two definitions
}

int A::f() { return 98; }           // [:en] definition for the function [`f] with C language linkage
extern "C" int h() { return 97; }   // [:en] definition for the function [`h] with C language linkage
                                    // [:en] [`A::h] and [`::h] refer to the same function
[codeblock:end]
[exit:example]

[para]
[:en]
A declaration directly contained in a [~linkage-specification] is treated as if
it contains the [`extern] specifier ([#dcl.stc]) for the purpose of determining
the linkage of the declared name and whether it is a definition.

[:en]
Such a declaration shall not specify a storage class.

[enter:example]
[codeblock]
extern "C" double f();
static double f();                  // [:en] error
extern "C" int i;                   // [:en] declaration
extern "C" {
  int i;                            // [:en] definition
}
extern "C" static void g();         // [:en] error
[codeblock:end]
[exit:example]

[para]
[enter:note]
[:en]
Because the language linkage is part of a function type, when indirecting
through a pointer to C function, the function to which the resulting lvalue
refers is considered a C function.
[exit:note]

[para]
[:en]
[%object[!linkage specification]]
[%linkage[!implementation-defined object]]
Linkage from [=Cpp] to objects defined in other languages and to objects defined
in [=Cpp] from other languages is implementation-defined and language-dependent.

[:en]
Only where the object layout strategies of two language implementations are
similar enough can such linkage be achieved.

[%:end#specification.linkage]
