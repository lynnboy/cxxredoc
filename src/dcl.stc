[section#dcl.stc
    [:en] Storage class specifiers
]

[:en]
[%specifier[!storage class]]
[%declaration[!storage class]]
[%[`register]]
[%[`static]]
[%[`thread_local]]
[%[`extern]]
[%[`mutable]]

[para]
[:en]
The storage class specifiers are

[syntax]
[rule storage-class-specifier [:zh_CN] ]
    [| [`register] ]
    [| [`static] ]
    [| [`thread_local] ]
    [| [`extern] ]
    [| [`mutable] ]
[rule:end]
[syntax:end]

[:en]
At most one [~storage-class-specifier] shall appear in a given
[~decl-specifier-seq], except that [`thread_local] may appear with [`static] or 
[`extern].

[:en]
If [`thread_local] appears in any declaration of a variable it shall be present
in all declarations of that entity.

[:en]
If a  [~storage-class-specifier] appears in a [~decl-specifier-seq], there can
be no [`typedef] specifier in the same [~decl-specifier-seq] and the
[~init-declarator-list] of the declaration shall not be empty (except for an
anonymous union declared in a named namespace or in the global namespace, which
shall be declared [%specifier[![`static]]] [`static] ([#class.union])).

[:en]
The [~storage-class-specifier] applies to the name declared by each
[~init-declarator] in the list and not to any names declared by other
specifiers.

[:en]
A [~storage-class-specifier] other than [`thread_local] shall not be specified
in an explicit specialization ([#temp.expl.spec]) or an explicit instantiation
([#temp.explicit]) directive.

[para]
[:en]
[%restriction[![`register]]]
The [`register] specifier shall be applied only to names of variables declared
in a block ([#stmt.block]) or to function parameters ([#dcl.fct.def]).

[:en]
It specifies that the named variable has automatic storage duration
([#basic.stc.auto]).

[:en]
A variable declared without a [~storage-class-specifier] at block scope or
declared as a function parameter has automatic storage duration by default.

[para]
[:en]
[%declaration[![`register]]]
A [`register] specifier is a hint to the implementation that the variable so
declared will be heavily used.

[enter:note]
[:en]
The hint can be ignored and in most implementations it will be ignored if the
address of the variable is taken. This use is deprecated (see [#depr.register]).
[exit:note]

[para]
[:en]
The [`thread_local] specifier indicates that the named entity has thread storage
duration ([#basic.stc.thread]).

[:en]
It shall be applied only to the names of variables of namespace or block scope
and to the names of static data members.

[:en]
When [`thread_local] is applied to a variable of block scope the
[~storage-class-specifier] [`static] is implied if no other
[~storage-class-specifier] appears in the [~decl-specifier-seq].

[para]
[:en]
[%restriction[![`static]]]
The [`static] specifier can be applied only to names of variables and functions
and to anonymous unions ([#class.union]).

[:en]
There can be no [`static] function declarations within a block, nor any
[`static] function parameters.

[:en]
A [`static] specifier used in the declaration of a variable declares the
variable to have static storage duration ([#basic.stc.static]), unless
accompanied by the [`thread_local] specifier, which declares the variable to
have thread storage duration ([#basic.stc.thread]).

[:en]
A [`static] specifier can be used in declarations of class members;
[#class.static] describes its effect.

[:en]
[%[`static][!linkage of]]
For the linkage of a name declared with a [`static] specifier, see
[#basic.link].

[para]
[:en]
[%restriction[![`extern]]]
The [`extern] specifier can be applied only to the names of variables and
functions.

[:en]
The [`extern] specifier cannot be used in the declaration of class members or
function parameters.

[:en]
[%[`extern][!linkage of]]
[%consistency[!linkage]]
For the linkage of a name declared with an [`extern] specifier, see
[#basic.link].

[enter:note]
[:en]
The [`extern] keyword can also be used in [~explicit-instantiation]s and
[~linkage-specification]s, but it is not a [~storage-class-specifier] in such
contexts.
[exit:note]

[para]
[:en]
The linkages implied by successive declarations for a given entity shall agree.

[:en]
That is, within a given scope, each declaration declaring the same variable name
or the same overloading of a function name shall imply the same linkage.

[:en]
Each function in a given set of overloaded functions can have a different
linkage, however.

[enter:example]
[%  [:en] example[!linkage consistency]]

[codeblock]
static char* f();               // [:en] [`f()] has internal linkage
char* f()                       // [:en] [`f()] still has internal linkage
  { /* ... */ }

char* g();                      // [:en] [`g()] has external linkage
static char* g()                // [:en] error: inconsistent linkage
  { /* ... */ }

void h();
inline void h();                // [:en] external linkage

inline void l();
void l();                       // [:en] external linkage

inline void m();
extern void m();                // [:en] external linkage

static void n();
inline void n();                // [:en] internal linkage

static int a;                   // [:en] [`a] has internal linkage
int a;                          // [:en] error: two definitions

static int b;                   // [:en] [`b] has internal linkage
extern int b;                   // [:en] [`b] still has internal linkage

int c;                          // [:en] [`c] has external linkage
static int c;                   // [:en] error: inconsistent linkage

extern int d;                   // [:en] [`d] has external linkage
static int d;                   // [:en] error: inconsistent linkage
[codeblock:end]
[exit:example]

[para]
[:en]
[%declaration[!forward]]
The name of a declared but undefined class can be used in an [`extern]
declaration.

[:en]
Such a declaration can only be used in ways that do not require a complete class
type.

[enter:example]
[codeblock]
struct S;
extern S a;
extern S f();
extern void g(S);

void h() {
  g(a);                         // [:en] error: [`s] is incomplete
  f();                          // [:en] error: [`s] is incomplete
}
[codeblock:end]
[exit:example]

[para]
[:en]
The [`mutable] specifier shall appear only in the declaration of a non-static
data member ([#class.mem]) whose type is neither const-qualified nor a reference
type.

[enter:example]
[codeblock]
class X {
  mutable const int* p;         // OK
  mutable int* const q;         // [:en] ill-formed
};
[codeblock:end]
[exit:example]

[para]
[:en]
The [`mutable] specifier on a class data member nullifies a [`const] specifier
applied to the containing class object and permits modification of the mutable
class member even though the rest of the object is [`const] ([#dcl.type.cv]).
