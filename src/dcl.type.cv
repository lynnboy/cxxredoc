[section#dcl.type.cv
    [:en] The [~cv-qualifier]s
]

[:en]
[%specifier[!cv-qualifier]]
[%initialization[![`const]]]
[%type specifier[![`const]]]
[%type specifier[![`volatile]]]

[para]
[:en]
There are two [~cv-qualifiers], [`const] and [`volatile].

[:en]
Each [~cv-qualifier] shall appear at most once in a [~cv-qualifier-seq].

[:en]
If a [~cv-qualifier] appears in a [~decl-specifier-seq], the
[~init-declarator-list] of the declaration shall not be empty.

[enter:note]
[:en]
[#basic.type.qualifier] and [#dcl.fct] describe how cv-qualifiers affect object
and function types.
[exit:note]

[:en]
Redundant cv-qualifications are ignored.

[enter:note]
[:en]
For example, these could be introduced by typedefs.
[exit:note]

[para]
[enter:note]
[:en]
Declaring a variable [`const] can affect its linkage ([#dcl.stc]) and its
usability in constant expressions ([#expr.const]).

[:en]
As described in [#dcl.init], the definition of an object or subobject of
const-qualified type must specify an initializer or be subject to
default-initialization.
[exit:note]

[para]
[:en]
A pointer or reference to a cv-qualified type need not actually point or refer
to a cv-qualified object, but it is treated as if it does; a const-qualified
access path cannot be used to modify an object even if the object referenced is
a non-const object and can be modified through some other access path.

[enter:note]
[:en]
Cv-qualifiers are supported by the type system so that they cannot be
subverted without casting ([#expr.const.cast]).
[exit:note]

[para]
[:en]
[%[`const]-object[!undefined change to]]
Except that any class member declared [`mutable] ([#dcl.stc]) can be modified,
any attempt to modify a [`const] object during its lifetime ([#basic.life])
results in undefined behavior.

[enter:example]
[codeblock]
const int ci = 3;               // [:en] cv-qualified (initialized as required)
ci = 4;                         // [:en] ill-formed: attempt to modify [`const]

int i = 2;                      // [:en] not cv-qualified
const int* cip;                 // [:en] pointer to [`const int]
cip = &i;                       // [:en] OK: cv-qualified access path to unqualified
*cip = 4;                       // [:en] ill-formed: attempt to modify through ptr to [`const]

int* ip;
ip = const_cast<int*>(cip);     // [:en] cast needed to convert [`const int*] to [`int*]
*ip = 4;                        // [:en] defined: [`*ip] points to [`i], a non-[`const] object

const int* ciq = new const int (3);     // [:en] initialized as required
int* iq = const_cast<int*>(ciq);        // [:en] cast required
*iq = 4;                                // [:en] undefined: modifies a [`const] object
[codeblock:end]

[para]
[:en]
For another example

[codeblock]
struct X {
  mutable int i;
  int j;
};
struct Y {
  X x;
  Y();
};

const Y y;
y.x.i++;                        // [:en] well-formed: [`mutable] member can be modified
y.x.j++;                        // [:en] ill-formed: [`const]-qualified member modified
Y* p = const_cast<Y*>(&y);      // [:en] cast away const-ness of [`y]
p->x.i = 99;                    // [:en] well-formed: [`mutable] member can be modified
p->x.j = 99;                    // [:en] undefined: modifies a [`const] member
[codeblock:end]
[exit:example]

[para]
[:en]
What constitutes an access to an object that has volatile-qualified type is
implementation-defined.

[:en]
If an attempt is made to refer to an object defined with a volatile-qualified
type through the use of a glvalue with a non-volatile-qualified type, the
program behavior is undefined.

[para]
[:en]
[%type specifier[![`volatile]]]
[%[`volatile][!implementation-defined]]
[enter:note]
[:en]
[`volatile] is a hint to the implementation to avoid aggressive optimization
involving the object because the value of the object might be changed by means
undetectable by an implementation.

[:en]
Furthermore, for some implementations, [`volatile] might indicate that special
hardware instructions are required to access the object.

[:en]
See [#intro.execution] for detailed semantics.

[:en]
In general, the semantics of [`volatile] are intended to be the same in [=Cpp]
as they are in C.
[exit:note]
