[section:chapter#containers
    [:en] Containers library
]

[include containers.general]

[include container.requirements]

[/     1[sequences]{Sequence containers}/]
[section#sequences
    [:en] Sequence containers
]

[include sequences.general]

[include array]

[/     2[deque]{Class template [`deque}}/]
[section#deque
    [:en] Class template [`deque]
]

[include deque.overview]

[/     3[deque.cons]{[`deque} constructors, copy, and assignment}/]
[section#deque.cons
    [:en] [`deque] constructors, copy, and assignment
]

[%@library deque[!deque]]
[codeblock:declaration]
explicit deque(const Allocator&);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty [`deque], using the specified allocator.

[para:complexity]
[:en] Constant.
[exit:description]

[%@library deque[!deque]]
[codeblock:declaration]
explicit deque(size_type n, const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a [`deque] with [`n] default-inserted elements using the
specified allocator.

[para:requires]
[:en] [`T] shall be [`DefaultInsertable] into [`*this].

[para:complexity]
[:en] Linear in [`n].
[exit:description]

[%@library deque[!deque]]
[codeblock:declaration]
deque(size_type n, const T& value, const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a [`deque] with [`n] copies of [`value], using the specified
allocator.

[para:requires]
[:en] [`T] shall be [`CopyInsertable] into [`*this].

[para:complexity]
[:en] Linear in [`n].
[exit:description]

[%@library deque[!deque]]
[%@library deque[!deque]]
[codeblock:declaration]
template <class InputIterator>
  deque(InputIterator first, InputIterator last, const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a [`deque] equal to the range [=range[first,last)], using the
specified allocator.

[para:complexity]
[:en] Linear in [`distance(first, last)].
[exit:description]

[/     3[deque.capacity]{[`deque} capacity}/]
[section#deque.capacity
    [:en] [`deque] capacity
]

[%@library resize[!deque]]
[codeblock:declaration]
void resize(size_type sz);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`sz <= size()], equivalent to calling [`pop_back()] [`size() - sz]
times.

[:en] If [`size() < sz], appends [`sz - size()] default-inserted elements to the
sequence.

[para:requires]
[:en] [`T] shall be [`MoveInsertable] and [`DefaultInsertable] into [`*this].
[exit:description]

[%@library resize[!deque]]
[codeblock:declaration]
void resize(size_type sz, const T& c);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`sz <= size()], equivalent to calling [`pop_back()] [`size() - sz]
times.

[:en] If [`size() < sz], appends [`sz - size()] copies of [`c] to the sequence.

[para:requires]
[:en] [`T] shall be [`CopyInsertable] into [`*this].
[exit:description]

[%@library shrink_to_fit[!deque]]
[%@library deque[!shrink_to_fit]]
[codeblock:declaration]
void shrink_to_fit();
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`T] shall be [`MoveInsertable] into [`*this].

[para:complexity]
[:en] Linear in the size of the sequence.

[para:remarks]
[:en] [`shrink_to_fit] is a non-binding request to reduce memory use but does
not change the size of the sequence.

[enter:note]
[:en] The request is non-binding to allow latitude for implementation-specific
optimizations.
[exit:note]
[exit:description]

[/     3[deque.modifiers]{[`deque} modifiers}/]
[section#deque.modifiers
    [:en] [`deque] modifiers
]

[%@library insert[!deque]]
[%@library push_front[!deque]]
[%@library push_back[!deque]]
[%@library emplace[!deque]]
[codeblock:declaration]
iterator insert(const_iterator position, const T& x);
iterator insert(const_iterator position, T&& x);
iterator insert(const_iterator position, size_type n, const T& x);
template <class InputIterator>
  iterator insert(const_iterator position,
                  InputIterator first, InputIterator last);
iterator insert(const_iterator position, initializer_list<T>);

template <class... Args> void emplace_front(Args&&... args);
template <class... Args> void emplace_back(Args&&... args);
template <class... Args> iterator emplace(const_iterator position, Args&&... args);
void push_front(const T& x);
void push_front(T&& x);
void push_back(const T& x);
void push_back(T&& x);
[codeblock:end]

[enter:description]
[para:effects]
[:en] An insertion in the middle of the deque invalidates all the iterators and
references to elements of the deque.

[:en] An insertion at either end of the deque invalidates all the iterators to
the deque, but has no effect on the validity of references to elements of the
deque.

[para:notes]
[:en] If an exception is thrown other than by the copy constructor, move
constructor, assignment operator, or move assignment operator of [`T] there are
no effects.

[:en] If an exception is thrown while inserting a single element at either end,
there are no effects.

[:en] Otherwise, if an exception is thrown by the move constructor of a
non-[`CopyInsertable] [`T], the effects are unspecified.

[para:complexity]
[:en] The complexity is linear in the number of elements inserted plus the
lesser of the distances to the beginning and end of the deque.

[:en] Inserting a single element either at the beginning or end of a deque
always takes constant time and causes a single call to a constructor of [`T].
[exit:description]

[%@library erase[!deque]]
[codeblock:declaration]
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
[codeblock:end]

[enter:description]
[para:effects]
[:en] An erase operation that erases the last element of a deque invalidates
only the past-the-end iterator and all iterators and references to the erased
elements.

[:en] An erase operation that erases the first element of a deque but not the
last element invalidates only the erased elements.

[:en] An erase operation that erases neither the first element nor the last
element of a deque invalidates the past-the-end iterator and all iterators and
references to all the elements of the deque.

[para:complexity]
[:en] The number of calls to the destructor is the same as the number of
elements erased, but the number of calls to the assignment operator is no more
than the lesser of the number of elements before the erased elements and the
number of elements after the erased elements.

[para:throws]
[:en] Nothing unless an exception is thrown by the copy constructor, move
constructor, assignment operator, or move assignment operator of [`T].
[exit:description]

[/     3[deque.special]{[`deque} specialized algorithms}/]
[section#deque.special
    [:en] [`deque] specialized algorithms
]

[%@library swap[!deque]]
[%@library deque[!swap]]
[codeblock:declaration]
template <class T, class Allocator>
  void swap(deque<T, Allocator>& x, deque<T, Allocator>& y)
    noexcept(noexcept(x.swap(y)));
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
x.swap(y);
[codeblock:end]
[exit:description]

[/     2[forwardlist]{Class template [`forward_list}}/]
[section#forwardlist
    [:en] Class template [`forward_list]
]

[/     3[forwardlist.overview]{Class template [`forward_list} overview}/]
[section#forwardlist.overview
    [:en] Class template [`forward_list] overview
]

[para]
[:en] A [`forward_list] is a container that supports forward iterators and
allows constant time insert and erase operations anywhere within the sequence,
with storage management handled automatically.

[:en] Fast random access to list elements is not supported.

[enter:note]
[:en] It is intended that [`forward_list] have zero space or time overhead
relative to a hand-written C-style singly linked list.

[:en] Features that would conflict with that goal have been omitted.
[exit:note]

[para]
[:en] A [`forward_list] satisfies all of the requirements of a container
(Table [#tab:containers.container.requirements]), except that the [`size()]
member function is not provided and [`operator==] has linear complexity.

[:en] A [`forward_list] also satisfies all of the requirements for an
allocator-aware container (Table [#tab:containers.allocatoraware]).

[:en] In addition, a [`forward_list] provides the [`assign] member functions
(Table [#tab:containers.sequence.requirements]) and several of the optional
container requirements (Table [#tab:containers.sequence.optional]).

[:en] Descriptions are provided here only for operations on [`forward_list] that
are not described in that table or for operations where there is additional
semantic information.

[para]
[enter:note]
[:en] Modifying any list requires access to the element preceding the first
element of interest, but in a [`forward_list] there is no constant-time way to
access a preceding element.

[:en] For this reason, ranges that are modified, such as those supplied to
[`erase] and [`splice], must be open at the beginning.
[exit:note]

[codeblock:synopsis [special implementation-defined] ]
namespace std {
  template <class T, class Allocator = allocator<T> >
  class forward_list {
  public:
    // [:en] types:
    typedef value_type&                                           reference;
    typedef const value_type&                                     const_reference;
    typedef implementation-defined iterator;       // [:en] See [#container.requirements]
    typedef implementation-defined const_iterator; // [:en] See [#container.requirements]
    typedef implementation-defined size_type;      // [:en] See [#container.requirements]
    typedef implementation-defined difference_type;// [:en] See [#container.requirements]
    typedef T value_type;
    typedef Allocator allocator_type;
    typedef typename allocator_traits<Allocator>::pointer         pointer;
    typedef typename allocator_traits<Allocator>::const_pointer   const_pointer;

    // [:en] [#forwardlist.cons], construct/copy/destroy:
    forward_list() : forward_list(Allocator()) { }
    explicit forward_list(const Allocator&);
    explicit forward_list(size_type n, const Allocator& = Allocator());
    forward_list(size_type n, const T& value,
                 const Allocator& = Allocator());
    template <class InputIterator>
      forward_list(InputIterator first, InputIterator last,
                   const Allocator& = Allocator());
    forward_list(const forward_list& x);
    forward_list(forward_list&& x);
    forward_list(const forward_list& x, const Allocator&);
    forward_list(forward_list&& x, const Allocator&);
    forward_list(initializer_list<T>, const Allocator& = Allocator());
    ~forward_list();
    forward_list& operator=(const forward_list& x);
    forward_list& operator=(forward_list&& x)
      noexcept(allocator_traits<Allocator>::is_always_equal::value);
    forward_list& operator=(initializer_list<T>);
    template <class InputIterator>
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T& t);
    void assign(initializer_list<T>);
    allocator_type get_allocator() const noexcept;

    // [:en] [#forwardlist.iter], iterators:
    iterator before_begin() noexcept;
    const_iterator before_begin() const noexcept;
    iterator begin() noexcept;
    const_iterator begin() const noexcept;
    iterator end() noexcept;
    const_iterator end() const noexcept;

    const_iterator cbegin() const noexcept;
    const_iterator cbefore_begin() const noexcept;
    const_iterator cend() const noexcept;

    // [:en] capacity:
    bool empty() const noexcept;
    size_type max_size() const noexcept;

    // [:en] [#forwardlist.access], element access:
    reference front();
    const_reference front() const;

    // [:en] [#forwardlist.modifiers], modifiers:
    template <class... Args> void emplace_front(Args&&... args);
    void push_front(const T& x);
    void push_front(T&& x);
    void pop_front();

    template <class... Args> iterator emplace_after(const_iterator position, Args&&... args);
    iterator insert_after(const_iterator position, const T& x);
    iterator insert_after(const_iterator position, T&& x);

    iterator insert_after(const_iterator position, size_type n, const T& x);
    template <class InputIterator>
      iterator insert_after(const_iterator position, InputIterator first, InputIterator last);
    iterator insert_after(const_iterator position, initializer_list<T> il);

    iterator erase_after(const_iterator position);
    iterator erase_after(const_iterator position, const_iterator last);
    void swap(forward_list&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value);

    void resize(size_type sz);
    void resize(size_type sz, const value_type& c);
    void clear() noexcept;

    // [:en] [#forwardlist.ops], forward_list operations:
    void splice_after(const_iterator position, forward_list& x);
    void splice_after(const_iterator position, forward_list&& x);
    void splice_after(const_iterator position, forward_list& x,
                      const_iterator i);
    void splice_after(const_iterator position, forward_list&& x,
                      const_iterator i);
    void splice_after(const_iterator position, forward_list& x,
                      const_iterator first, const_iterator last);
    void splice_after(const_iterator position, forward_list&& x,
                      const_iterator first, const_iterator last);

    void remove(const T& value);
    template <class Predicate> void remove_if(Predicate pred);

    void unique();
    template <class BinaryPredicate> void unique(BinaryPredicate binary_pred);

    void merge(forward_list& x);
    void merge(forward_list&& x);
    template <class Compare> void merge(forward_list& x, Compare comp);
    template <class Compare> void merge(forward_list&& x, Compare comp);

    void sort();
    template <class Compare> void sort(Compare comp);

    void reverse() noexcept;
  };

  // [:en] Comparison operators
  template <class T, class Allocator>
    bool operator==(const forward_list<T, Allocator>& x, const forward_list<T, Allocator>& y);
  template <class T, class Allocator>
    bool operator< (const forward_list<T, Allocator>& x, const forward_list<T, Allocator>& y);
  template <class T, class Allocator>
    bool operator!=(const forward_list<T, Allocator>& x, const forward_list<T, Allocator>& y);
  template <class T, class Allocator>
    bool operator> (const forward_list<T, Allocator>& x, const forward_list<T, Allocator>& y);
  template <class T, class Allocator>
    bool operator>=(const forward_list<T, Allocator>& x, const forward_list<T, Allocator>& y);
  template <class T, class Allocator>
    bool operator<=(const forward_list<T, Allocator>& x, const forward_list<T, Allocator>& y);

  // [:en] [#forwardlist.spec], specialized algorithms:
  template <class T, class Allocator>
    void swap(forward_list<T, Allocator>& x, forward_list<T, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
[codeblock:end]

[/     3[forwardlist.cons]{[`forward_list} constructors, copy, assignment}/]
[section#forwardlist.cons
    [:en] [`forward_list] constructors, copy, assignment
]

[%@library forward_list[!forward_list]]
[%@library forward_list[!forward_list]]
[codeblock:declaration]
explicit forward_list(const Allocator&);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty [`forward_list] object using the specified allocator.

[para:complexity]
[:en] Constant.
[exit:description]

[%@library forward_list[!forward_list]]
[%@library forward_list[!forward_list]]
[codeblock:declaration]
explicit forward_list(size_type n, const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a [`forward_list] object with [`n] default-inserted elements
using the specified allocator.

[para:requires]
[:en] [`T] shall be [`DefaultInsertable] into [`*this].

[para:complexity]
[:en] Linear in [`n].
[exit:description]

[%@library forward_list[!forward_list]]
[%@library forward_list[!forward_list]]
[codeblock:declaration]
forward_list(size_type n, const T& value, const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a [`forward_list] object with [`n] copies of [`value] using the
specified allocator.

[para:requires]
[:en] [`T] shall be [`CopyInsertable] into [`*this].

[para:complexity]
[:en] Linear in [`n].
[exit:description]

[%@library forward_list[!forward_list]]
[%@library forward_list[!forward_list]]
[codeblock:declaration]
template <class InputIterator>
  forward_list(InputIterator first, InputIterator last, const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a [`forward_list] object equal to the range
[=range[first,last)].

[para:complexity]
[:en] Linear in [`distance(first, last)].
[exit:description]

[/     3[forwardlist.iter]{[`forward_list} iterators}/]
[section#forwardlist.iter
    [:en] [`forward_list] iterators
]

[%@library before_begin[!forward_list]]
[%@library forward_list[!before_begin]]
[%@library cbefore_begin[!forward_list]]
[%@library forward_list[!cbefore_begin]]
[codeblock:declaration]
iterator before_begin() noexcept;
const_iterator before_begin() const noexcept;
const_iterator cbefore_begin() const noexcept;
[codeblock:end]

[enter:description]
[para:returns]
[:en] A non-dereferenceable iterator that, when incremented, is equal to the
iterator returned by [`begin()].

[para:effects]
[:en] [`cbefore_begin()] is equivalent to
[`const_cast<forward_list const&>(*this).before_begin()].

[para:remarks]
[:en] [`before_begin() == end()] shall equal [`false].
[exit:description]

[/     3[forwardlist.access]{[`forward_list} element access}/]
[section#forwardlist.access
    [:en] [`forward_list] element access
]

[%@library front[!forward_list]]
[%@library forward_list[!front]]
[codeblock:declaration]
reference front();
const_reference front() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`*begin()]
[exit:description]

[/     3[forwardlist.modifiers]{[`forward_list} modifiers}/]
[section#forwardlist.modifiers
    [:en] [`forward_list] modifiers
]

[para]
[:en] None of the overloads of [`insert_after] shall affect the validity of
iterators and references, and [`erase_after] shall invalidate only iterators and
references to the erased elements.

[:en] If an exception is thrown during [`insert_after] there shall be no effect.

[:en] Inserting [`n] elements into a [`forward_list] is linear in [`n], and the
number of calls to the copy or move constructor of [`T] is exactly equal to
[`n].

[:en] Erasing [`n] elements from a [`forward_list] is linear in [`n] and the
number of calls to the destructor of type [`T] is exactly equal to [`n].

[%@library emplace_front[!forward_list]]
[%@library forward_list[!emplace_front]]
[codeblock:declaration]
template <class... Args> void emplace_front(Args&&... args);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Inserts an object of type [`value_type] constructed with
[`value_type(std::forward<Args>(args)...)] at the beginning of the list.
[exit:description]

[%@library push_front[!forward_list]]
[%@library forward_list[!push_front]]
[codeblock:declaration]
void push_front(const T& x);
void push_front(T&& x);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Inserts a copy of [`x] at the beginning of the list.
[exit:description]


[%@library pop[!forward_list]]
[%@library forward_list[!pop]]
[codeblock:declaration]
void pop_front();
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`erase_after(before_begin())]
[exit:description]

[%@library insert_after[!forward_list]]
[%@library forward_list[!insert_after]]
[codeblock:declaration]
iterator insert_after(const_iterator position, const T& x);
iterator insert_after(const_iterator position, T&& x);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`position] is [`before_begin()] or is a dereferenceable iterator in the
range [=range[begin(),end())].

[para:effects]
[:en] Inserts a copy of [`x] after [`position].

[para:returns]
[:en] An iterator pointing to the copy of [`x].
[exit:description]

[%@library insert_after[!forward_list]]
[%@library forward_list[!insert_after]]
[codeblock:declaration]
iterator insert_after(const_iterator position, size_type n, const T& x);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`position] is [`before_begin()] or is a dereferenceable iterator in the
range [=range[begin(),end())].

[para:effects]
[:en] Inserts [`n] copies of [`x] after [`position].

[para:returns]
[:en] An iterator pointing to the last inserted copy of [`x] or [`position] if
[`n == 0].
[exit:description]

[%@library insert_after[!forward_list]]
[%@library forward_list[!insert_after]]
[codeblock:declaration]
template <class InputIterator>
  iterator insert_after(const_iterator position, InputIterator first, InputIterator last);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`position] is [`before_begin()] or is a dereferenceable iterator in the
range [=range[begin(),end())].

[:en] [`first] and [`last] are not iterators in [`*this].

[para:effects]
[:en] Inserts copies of elements in [=range[first,last)] after [`position].

[para:returns]
[:en] An iterator pointing to the last inserted element or [`position] if
[`first == last].
[exit:description]

[%@library insert_after[!forward_list]]
[%@library forward_list[!insert_after]]
[codeblock:declaration]
iterator insert_after(const_iterator position, initializer_list<T> il);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`insert_after(p, il.begin(), il.end())].

[para:returns]
[:en] An iterator pointing to the last inserted element or [`position] if [`il]
is empty.
[exit:description]


[%@library emplace_after[!forward_list]]
[%@library forward_list[!emplace_after]]
[codeblock:declaration]
template <class... Args>
  iterator emplace_after(const_iterator position, Args&&... args);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`position] is [`before_begin()] or is a dereferenceable iterator in the
range [=range[begin(),end())].

[para:effects]
[:en] Inserts an object of type [`value_type] constructed with
[`value_type(std::forward<Args>(args)...)] after [`position].

[para:returns]
[:en] An iterator pointing to the new object.
[exit:description]

[%@library erase_after[!forward_list]]
[%@library forward_list[!erase_after]]
[codeblock:declaration]
iterator erase_after(const_iterator position);
[codeblock:end]

[enter:description]
[para:requires]
[:en] The iterator following [`position] is dereferenceable.

[para:effects]
[:en] Erases the element pointed to by the iterator following [`position].

[para:returns]
[:en] An iterator pointing to the element following the one that was erased, or
[`end()] if no such element exists.

[para:throws]
[:en] Nothing.
[exit:description]

[%@library erased[!forward_list]]
[%@library forward_list[!erased]]
[codeblock:declaration]
iterator erase_after(const_iterator position, const_iterator last);
[codeblock:end]

[enter:description]
[para:requires]
[:en] All iterators in the range [=orange(position,last)] are dereferenceable.

[para:effects]
[:en] Erases the elements in the range [=orange(position,last)].

[para:returns]
[:en] [`last].

[para:throws]
[:en] Nothing.
[exit:description]

[%@library resize[!forward_list]]
[%@library forward_list[!resize]]
[codeblock:declaration]
void resize(size_type sz);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`sz < distance(begin(), end())], erases the last [`distance(begin(),
end()) - sz] elements from the list.

[:en] Otherwise, inserts [`sz - distance(begin(), end())] default-inserted
elements at the end of the list.

[para:requires]
[:en] [`T] shall be [`DefaultInsertable] into [`*this].
[exit:description]

[codeblock:declaration]
void resize(size_type sz, const value_type& c);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`sz < distance(begin(), end())], erases the last [`distance(begin(),
end()) - sz] elements from the list. Otherwise, inserts [`sz - distance(begin(),
end())] elements at the end of the list such that each new element, [`e], is
initialized by a method equivalent to calling
[`allocator_traits<allocator_type>::construct(get_allocator(),
std::addressof(e), c)].

[para:requires]
[:en] [`T] shall be [`CopyInsertable] into [`*this].
[exit:description]


[%@library clear[!forward_list]]
[%@library forward_list[!clear]]
[codeblock:declaration]
void clear() noexcept;
[codeblock:end]

[enter:description]
[para:effects]
[:en] Erases all elements in the range [=range[begin(),end())].

[para:remarks]
[:en] Does not invalidate past-the-end iterators.
[exit:description]

[/     3[forwardlist.ops]{[`forward_list} operations}/]
[section#forwardlist.ops
    [:en] [`forward_list] operations
]

[%@library splice_after[!forward_list]]
[%@library forward_list[!splice_after]]
[codeblock:declaration]
void splice_after(const_iterator position, forward_list& x);
void splice_after(const_iterator position, forward_list&& x);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`position] is [`before_begin()] or is a dereferenceable iterator in the
range [=range[begin(),end())].

[:en] [`get_allocator() == x.get_allocator()].

[:en] [`&x != this].

[para:effects]
[:en] Inserts the contents of [`x] after [`position], and [`x] becomes empty.

[:en] Pointers and references to the moved elements of [`x] now refer to those
same elements but as members of [`*this].

[:en] Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into [`*this], not into [`x].

[para:throws]
[:en] Nothing.

[para:complexity] [$[=bigoh]([`distance(x.begin(), x.end())])]
[exit:description]

[%@library splice_after[!forward_list]]
[%@library forward_list[!splice_after]]
[codeblock:declaration]
void splice_after(const_iterator position, forward_list& x, const_iterator i);
void splice_after(const_iterator position, forward_list&& x, const_iterator i);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`position] is [`before_begin()] or is a dereferenceable iterator in the
range [=range[begin(),end())].

[:en] The iterator following [`i] is a dereferenceable iterator in [`x].

[:en] [`get_allocator() == x.get_allocator()].

[para:effects]
[:en] Inserts the element following [`i] into [`*this], following [`position],
and removes it from [`x].

[:en] The result is unchanged if [`position == i] or [`position == ++i].

[:en] Pointers and references to [`*++i] continue to refer to the same element
but as a member of [`*this].

[:en] Iterators to [`*++i] continue to refer to the same element, but now behave
as iterators into [`*this], not into [`x].

[para:throws]
[:en] Nothing.

[para:complexity]
[$[=bigoh](1)]
[exit:description]

[%@library splice_after[!forward_list]]
[%@library forward_list[!splice_after]]
[codeblock:declaration]
void splice_after(const_iterator position, forward_list& x,
                  const_iterator first, const_iterator last);
void splice_after(const_iterator position, forward_list&& x,
                  const_iterator first, const_iterator last);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`position] is [`before_begin()] or is a dereferenceable iterator in the
range [=range[begin(),end())].

[:en] [=orange(first,last)] is a valid range in [`x], and all iterators in the
range [=orange(first,last)] are dereferenceable.

[:en] [`position] is not an iterator in the range [=orange(first,last)].

[:en] [`get_allocator() == x.get_allocator()].

[para:effects]
[:en] Inserts elements in the range [=orange(first,last)] after [`position] and
removes the elements from [`x].

[:en] Pointers and references to the moved elements of [`x] now refer to those
same elements but as members of [`*this].

[:en] Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into [`*this], not into [`x].

[para:complexity]
[$[=bigoh]([`distance(first, last)])]
[exit:description]

[%@library remove[!forward_list]]
[%@library forward_list[!remove]]
[%@library remove_if[!forward_list]]
[%@library forward_list[!remove_if]]
[codeblock:declaration]
void remove(const T& value);
template <class Predicate> void remove_if(Predicate pred);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Erases all the elements in the list referred by a list iterator [`i] for
which the following conditions hold: [`*i == value] (for [`remove()]),
[`pred(*i)] is true (for [`remove_if()]).

[:en] Invalidates only the iterators and references to the erased elements.

[para:throws]
[:en] Nothing unless an exception is thrown by the equality comparison or the
predicate.

[para:remarks]
[:en] Stable ([#algorithm.stable]).

[para:complexity]
[:en] Exactly [`distance(begin(), end())] applications of the corresponding
predicate.
[exit:description]

[%@library unique[!forward_list]]
[%@library forward_list[!unique]]
[codeblock:declaration]
void unique();
template <class BinaryPredicate> void unique(BinaryPredicate pred);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Erases all but the first element from every consecutive group of equal
elements referred to by the iterator [`i] in the range [=range[first + 1,last)]
for which [`*i == *(i-1)] (for the version with no arguments) or [`pred(*i, *(i
- 1))] (for the version with a predicate argument) holds.

[:en] Invalidates only the iterators and references to the erased elements.

[para:throws]
[:en] Nothing unless an exception is thrown by the equality comparison or the
predicate.

[para:complexity]
[:en] If the range [=range[first,last)] is not empty, exactly [`(last - first)
- 1] applications of the corresponding predicate, otherwise no applications of
the predicate.
[exit:description]

[%@library merge[!forward_list]]
[%@library forward_list[!merge]]
[codeblock:declaration]
void merge(forward_list& x);
void merge(forward_list&& x);
template <class Compare> void merge(forward_list& x, Compare comp);
template <class Compare> void merge(forward_list&& x, Compare comp);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`comp] defines a strict weak ordering ([#alg.sorting]), and [`*this] and
[`x] are both sorted according to this ordering.

[:en] [`get_allocator() == x.get_allocator()].

[para:effects]
[:en] Merges the two sorted ranges [`[begin(), end())] and [`[x.begin(),
x.end())].

[:en] [`x] is empty after the merge.

[:en] If an exception is thrown other than by a comparison there are no effects.

[:en] Pointers and references to the moved elements of [`x] now refer to those
same elements but as members of [`*this].

[:en] Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into [`*this], not into [`x].

[para:remarks]
[:en] Stable ([#algorithm.stable]). The behavior is undefined if
[`this->get_allocator() != x.get_allocator()].

[para:complexity]
[:en] At most [`distance(begin(), end()) + distance(x.begin(), x.end()) - 1]
comparisons.
[exit:description]

[%@library sort[!forward_list]]
[%@library forward_list[!sort]]
[codeblock:declaration]
void sort();
template <class Compare> void sort(Compare comp);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`operator<] (for the version with no arguments) or [`comp] (for the
version with a comparison argument) defines a strict weak ordering
([#alg.sorting]).

[para:effects]
[:en] Sorts the list according to the [`operator<] or the [`comp] function
object.

[:en] If an exception is thrown the order of the elements in [`*this] is
unspecified.

[:en] Does not affect the validity of iterators and references.

[para:remarks]
[:en] Stable ([#algorithm.stable]).

[para:complexity]
[:en] Approximately [$N] log [$N] comparisons, where [$N] is [`distance(begin(),
end())].
[exit:description]

[%@library reverse[!forward_list]]
[%@library forward_list[!reverse]]
[codeblock:declaration]
void reverse() noexcept;
[codeblock:end]

[enter:description]
[para:effects]
[:en] Reverses the order of the elements in the list.

[:en] Does not affect the validity of iterators and references.

[para:complexity]
[:en] Linear time.
[exit:description]

[/     3[forwardlist.spec]{[`forward_list} specialized algorithms}/]
[section#forwardlist.spec
    [:en] [`forward_list] specialized algorithms
]

[%@library swap[!forward_list]]
[%@library forward_list[!swap]]
[codeblock:declaration]
template <class T, class Allocator>
  void swap(forward_list<T, Allocator>& x, forward_list<T, Allocator>& y)
    noexcept(noexcept(x.swap(y)));
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`x.swap(y)]
[exit:description]

[/     2[list]{Class template [`list}}/]
[section#list
    [:en] Class template [`list]
]

[/     3[list.overview]{Class template [`list} overview}/]
[section#list.overview
    [:en] Class template [`list] overview
]

[para]
[:en]
[%@library list]
A [`list] is a sequence container that supports bidirectional iterators and
allows constant time insert and erase operations anywhere within the sequence,
with storage management handled automatically.

[:en] Unlike vectors ([#vector]) and deques ([#deque]), fast random access to
list elements is not supported, but many algorithms only need sequential access
anyway.

[para]
[:en] A [`list] satisfies all of the requirements of a container, of
a reversible container (given in two tables in [#container.requirements]), of
a sequence container, including most of the optional sequence container
requirements ([#sequence.reqmts]), and of an allocator-aware container (Table
[#tab:containers.allocatoraware]).

[:en] The exceptions are the [`operator[`]] and [`at] member functions, which
are not provided.

[footnote]
[:en] These member functions are only provided by containers whose iterators are
random access iterators.
[footnote:end]

[:en] Descriptions are provided here only for operations on [`list] that are not
described in one of these tables or for operations where there is additional
semantic information.

[codeblock:synopsis [special implementation-defined] ]
namespace std {
  template <class T, class Allocator = allocator<T> >
  class list {
  public:
    // [:en] types:
    typedef value_type&                                             reference;
    typedef const value_type&                                       const_reference;
    typedef implementation-defined                iterator;       // [:en] see [#container.requirements]
    typedef implementation-defined                const_iterator; // [:en] see [#container.requirements]
    typedef implementation-defined                size_type;      // [:en] see [#container.requirements]
    typedef implementation-defined                difference_type;// [:en] see [#container.requirements]
    typedef T                                     value_type;
    typedef Allocator                             allocator_type;
    typedef typename allocator_traits<Allocator>::pointer           pointer;
    typedef typename allocator_traits<Allocator>::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // [:en] [#list.cons], construct/copy/destroy:
    list() : list(Allocator()) { }
    explicit list(const Allocator&);
    explicit list(size_type n, const Allocator& = Allocator());
    list(size_type n, const T& value, const Allocator& = Allocator());
    template <class InputIterator>
      list(InputIterator first, InputIterator last, const Allocator& = Allocator());
    list(const list& x);
    list(list&& x);
    list(const list&, const Allocator&);
    list(list&&, const Allocator&);
    list(initializer_list<T>, const Allocator& = Allocator());
   ~list();
    list& operator=(const list& x);
    list& operator=(list&& x)
      noexcept(allocator_traits<Allocator>::is_always_equal::value);
    list& operator=(initializer_list<T>);
    template <class InputIterator>
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T& t);
    void assign(initializer_list<T>);
    allocator_type get_allocator() const noexcept;

    // [:en] iterators:
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;
    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // [:en] [#list.capacity], capacity:
    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    void      resize(size_type sz);
    void      resize(size_type sz, const T& c);

    // [:en] element access:
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // [:en] [#list.modifiers], modifiers:
    template <class... Args> void emplace_front(Args&&... args);
    void pop_front();
    template <class... Args> void emplace_back(Args&&... args);
    void push_front(const T& x);
    void push_front(T&& x);
    void push_back(const T& x);
    void push_back(T&& x);
    void pop_back();

    template <class... Args> iterator emplace(const_iterator position, Args&&... args);
    iterator insert(const_iterator position, const T& x);
    iterator insert(const_iterator position, T&& x);
    iterator insert(const_iterator position, size_type n, const T& x);
    template <class InputIterator>
      iterator insert(const_iterator position, InputIterator first,
                      InputIterator last);
    iterator insert(const_iterator position, initializer_list<T> il);

    iterator erase(const_iterator position);
    iterator erase(const_iterator position, const_iterator last);
    void     swap(list&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value);
    void     clear() noexcept;

    // [:en] [#list.ops], list operations:
    void splice(const_iterator position, list& x);
    void splice(const_iterator position, list&& x);
    void splice(const_iterator position, list& x, const_iterator i);
    void splice(const_iterator position, list&& x, const_iterator i);
    void splice(const_iterator position, list& x,
                const_iterator first, const_iterator last);
    void splice(const_iterator position, list&& x,
                const_iterator first, const_iterator last);

    void remove(const T& value);
    template <class Predicate> void remove_if(Predicate pred);

    void unique();
    template <class BinaryPredicate>
      void unique(BinaryPredicate binary_pred);

    void merge(list& x);
    void merge(list&& x);
    template <class Compare> void merge(list& x, Compare comp);
    template <class Compare> void merge(list&& x, Compare comp);

    void sort();
    template <class Compare> void sort(Compare comp);

    void reverse() noexcept;
  };

  template <class T, class Allocator>
    bool operator==(const list<T, Allocator>& x, const list<T, Allocator>& y);
  template <class T, class Allocator>
    bool operator< (const list<T, Allocator>& x, const list<T, Allocator>& y);
  template <class T, class Allocator>
    bool operator!=(const list<T, Allocator>& x, const list<T, Allocator>& y);
  template <class T, class Allocator>
    bool operator> (const list<T, Allocator>& x, const list<T, Allocator>& y);
  template <class T, class Allocator>
    bool operator>=(const list<T, Allocator>& x, const list<T, Allocator>& y);
  template <class T, class Allocator>
    bool operator<=(const list<T, Allocator>& x, const list<T, Allocator>& y);

  // [:en] specialized algorithms:
  template <class T, class Allocator>
    void swap(list<T, Allocator>& x, list<T, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
[codeblock:end]

[/     3[list.cons]{[`list} constructors, copy, and assignment}/]
[section#list.cons
    [:en] [`list] constructors, copy, and assignment
]

[%@library list[!list]]
[codeblock:declaration]
explicit list(const Allocator&);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty list, using the specified allocator.

[para:complexity]
[:en] Constant.
[exit:description]

[%@library list[!list]]
[codeblock:declaration]
explicit list(size_type n, const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a [`list] with [`n] default-inserted elements using the
specified allocator.

[para:requires]
[:en] [`T] shall be [`DefaultInsertable] into [`*this].

[para:complexity]
[:en] Linear in [`n].
[exit:description]

[%@library list[!list]]
[codeblock:declaration]
list(size_type n, const T& value, const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a [`list] with [`n] copies of [`value], using the specified
allocator.

[para:requires]
[:en] [`T] shall be [`CopyInsertable] into [`*this].

[para:complexity]
[:en] Linear in [`n].
[exit:description]

[%@library list[!list]]
[codeblock:declaration]
template <class InputIterator>
  list(InputIterator first, InputIterator last, const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a [`list] equal to the range [=range[first,last)].

[para:complexity]
[:en] Linear in [`distance(first, last)].
[exit:description]

[/     3[list.capacity]{[`list} capacity}/]
[section#list.capacity
    [:en] [`list] capacity
]

[%@library resize[!list]]
[codeblock:declaration]
void resize(size_type sz);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`size() < sz], appends [`sz - size()] default-inserted elements to the
sequence.

[:en] If [`sz <= size()], equivalent to

[codeblock:notation]
list<T>::iterator it = begin();
advance(it, sz);
erase(it, end());
[codeblock:end]

[para:requires]
[:en] [`T] shall be [`DefaultInsertable] into [`*this].
[exit:description]

[%@library resize[!list]]
[codeblock:declaration]
void resize(size_type sz, const T& c);
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
if (sz > size())
  insert(end(), sz-size(), c);
else if (sz < size()) {
  iterator i = begin();
  advance(i, sz);
  erase(i, end());
}
else
  ;                 // [:en] do nothing
[codeblock:end]

[para:requires]
[:en] [`T] shall be [`CopyInsertable] into [`*this].
[exit:description]

[/     3[list.modifiers]{[`list} modifiers}/]
[section#list.modifiers
    [:en] [`list] modifiers
]

[%@library insert[!list]]
[codeblock:declaration]
iterator insert(const_iterator position, const T& x);
iterator insert(const_iterator position, T&& x);
iterator insert(const_iterator position, size_type n, const T& x);
template <class InputIterator>
  iterator insert(const_iterator position, InputIterator first,
                  InputIterator last);
iterator insert(const_iterator position, initializer_list<T>);

template <class... Args> void emplace_front(Args&&... args);
template <class... Args> void emplace_back(Args&&... args);
template <class... Args> iterator emplace(const_iterator position, Args&&... args);
void push_front(const T& x);
void push_front(T&& x);
void push_back(const T& x);
void push_back(T&& x);
[codeblock:end]

[enter:description]
[para:notes]
[:en] Does not affect the validity of iterators and references.

[:en] If an exception is thrown there are no effects.

[para:complexity]
[:en] Insertion of a single element into a list takes constant time and exactly
one call to a constructor of [`T].

[:en] Insertion of multiple elements into a list is linear in the number of
elements inserted, and the number of calls to the copy constructor or move
constructor of [`T] is exactly equal to the number of elements inserted.
[exit:description]

[%@library erase[!list]]
[codeblock:declaration]
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);

void pop_front();
void pop_back();
void clear() noexcept;
[codeblock:end]

[enter:description]
[para:effects]
[:en] Invalidates only the iterators and references to the erased elements.

[para:throws]
[:en] Nothing.

[para:complexity]
[:en] Erasing a single element is a constant time operation with a single call
to the destructor of [`T].

[:en] Erasing a range in a list is linear time in the size of the range and the
number of calls to the destructor of type [`T] is exactly equal to the size of
the range.
[exit:description]

[/     3[list.ops]{[`list} operations}/]
[section#list.ops
    [:en] [`list] operations
]

[para]
[:en] Since lists allow fast insertion and erasing from the middle of a list,
certain operations are provided specifically for them.

[footnote]
[:en] As specified in [#allocator.requirements], the requirements in this Clause
apply only to lists whose allocators compare equal.
[footnote:end]

[para]
[:en] [`list] provides three splice operations that destructively move elements
from one list to another.

[:en] The behavior of splice operations is undefined if [`get_allocator() !=
x.get_allocator()].

[%@library splice[!list]]
[codeblock:declaration]
void splice(const_iterator position, list& x);
void splice(const_iterator position, list&& x);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`&x != this].

[para:effects]
[:en] Inserts the contents of [`x] before [`position] and [`x] becomes empty.

[:en] Pointers and references to the moved elements of [`x] now refer to those
same elements but as members of [`*this].

[:en] Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into [`*this], not into [`x].

[para:throws]
[:en] Nothing.

[para:complexity]
[:en] Constant time.
[exit:description]

[%@library splice[!list]]
[%@library list[!splice]]
[codeblock:declaration]
void splice(const_iterator position, list& x, const_iterator i);
void splice(const_iterator position, list&& x, const_iterator i);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Inserts an element pointed to by [`i] from list [`x] before [`position]
and removes the element from [`x].

[:en] The result is unchanged if [`position == i] or [`position == ++i].

[:en] Pointers and references to [`*i] continue to refer to this same element
but as a member of [`*this].

[:en] Iterators to [`*i] (including [`i] itself) continue to refer to the same
element, but now behave as iterators into [`*this], not into [`x].

[para:requires]
[:en] [`i] is a valid dereferenceable iterator of [`x].

[para:throws]
[:en] Nothing.

[para:complexity]
[:en] Constant time.
[exit:description]

[%@library splice[!list]]
[%@library list[!splice]]
[codeblock:declaration]
void splice(const_iterator position, list& x, const_iterator first,
            const_iterator last);
void splice(const_iterator position, list&& x, const_iterator first,
            const_iterator last);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Inserts elements in the range [=range[first,last)] before [`position]
and removes the elements from [`x].

[para:requires]
[:en] [`[first, last)] is a valid range in [`x].

[:en] The result is undefined if [`position] is an iterator in the range
[=range[first,last)].

[:en] Pointers and references to the moved elements of [`x] now refer to those
same elements but as members of [`*this].

[:en] Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into [`*this], not into [`x].

[para:throws]
[:en] Nothing.

[para:complexity]
[:en] Constant time if [`&x == this]; otherwise, linear time.
[exit:description]

[%@library remove[!list]]
[codeblock:declaration]
void remove(const T& value);
template <class Predicate> void remove_if(Predicate pred);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Erases all the elements in the list referred by a list iterator [`i] for
which the following conditions hold: [`*i == value, pred(*i) != false].

[:en] Invalidates only the iterators and references to the erased elements.

[para:throws]
[:en] Nothing unless an exception is thrown by [`*i == value] or [`pred(*i) !=
false].

[para:remarks]
[:en] Stable ([#algorithm.stable]).

[para:complexity]
[:en] Exactly [`size()] applications of the corresponding predicate.
[exit:description]

[%@library unique[!list]]
[codeblock:declaration]
void unique();
template <class BinaryPredicate> void unique(BinaryPredicate binary_pred);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Erases all but the first element from every consecutive group of equal
elements referred to by the iterator [`i] in the range [=range[first + 1,last)]
for which [`*i == *(i-1)] (for the version of [`unique] with no arguments) or
[`pred(*i, *(i - 1))] (for the version of [`unique] with a predicate argument)
holds.

[:en] Invalidates only the iterators and references to the erased elements.

[para:throws]
[:en] Nothing unless an exception is thrown by [`*i == *(i-1)] or
[`pred(*i, *(i - 1))]

[para:complexity]
[:en] If the range [`[first, last)] is not empty, exactly [`(last - first) - 1]
applications of the corresponding predicate, otherwise no applications of the
predicate.
[exit:description]

[%@library merge[!list]]
[codeblock:declaration]
void merge(list& x);
void merge(list&& x);
template <class Compare> void merge(list& x, Compare comp);
template <class Compare> void merge(list&& x, Compare comp);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`comp] shall define a strict weak ordering ([#alg.sorting]), and both the
list and the argument list shall be sorted according to this ordering.

[para:effects]
[:en] If [`(&x == this)] does nothing; otherwise, merges the two sorted ranges
[`[begin(), end())] and [`[x.begin(), x.end())].

[:en] The result is a range in which the elements will be sorted in
non-decreasing order according to the ordering defined by [`comp]; that is, for
every iterator [`i], in the range other than the first, the condition
[`comp(*i, *(i - 1))] will be false.

[:en] Pointers and references to the moved elements of [`x] now refer to those
same elements but as members of [`*this].

[:en] Iterators referring to the moved elements will continue to refer to their
elements, but they now behave as iterators into [`*this], not into [`x].

[para:remarks]
[:en] Stable ([#algorithm.stable]).

[:en] If [`(&x != this)] the range [`[x.begin(), x.end())] is empty after the
merge.

[:en] No elements are copied by this operation.

[:en]
The behavior is undefined if [`this->get_allocator() != x.get_allocator()].

[para:complexity]
[:en]
At most [`size() + x.size() - 1] applications of [`comp] if [`(&x != this)];
otherwise, no applications of [`comp] are performed.

[:en] If an exception is thrown other than by a comparison there are no effects.
[exit:description]

[%@library reverse[!list]]
[codeblock:declaration]
void reverse() noexcept;
[codeblock:end]

[enter:description]
[para:effects]
[:en] Reverses the order of the elements in the list.

[:en] Does not affect the validity of iterators and references.

[para:complexity]
[:en] Linear time.
[exit:description]

[%@library sort[!list]]
[codeblock:declaration]
void sort();
template <class Compare> void sort(Compare comp);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`operator<] (for the first version) or [`comp] (for the second version)
shall define a strict weak ordering ([#alg.sorting]).

[para:effects]
[:en] Sorts the list according to the [`operator<] or a [`Compare] function
object.

[:en] Does not affect the validity of iterators and references.

[para:remarks]
[:en] Stable ([#algorithm.stable]).

[para:complexity]
[:en] Approximately [$N] log([$N]) comparisons, where [`N == size()].
[exit:description]

[/     3[list.special]{[`list} specialized algorithms}/]
[section#list.special
    [:en] [`list] specialized algorithms
]

[%@library swap[!list]]
[%@library list[!swap]]
[codeblock:declaration]
template <class T, class Allocator>
  void swap(list<T, Allocator>& x, list<T, Allocator>& y)
    noexcept(noexcept(x.swap(y)));
[codeblock:end]

[enter:description]
[para:effects]

[codeblock:notation]
x.swap(y);
[codeblock:end]

[exit:description]

[/     2[vector]{Class template [`vector}}/]
[section#vector
    [:en] Class template [`vector]
]

[/     3[vector.overview]{Class template [`vector} overview}/]
[section#vector.overview
    [:en] Class template [`vector] overview
]

[para]
[%@library vector]
[:en] A [`vector] is a sequence container that supports (amortized) constant
time insert and erase operations at the end; insert and erase in the middle take
linear time.

[:en] Storage management is handled automatically, though hints can be given
to improve efficiency.

[para]
[:en] A [`vector] satisfies all of the requirements of a container and of a
reversible container (given in two tables in [#container.requirements]), of a
sequence container, including most of the optional sequence container
requirements ([#sequence.reqmts]), of an allocator-aware container (Table
[#tab:containers.allocatoraware]), and, for an element type other than [`bool],
of a contiguous container ([#container.requirements.general]).

[:en] The exceptions are the [`push_front], [`pop_front], and [`emplace_front]
member functions, which are not provided.

[:en] Descriptions are provided here only for operations on [`vector] that are
not described in one of these tables or for operations where there is additional
semantic information.

[codeblock:synopsis [special implementation-defined] ]
namespace std {
  template <class T, class Allocator = allocator<T> >
  class vector {
  public:
    // [:en] types:
    typedef value_type&                           reference;
    typedef const value_type&                     const_reference;
    typedef implementation-defined                iterator;       // [:en] see [#container.requirements]
    typedef implementation-defined                const_iterator; // [:en] see [#container.requirements]
    typedef implementation-defined                size_type;      // [:en] see [#container.requirements]
    typedef implementation-defined                difference_type;// [:en] see [#container.requirements]
    typedef T                                     value_type;
    typedef Allocator                             allocator_type;
    typedef typename allocator_traits<Allocator>::pointer           pointer;
    typedef typename allocator_traits<Allocator>::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // [:en] [#vector.cons], construct/copy/destroy:
    vector() noexcept : vector(Allocator()) { }
    explicit vector(const Allocator&) noexcept;
    explicit vector(size_type n, const Allocator& = Allocator());
    vector(size_type n, const T& value, const Allocator& = Allocator());
    template <class InputIterator>
      vector(InputIterator first, InputIterator last, const Allocator& = Allocator());
    vector(const vector& x);
    vector(vector&&) noexcept;
    vector(const vector&, const Allocator&);
    vector(vector&&, const Allocator&);
    vector(initializer_list<T>, const Allocator& = Allocator());
   ~vector();
    vector& operator=(const vector& x);
    vector& operator=(vector&& x)
      noexcept(allocator_traits<Allocator>::propagate_on_container_move_assignment::value ||
               allocator_traits<Allocator>::is_always_equal::value);
    vector& operator=(initializer_list<T>);
    template <class InputIterator>
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const T& u);
    void assign(initializer_list<T>);
    allocator_type get_allocator() const noexcept;

    // [:en] iterators:
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;
    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // [:en] [#vector.capacity], capacity:
    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    size_type capacity() const noexcept;
    void      resize(size_type sz);
    void      resize(size_type sz, const T& c);
    void      reserve(size_type n);
    void      shrink_to_fit();

    // [:en] element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // [:en] [#vector.data], data access
    T*       data() noexcept;
    const T* data() const noexcept;

    // [:en] [#vector.modifiers], modifiers:
    template <class... Args> void emplace_back(Args&&... args);
    void push_back(const T& x);
    void push_back(T&& x);
    void pop_back();

    template <class... Args> iterator emplace(const_iterator position, Args&&... args);
    iterator insert(const_iterator position, const T& x);
    iterator insert(const_iterator position, T&& x);
    iterator insert(const_iterator position, size_type n, const T& x);
    template <class InputIterator>
      iterator insert(const_iterator position, InputIterator first, InputIterator last);
    iterator insert(const_iterator position, initializer_list<T> il);
    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);
    void     swap(vector&)
      noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
               allocator_traits<Allocator>::is_always_equal::value);
    void     clear() noexcept;
  };

  template <class T, class Allocator>
    bool operator==(const vector<T, Allocator>& x, const vector<T, Allocator>& y);
  template <class T, class Allocator>
    bool operator< (const vector<T, Allocator>& x, const vector<T, Allocator>& y);
  template <class T, class Allocator>
    bool operator!=(const vector<T, Allocator>& x, const vector<T, Allocator>& y);
  template <class T, class Allocator>
    bool operator> (const vector<T, Allocator>& x, const vector<T, Allocator>& y);
  template <class T, class Allocator>
    bool operator>=(const vector<T, Allocator>& x, const vector<T, Allocator>& y);
  template <class T, class Allocator>
    bool operator<=(const vector<T, Allocator>& x, const vector<T, Allocator>& y);

  // [:en] [#vector.special], specialized algorithms:
  template <class T, class Allocator>
    void swap(vector<T, Allocator>& x, vector<T, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
[codeblock:end]
[%@library vector[!operator==]]
[%@library vector[!operator<]]

[/     3[vector.cons]{[`vector} constructors, copy, and assignment}/]
[section#vector.cons
    [:en] [`vector] constructors, copy, and assignment
]

[%@library vector[!vector]]
[codeblock:declaration]
explicit vector(const Allocator&);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty [`vector], using the specified allocator.

[para:complexity]
[:en] Constant.
[exit:description]

[%@library vector[!vector]]
[codeblock:declaration]
explicit vector(size_type n, const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a [`vector] with [`n] default-inserted elements using the
specified allocator.

[para:requires]
[:en] [`T] shall be [`DefaultInsertable] into [`*this].

[para:complexity]
[:en] Linear in [`n].
[exit:description]

[%@library vector[!vector]]
[codeblock:declaration]
vector(size_type n, const T& value,
       const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a [`vector] with [`n] copies of [`value], using the specified
allocator.

[para:requires]
[:en] [`T] shall be [`CopyInsertable] into [`*this].

[para:complexity]
[:en] Linear in [`n].
[exit:description]

[%@library vector[!vector]]
[codeblock:declaration]
template <class InputIterator>
  vector(InputIterator first, InputIterator last,
         const Allocator& = Allocator());
[codeblock:end]

[enter:description]

[para:effects]
[:en] Constructs a [`vector] equal to the range [=range[first,last)], using the
specified allocator.

[para:complexity]
[:en] Makes only [$N] calls to the copy constructor of [`T] (where [$N] is the
distance between [`first] and [`last]) and no reallocations if iterators first
and last are of forward, bidirectional, or random access categories.

[:en] It makes order [`N] calls to the copy constructor of [`T] and order
log([$N]) reallocations if they are just input iterators.
[exit:description]

[/     3[vector.capacity]{[`vector} capacity}/]
[section#vector.capacity
    [:en] [`vector] capacity
]

[%@library capacity[!vector]]
[codeblock:declaration]
size_type capacity() const noexcept;
[codeblock:end]

[enter:description]
[para:returns]
[:en] The total number of elements that the vector can hold without requiring
reallocation.
[exit:description]

[%@library reserve[!vector]]
[codeblock:declaration]
void reserve(size_type n);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`T] shall be [`MoveInsertable] into [`*this].

[para:effects]
[:en] A directive that informs a [`vector] of a planned change in size, so that
it can manage the storage allocation accordingly.

[:en] After [`reserve()], [`capacity()] is greater or equal to the argument of
[`reserve] if reallocation happens; and equal to the previous value of
[`capacity()] otherwise.

[:en] Reallocation happens at this point if and only if the current capacity is
less than the argument of [`reserve()].

[:en] If an exception is thrown other than by the move constructor of a
non-[`CopyInsertable] type, there are no effects.

[para:complexity]
[:en] It does not change the size of the sequence and takes at most linear
time in the size of the sequence.

[para:throws]
[:en] [`length_error] if [`n > max_size()].

[footnote]
[:en] [`reserve()] uses [`Allocator::allocate()] which may throw an appropriate
exception.
[footnote:end]

[para:notes]
[:en] Reallocation invalidates all the references, pointers, and iterators
referring to the elements in the sequence.

[:en] No reallocation shall take place during insertions that happen after a
call to [`reserve()] until the time when an insertion would make the size of the
vector greater than the value of [`capacity()].
[exit:description]

[%@library shrink_to_fit[!vector]]
[codeblock:declaration]
void shrink_to_fit();
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`T] shall be [`MoveInsertable] into [`*this].

[para:complexity]
[:en] Linear in the size of the sequence.

[para:notes]
[:en] [`shrink_to_fit] is a non-binding request to reduce [`capacity()] to
[`size()].

[enter:note]
[:en] The request is non-binding to allow latitude for implementation-specific
optimizations.
[exit:note]

[:en] If an exception is thrown other than by the move constructor of a
non-[`CopyInsertable] [`T] there are no effects.
[exit:description]

[%@library swap[!vector]]
[codeblock:declaration]
void swap(vector& x)
  noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value ||
           allocator_traits<Allocator>::is_always_equal::value);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Exchanges the contents and [`capacity()] of [`*this] with that of [`x].

[para:complexity]
[:en] Constant time.
[exit:description]

[%@library resize[!vector]]
[codeblock:declaration]
void resize(size_type sz);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`sz <= size()], equivalent to calling [`pop_back()] [`size() - sz]
times.

[:en] If [`size() < sz], appends [`sz - size()] default-inserted elements to the
sequence.

[para:requires]
[:en] [`T] shall be [`MoveInsertable] and [`DefaultInsertable] into [`*this].

[para:notes]
[:en] If an exception is thrown other than by the move constructor of a
non-[`CopyInsertable] [`T] there are no effects.
[exit:description]

[%@library resize[!vector]]
[codeblock:declaration]
void resize(size_type sz, const T& c);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`sz <= size()], equivalent to calling [`pop_back()] [`size() - sz]
times.

[:en] If [`size() < sz], appends [`sz - size()] copies of [`c] to the sequence.

[para:requires]
[:en] [`T] shall be [`CopyInsertable] into [`*this].

[para:notes]
[:en] If an exception is thrown there are no effects.
[exit:description]

[/     3[vector.data]{[`vector} data}/]
[section#vector.data
    [:en] [`vector] data
]

[%@library data[!vector]]
[codeblock:declaration]
T*         data() noexcept;
const T*   data() const noexcept;
[codeblock:end]

[enter:description]
[para:returns]
[:en] A pointer such that [=range[data(),data() + size())] is a valid range.

[:en] For a non-empty vector, [`data() == &front()].

[para:complexity]
[:en] Constant time.
[exit:description]

[/     3[vector.modifiers]{[`vector} modifiers}/]
[section#vector.modifiers
    [:en] [`vector] modifiers
]

[%@library insert[!vector]]
[codeblock:declaration]
iterator insert(const_iterator position, const T& x);
iterator insert(const_iterator position, T&& x);
iterator insert(const_iterator position, size_type n, const T& x);
template <class InputIterator>
  iterator insert(const_iterator position, InputIterator first, InputIterator last);
iterator insert(const_iterator position, initializer_list<T>);

template <class... Args> void emplace_back(Args&&... args);
template <class... Args> iterator emplace(const_iterator position, Args&&... args);
void push_back(const T& x);
void push_back(T&& x);
[codeblock:end]

[enter:description]
[para:notes]
[:en] Causes reallocation if the new size is greater than the old capacity.

[:en] If no reallocation happens, all the iterators and references before the
insertion point remain valid.

[:en] If an exception is thrown other than by the copy constructor, move
constructor, assignment operator, or move assignment operator of [`T] or by any
[`InputIterator] operation there are no effects.

[:en] If an exception is thrown while inserting a single element at the end and
[`T] is [`CopyInsertable] or [`is_nothrow_move_constructible<T>::value] is
[`true], there are no effects.

[:en] Otherwise, if an exception is thrown by the move constructor of a
non-[`CopyInsertable] [`T], the effects are unspecified.

[para:complexity]
[:en] The complexity is linear in the number of elements inserted plus the
distance to the end of the vector.
[exit:description]

[%@library erase[!vector]]
[codeblock:declaration]
iterator erase(const_iterator position);
iterator erase(const_iterator first, const_iterator last);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Invalidates iterators and references at or after the point of the erase.

[para:complexity]
[:en] The destructor of [`T] is called the number of times equal to the number
of the elements erased, but the move assignment operator of [`T] is called the
number of times equal to the number of elements in the vector after the erased
elements.

[para:throws]
[:en] Nothing unless an exception is thrown by the copy constructor, move
constructor, assignment operator, or move assignment operator of [`T].
[exit:description]

[/     3[vector.special]{[`vector} specialized algorithms}/]
[section#vector.special
    [:en] [`vector] specialized algorithms
]

[%@library swap[!vector]]
[%@library vector[!swap]]
[codeblock:declaration]
template <class T, class Allocator>
  void swap(vector<T, Allocator>& x, vector<T, Allocator>& y)
    noexcept(noexcept(x.swap(y)));
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
x.swap(y);
[codeblock:end]
[exit:description]

[/     2[vector.bool]{Class [`vector<bool>}}/]
[section#vector.bool
    [:en] Class [`vector<bool>]
]

[para]
[%@library vector<bool>]
[:en] To optimize space allocation, a specialization of vector for [`bool]
elements is provided:

[codeblock:synopsis [special implementation-defined] ]
namespace std {
  template <class Allocator> class vector<bool, Allocator> {
  public:
    // [:en] types:
    typedef bool                                  const_reference;
    typedef implementation-defined                iterator;       // [:en] see [#container.requirements]
    typedef implementation-defined                const_iterator; // [:en] see [#container.requirements]
    typedef implementation-defined                size_type;      // [:en] see [#container.requirements]
    typedef implementation-defined                difference_type;// [:en] see [#container.requirements]
    typedef bool                                  value_type;
    typedef Allocator                             allocator_type;
    typedef implementation-defined                pointer;
    typedef implementation-defined                const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // [:en] bit reference:
    class reference {
      friend class vector;
      reference() noexcept;
    public:
      ~reference();
      operator bool() const noexcept;
      reference& operator=(const bool x) noexcept;
      reference& operator=(const reference& x) noexcept;
      void flip() noexcept;     // [:en] flips the bit
    };

    // [:en] construct/copy/destroy:
    vector() : vector(Allocator()) { }
    explicit vector(const Allocator&);
    explicit vector(size_type n, const Allocator& = Allocator());
    vector(size_type n, const bool& value,
           const Allocator& = Allocator());
    template <class InputIterator>
      vector(InputIterator first, InputIterator last,
             const Allocator& = Allocator());
    vector(const vector<bool, Allocator>& x);
    vector(vector<bool, Allocator>&& x);
    vector(const vector&, const Allocator&);
    vector(vector&&, const Allocator&);
    vector(initializer_list<bool>, const Allocator& = Allocator()));
   ~vector();
    vector<bool, Allocator>& operator=(const vector<bool, Allocator>& x);
    vector<bool, Allocator>& operator=(vector<bool, Allocator>&& x);
    vector& operator=(initializer_list<bool>);
    template <class InputIterator>
      void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const bool& t);
    void assign(initializer_list<bool>);
    allocator_type get_allocator() const noexcept;

    // [:en] iterators:
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;
    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // [:en] capacity:
    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    size_type capacity() const noexcept;
    void      resize(size_type sz, bool c = false);
    void      reserve(size_type n);
    void      shrink_to_fit();

    // [:en] element access:
    reference       operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference       at(size_type n);
    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back() const;

    // [:en] modifiers:
    template <class... Args> void emplace_back(Args&&... args);
    void push_back(const bool& x);
    void pop_back();
    template <class... Args> iterator emplace(const_iterator position, Args&&... args);
    iterator insert(const_iterator position, const bool& x);
    iterator insert (const_iterator position, size_type n, const bool& x);
    template <class InputIterator>
      iterator insert(const_iterator position,
                      InputIterator first, InputIterator last);
    iterator insert(const_iterator position, initializer_list<bool> il);

    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);
    void swap(vector<bool, Allocator>&);
    static void swap(reference x, reference y) noexcept;
    void flip() noexcept;       // [:en] flips all bits
    void clear() noexcept;
  };
}
[codeblock:end]

[para]
[:en] Unless described below, all operations have the same requirements and
semantics as the primary [`vector] template, except that operations dealing with
the [`bool] value type map to bit values in the container storage and
[`allocator_traits::construct] ([#allocator.traits.members]) is not used to
construct these values.

[para]
[:en] There is no requirement that the data be stored as a contiguous allocation
of [`bool] values.

[:en] A space-optimized representation of bits is recommended instead.

[para]
[:en] [`reference] is a class that simulates the behavior of references of a
single bit in [`vector<bool>].

[:en] The conversion operator returns [`true] when the bit is set, and [`false]
otherwise.

[:en] The assignment operator sets the bit when the argument is (convertible to)
[`true] and clears it otherwise.

[:en] [`flip] reverses the state of the bit.

[%@library flip[!vector<bool>]]
[%@library vector<bool>[!flip]]
[codeblock:declaration]
void flip() noexcept;
[codeblock:end]

[enter:description]
[para:effects]
[:en] Replaces each element in the container with its complement.
[exit:description]

[%@library swap[!vector<bool>]]
[%@library vector<bool>[!swap]]
[codeblock:declaration]
static void swap(reference x, reference y) noexcept;
[codeblock:end]

[enter:description]
[para:effects]
[:en] exchanges the contents of [`x] and [`y] as if by

[codeblock:notation]
bool b = x;
x = y;
y = b;
[codeblock:end]
[exit:description]

[codeblock:declaration]
template <class Allocator> struct hash<vector<bool, Allocator> >;
[codeblock:end]

[enter:description]
[para]
[:en] The template specialization shall meet the requirements of class template
[`hash] ([#unord.hash]).
[exit:description]

[/     1[associative]{Associative containers}/]
[section#associative
    [:en] Associative containers
]

[/     2[associative.general]{In general}/]
[section#associative.general
    [:en] In general
]

[para]
[:en] The header [`<map>] defines the class templates [`map] and [`multimap];
the header [`<set>] defines the class templates [`set] and [`multiset].

[/     2[associative.map.syn]{Header [`<map>} synopsis}/]
[section#associative.map.syn
    [:en] Header [`<map>] synopsis
]

[%@library <map> [sortas map]]
[codeblock:synopsis]
#include <initializer_list>

namespace std {

  template <class Key, class T, class Compare = less<Key>,
            class Allocator = allocator<pair<const Key, T> > >
    class map;
  template <class Key, class T, class Compare, class Allocator>
    bool operator==(const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator< (const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator!=(const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator> (const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator>=(const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator<=(const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    void swap(map<Key, T, Compare, Allocator>& x,
              map<Key, T, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));

  template <class Key, class T, class Compare = less<Key>,
            class Allocator = allocator<pair<const Key, T> > >
    class multimap;
  template <class Key, class T, class Compare, class Allocator>
    bool operator==(const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator< (const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator!=(const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator> (const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator>=(const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator<=(const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    void swap(multimap<Key, T, Compare, Allocator>& x,
              multimap<Key, T, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
[codeblock:end]

[/     2[associative.set.syn]{Header [`<set>} synopsis]]/]
[section#associative.set.syn
    [:en] Header [`<set>] synopsis
]
[%@library <set> [sortas set]]

[codeblock:synopsis]
#include <initializer_list>

namespace std {

  template <class Key, class Compare = less<Key>,
            class Allocator = allocator<Key> >
    class set;
  template <class Key, class Compare, class Allocator>
    bool operator==(const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator< (const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator!=(const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator> (const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator>=(const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator<=(const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    void swap(set<Key, Compare, Allocator>& x,
              set<Key, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));

  template <class Key, class Compare = less<Key>,
            class Allocator = allocator<Key> >
    class multiset;
  template <class Key, class Compare, class Allocator>
    bool operator==(const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator< (const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator!=(const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator> (const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator>=(const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator<=(const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    void swap(multiset<Key, Compare, Allocator>& x,
              multiset<Key, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
[codeblock:end]

[/     2[map]{Class template [`map}}/]
[section#map
    [:en] Class template [`map]
]

[/     3[map.overview]{Class template [`map} overview}/]
[section#map.overview
    [:en] Class template [`map] overview
]

[%@library map]
[para]
[:en] A [`map] is an associative container that supports unique keys (contains
at most one of each key value) and provides for fast retrieval of values of
another type [`T] based on the keys.

[:en] The [`map] class supports bidirectional iterators.

[para]
[:en] A [`map] satisfies all of the requirements of a container, of a reversible
container ([#container.requirements]), of an associative container
([#associative.reqmts]), and of an allocator-aware container (Table
[#tab:containers.allocatoraware]).

[:en] A [`map] also provides most operations described in
([#associative.reqmts]) for unique keys.

[:en] This means that a [`map] supports the [`a_uniq] operations in
([#associative.reqmts]) but not the [`a_eq] operations.

[:en] For a [`map<Key,T>] the [`key_type] is [`Key] and the [`value_type] is
[`pair<const Key,T>].

[:en] Descriptions are provided here only for operations on [`map] that are not
described in one of those tables or for operations where there is additional
semantic information.

[codeblock:synopsis [special implementation-defined] ]
namespace std {
  template <class Key, class T, class Compare = less<Key>,
            class Allocator = allocator<pair<const Key, T> > >
  class map {
  public:
    // [:en] types:
    typedef Key                                   key_type;
    typedef T                                     mapped_type;
    typedef pair<const Key, T>                    value_type;
    typedef Compare                               key_compare;
    typedef Allocator                             allocator_type;
    typedef value_type&                           reference;
    typedef const value_type&                     const_reference;
    typedef implementation-defined                iterator;       // [:en] see [#container.requirements]
    typedef implementation-defined                const_iterator; // [:en] see [#container.requirements]
    typedef implementation-defined                size_type;      // [:en] see [#container.requirements]
    typedef implementation-defined                difference_type;// [:en] see [#container.requirements]
    typedef typename allocator_traits<Allocator>::pointer           pointer;
    typedef typename allocator_traits<Allocator>::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    class value_compare {
    friend class map;
    protected:
      Compare comp;
      value_compare(Compare c) : comp(c) {}
    public:
      typedef bool result_type;
      typedef value_type first_argument_type;
      typedef value_type second_argument_type;
      bool operator()(const value_type& x, const value_type& y) const {
        return comp(x.first, y.first);
      }
    };

    // [:en] [#map.cons], construct/copy/destroy:
    map() : map(Compare()) { }
    explicit map(const Compare& comp, const Allocator& = Allocator());
    template <class InputIterator>
      map(InputIterator first, InputIterator last,
          const Compare& comp = Compare(), const Allocator& = Allocator());
    map(const map& x);
    map(map&& x);
    explicit map(const Allocator&);
    map(const map&, const Allocator&);
    map(map&&, const Allocator&);
    map(initializer_list<value_type>,
      const Compare& = Compare(),
      const Allocator& = Allocator());
    template <class InputIterator>
      map(InputIterator first, InputIterator last, const Allocator& a)
        : map(first, last, Compare(), a) { }
    map(initializer_list<value_type> il, const Allocator& a)
      : map(il, Compare(), a) { }
   ~map();
    map& operator=(const map& x);
    map& operator=(map&& x)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable<Compare>::value);
    map& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // [:en] iterators:
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // [:en] capacity:
    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // [:en] [#map.access], element access:
    T& operator[](const key_type& x);
    T& operator[](key_type&& x);
    T&       at(const key_type& x);
    const T& at(const key_type& x) const;

    // [:en] [#map.modifiers], modifiers:
    template <class... Args> pair<iterator, bool> emplace(Args&&... args);
    template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator, bool> insert(const value_type& x);
    pair<iterator, bool> insert(value_type&& x);
    template <class P> pair<iterator, bool> insert(P&& x);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    template <class P>
      iterator insert(const_iterator position, P&&);
    template <class InputIterator>
      void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    template <class... Args>
      pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
    template <class... Args>
      pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
    template <class... Args>
      iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
    template <class... Args>
      iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
    template <class M>
      pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
    template <class M>
      pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
    template <class M>
      iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
    template <class M>
      iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(map&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               noexcept(swap(declval<Compare&>(), declval<Compare&>())));
    void      clear() noexcept;

    // [:en] observers:
    key_compare key_comp() const;
    value_compare value_comp() const;

    // [:en] map operations:
    iterator       find(const key_type& x);
    const_iterator find(const key_type& x) const;
    template <class K> iterator       find(const K& x);
    template <class K> const_iterator find(const K& x) const;

    size_type      count(const key_type& x) const;
    template <class K> size_type count(const K& x) const;

    iterator       lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    template <class K> iterator       lower_bound(const K& x);
    template <class K> const_iterator lower_bound(const K& x) const;

    iterator       upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    template <class K> iterator       upper_bound(const K& x);
    template <class K> const_iterator upper_bound(const K& x) const;

    pair<iterator, iterator>               equal_range(const key_type& x);
    pair<const_iterator, const_iterator>   equal_range(const key_type& x) const;
    template <class K>
      pair<iterator, iterator>             equal_range(const K& x);
    template <class K>
      pair<const_iterator, const_iterator> equal_range(const K& x) const;
  };

  template <class Key, class T, class Compare, class Allocator>
    bool operator==(const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator< (const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator!=(const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator> (const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator>=(const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator<=(const map<Key, T, Compare, Allocator>& x,
                    const map<Key, T, Compare, Allocator>& y);

  // [:en] specialized algorithms:
  template <class Key, class T, class Compare, class Allocator>
    void swap(map<Key, T, Compare, Allocator>& x,
              map<Key, T, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
[codeblock:end]


[/     3[map.cons]{[`map} constructors, copy, and assignment]]/]
[section#map.cons
    [:en] [`map] constructors, copy, and assignment
]

[%@library map[!operator==]]
[%@library map[!operator<]]

[%@library map[!map]]
[codeblock:declaration]
explicit map(const Compare& comp, const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty [`map] using the specified comparison object and
allocator.

[para:complexity]
[:en] Constant.
[exit:description]

[%@library map[![:en]constructor]]
[codeblock:declaration]
template <class InputIterator>
  map(InputIterator first, InputIterator last,
      const Compare& comp = Compare(), const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:requires]
[:en] If the iterator[=']s indirection operator returns an lvalue or a const
rvalue [`pair<key_type, mapped_type>], then both [`key_type] and [`mapped_type]
shall be [`CopyInsertable] into [`*this].

[para:effects]
[:en] Constructs an empty [`map] using the specified comparison object and
allocator, and inserts elements from the range [=range[first,last)].

[para:complexity]
[:en] Linear in [$N] if the range [=range[first,last)] is already sorted using
[`comp] and otherwise [$N] log([$N]), where [$N] is [`last] - [`first].
[exit:description]

[/     3[map.access]{[`map} element access}/]
[section#map.access
    [:en] [`map] element access
]

[%@library operator['][!map]]
[codeblock:declaration]
T& operator[](const key_type& x);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If there is no key equivalent to [`x] in the map, inserts [`value_type(x,
T())] into the map.

[para:requires]
[:en] [`key_type] shall be [`CopyInsertable] and [`mapped_type] shall be
[`DefaultInsertable] into [`*this].

[para:returns]
[:en] A reference to the [`mapped_type] corresponding to [`x] in [`*this].

[para:complexity]
[:en] Logarithmic.
[exit:description]

[%@library operator['][!map]]
[codeblock:declaration]
T& operator[](key_type&& x);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If there is no key equivalent to [`x] in the map, inserts
[`value_type(std::move(x), T())] into the map.

[para:requires]
[:en] [`mapped_type] shall be [`DefaultInsertable] into [`*this].

[para:returns]
[:en] A reference to the [`mapped_type] corresponding to [`x] in [`*this].

[para:complexity]
[:en] Logarithmic.
[exit:description]

[%@library at[!map]]
[codeblock:declaration]
T&       at(const key_type& x);
const T& at(const key_type& x) const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] A reference to the [`mapped_type] corresponding to [`x] in [`*this].

[para:throws]
[:en] An exception object of type [`out_of_range] if no such element is present.

[para:complexity]
[:en] Logarithmic.
[exit:description]

[/     3[map.modifiers]{[`map} modifiers}/]
[section#map.modifiers
    [:en] [`map] modifiers
]

[%@library insert[!map]]
[%@library map[!insert]]
[codeblock:declaration]
template <class P> pair<iterator, bool> insert(P&& x);
template <class P> iterator insert(const_iterator position, P&& x);
template <class InputIterator>
  void insert(InputIterator first, InputIterator last);
[codeblock:end]

[enter:description]
[para:effects]
[:en] The first form is equivalent to [`return emplace(std::forward<P>(x))].

[:en] The second form is equivalent to [`return emplace_hint(position,
std::forward<P>(x))].

[para:remarks]
[:en] These signatures shall not participate in overload resolution unless
[`std::is_constructible<value_type, P&&>::value] is [`true].
[exit:description]

[%@library try_emplace[!map]]
[%@library map[!try_emplace]]
[codeblock:declaration]
template <class... Args> pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
template <class... Args> pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
template <class... Args> iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
template <class... Args> iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If the key [`k] already exists in the map, there is no effect.

[:en] Otherwise, inserts an element into the map.

[:en] In the first and third forms, the element is constructed from the
arguments as [`value_type(k, std::forward<Args>(args)...)].

[:en] In the second and fourth forms, the element is constructed from the
arguments as [`value_type(std::move(k), std::forward<Args>(args)...)].

[:en] In the first two overloads, the [`bool] component of the returned pair is
[`true] if and only if the insertion took place.

[:en] The returned [`iterator] points to the element of the map whose key is
equivalent to [`k].

[para:complexity]
[:en] The same as [`emplace] and [`emplace_hint], respectively.
[exit:description]

[%@library insert_or_assign[!map]]
[%@library map[!insert_or_assign]]
[codeblock:declaration]
template <class M> pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
template <class M> pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
template <class M> iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
template <class M> iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If the key [`k] does not exist in the map, inserts an element into the
map.

[:en] In the first and third forms, the element is constructed from the
arguments as [`value_type(k, std::forward<Args>(args)...)].

[:en] In the second and fourth forms, the element is constructed from the
arguments as [`value_type(std::move(k), std::forward<Args>(args)...)].

[:en] If the key already exists, [`std::forward<M>(obj)] is assigned to the
[`mapped_type] corresponding to the key.

[:en] In the first two overloads, the [`bool] component of the returned value is
[`true] if and only if the insertion took place.

[:en] The returned [`iterator] points to the element that was inserted or
updated.

[para:complexity]
The same as [`emplace] and [`emplace_hint],
respectively.
[exit:description]

[/     3[map.special]{[`map} specialized algorithms}/]
[section#map.special
    [:en] [`map] specialized algorithms
]

[%@library swap[!map]]
[%@library map[!swap]]
[codeblock:declaration]
template <class Key, class T, class Compare, class Allocator>
  void swap(map<Key, T, Compare, Allocator>& x,
            map<Key, T, Compare, Allocator>& y)
    noexcept(noexcept(x.swap(y)));
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
x.swap(y);
[codeblock:end]
[exit:description]

[/     2[multimap]{Class template [`multimap}}/]
[section#multimap
    [:en] Class template [`multimap]
]

[/     3[multimap.overview]{Class template [`multimap} overview}/]
[section#multimap.overview
    [:en] Class template [`multimap] overview
]

[para]
[%@library multimap]
[:en] A [`multimap] is an associative container that supports equivalent keys
(possibly containing multiple copies of the same key value) and provides for
fast retrieval of values of another type [`T] based on the keys.

[:en] The [`multimap] class supports bidirectional iterators.

[para]
[:en] A [`multimap] satisfies all of the requirements of a container and of a
reversible container ([#container.requirements]), of an associative container
([#associative.reqmts]), and of an allocator-aware container (Table
[#tab:containers.allocatoraware]).

[:en] A [`multimap] also provides most operations described in
([#associative.reqmts]) for equal keys.

[:en] This means that a [`multimap] supports the [`a_eq] operations in
([#associative.reqmts]) but not the [`a_uniq] operations.

[:en] For a [`multimap<Key,T>] the [`key_type] is [`Key] and the [`value_type]
is [`pair<const Key,T>].

[:en] Descriptions are provided here only for operations on [`multimap] that are
not described in one of those tables or for operations where there is additional
semantic information.

[codeblock:synopsis [special implementation-defined] ]
namespace std {
  template <class Key, class T, class Compare = less<Key>,
            class Allocator = allocator<pair<const Key, T> > >
  class multimap {
  public:
    // [:en] types:
    typedef Key                                   key_type;
    typedef T                                     mapped_type;
    typedef pair<const Key,T>                     value_type;
    typedef Compare                               key_compare;
    typedef Allocator                             allocator_type;
    typedef value_type&                           reference;
    typedef const value_type&                     const_reference;
    typedef implementation-defined                iterator;       // [:en] see [#container.requirements]
    typedef implementation-defined                const_iterator; // [:en] see [#container.requirements]
    typedef implementation-defined                size_type;      // [:en] see [#container.requirements]
    typedef implementation-defined                difference_type;// [:en] see [#container.requirements]
    typedef typename allocator_traits<Allocator>::pointer           pointer;
    typedef typename allocator_traits<Allocator>::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    class value_compare {
    friend class multimap;
    protected:
      Compare comp;
      value_compare(Compare c) : comp(c) { }
    public:
      typedef bool result_type;
      typedef value_type first_argument_type;
      typedef value_type second_argument_type;
      bool operator()(const value_type& x, const value_type& y) const {
        return comp(x.first, y.first);
      }
    };

    // [:en] construct/copy/destroy:
    multimap() : multimap(Compare()) { }
    explicit multimap(const Compare& comp, const Allocator& = Allocator());
    template <class InputIterator>
      multimap(InputIterator first, InputIterator last,
               const Compare& comp = Compare(),
               const Allocator& = Allocator());
    multimap(const multimap& x);
    multimap(multimap&& x);
    explicit multimap(const Allocator&);
    multimap(const multimap&, const Allocator&);
    multimap(multimap&&, const Allocator&);
    multimap(initializer_list<value_type>,
      const Compare& = Compare(),
      const Allocator& = Allocator());
    template <class InputIterator>
      multimap(InputIterator first, InputIterator last, const Allocator& a)
        : multimap(first, last, Compare(), a) { }
    multimap(initializer_list<value_type> il, const Allocator& a)
      : multimap(il, Compare(), a) { }
   ~multimap();
    multimap& operator=(const multimap& x);
    multimap& operator=(multimap&& x)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable<Compare>::value);
    multimap& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // [:en] iterators:
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // [:en] capacity:
    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // [:en] modifiers:
    template <class... Args> iterator emplace(Args&&... args);
    template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    iterator insert(const value_type& x);
    iterator insert(value_type&& x);
    template <class P> iterator insert(P&& x);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    template <class P> iterator insert(const_iterator position, P&& x);
    template <class InputIterator>
      void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(multimap&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               noexcept(swap(declval<Compare&>(), declval<Compare&>())));
    void      clear() noexcept;

    // [:en] observers:
    key_compare key_comp() const;
    value_compare value_comp() const;

    // [:en] map operations:
    iterator       find(const key_type& x);
    const_iterator find(const key_type& x) const;
    template <class K> iterator       find(const K& x);
    template <class K> const_iterator find(const K& x) const;

    size_type      count(const key_type& x) const;
    template <class K> size_type count(const K& x) const;

    iterator       lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    template <class K> iterator       lower_bound(const K& x);
    template <class K> const_iterator lower_bound(const K& x) const;

    iterator       upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    template <class K> iterator       upper_bound(const K& x);
    template <class K> const_iterator upper_bound(const K& x) const;

    pair<iterator, iterator>               equal_range(const key_type& x);
    pair<const_iterator, const_iterator>   equal_range(const key_type& x) const;
    template <class K>
      pair<iterator, iterator>             equal_range(const K& x);
    template <class K>
      pair<const_iterator, const_iterator> equal_range(const K& x) const;
  };

  template <class Key, class T, class Compare, class Allocator>
    bool operator==(const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator< (const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator!=(const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator> (const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator>=(const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);
  template <class Key, class T, class Compare, class Allocator>
    bool operator<=(const multimap<Key, T, Compare, Allocator>& x,
                    const multimap<Key, T, Compare, Allocator>& y);

  // [:en] specialized algorithms:
  template <class Key, class T, class Compare, class Allocator>
    void swap(multimap<Key, T, Compare, Allocator>& x,
              multimap<Key, T, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
[codeblock:end]
[%@library multimap[!operator==]]
[%@library multimap[!operator<]]

[/     3[multimap.cons]{[`multimap} constructors}/]
[section#multimap.cons
    [:en] [`multimap] constructors
]

[%@library multimap[!multimap]]
[codeblock:declaration]
explicit multimap(const Compare& comp, const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty [`multimap] using the specified comparison object and
allocator.

[para:complexity]
[:en] Constant.
[exit:description]

[%@library multimap[!multimap]]
[codeblock:declaration]
template <class InputIterator>
  multimap(InputIterator first, InputIterator last,
           const Compare& comp = Compare(),
           const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:requires]
[:en] If the iterator[=']s indirection operator returns an lvalue or a const
rvalue [`pair<key_type, mapped_type>], then both [`key_type] and [`mapped_type]
shall be [`CopyInsertable] into [`*this].

[para:effects]
[:en] Constructs an empty [`multimap] using the specified comparison object and
allocator, and inserts elements from the range [=range[first,last)].

[para:complexity]
[:en] Linear in [$N] if the range [=range[first,last)] is already sorted using
[`comp] and otherwise [$N] log([$N]), where [$N] is [`last - first].
[exit:description]

[/     3[multimap.modifiers]{[`multimap} modifiers}/]
[section#multimap.modifiers
    [:en] [`multimap] modifiers
]

[%@library insert[!multimap]]
[%@library multimap[!insert]]
[codeblock:declaration]
template <class P> iterator insert(P&& x);
template <class P> iterator insert(const_iterator position, P&& x);
[codeblock:end]

[enter:description]
[para:effects]
[:en] The first form is equivalent to  [`return emplace(std::forward<P>(x))].

[:en] The second form is equivalent to [`return emplace_hint(position,
std::forward<P>(x))].

[para:remarks]
[:en] These signatures shall not participate in overload resolution unless
[`std::is_constructible<value_type, P&&>::value] is [`true].
[exit:description]

[/     3[multimap.special]{[`multimap} specialized algorithms}/]
[section#multimap.special
    [:en] [`multimap] specialized algorithms
]

[%@library swap[!multimap]]
[%@library multimap[!swap]]
[codeblock:declaration]
template <class Key, class T, class Compare, class Allocator>
  void swap(multimap<Key, T, Compare, Allocator>& x,
            multimap<Key, T, Compare, Allocator>& y)
    noexcept(noexcept(x.swap(y)));
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
x.swap(y);
[codeblock:end]
[exit:description]

[/     2[set]{Class template [`set}}/]
[section#set
    [:en] Class template [`set]
]

[/     3[set.overview]{Class template [`set} overview}/]
[section#set.overview
    [:en] Class template [`set] overview
]

[para]
[%@library set]
[:en] A [`set] is an associative container that supports unique keys (contains
at most one of each key value) and provides for fast retrieval of the keys
themselves.

[:en] The [`set] class supports bidirectional iterators.

[para]
[:en] A [`set] satisfies all of the requirements of a container, of a reversible
container ([#container.requirements]), of an associative container
([#associative.reqmts]), and of an allocator-aware container (Table
[#tab:containers.allocatoraware]).

[:en] A [`set] also provides most operations described in
([#associative.reqmts]) for unique keys.

[:en] This means that a [`set] supports the [`a_uniq] operations in
([#associative.reqmts]) but not the [`a_eq] operations.

[:en] For a [`set<Key>] both the [`key_type] and [`value_type] are [`Key].

[:en] Descriptions are provided here only for operations on [`set] that are not
described in one of these tables and for operations where there is additional
semantic information.

[codeblock:synopsis [special implementation-defined] ]
namespace std {
  template <class Key, class Compare = less<Key>,
            class Allocator = allocator<Key> >
  class set {
  public:
    // [:en] types:
    typedef Key                                   key_type;
    typedef Key                                   value_type;
    typedef Compare                               key_compare;
    typedef Compare                               value_compare;
    typedef Allocator                             allocator_type;
    typedef value_type&                           reference;
    typedef const value_type&                     const_reference;
    typedef implementation-defined                iterator;       // [:en] See [#container.requirements]
    typedef implementation-defined                const_iterator; // [:en] See [#container.requirements]
    typedef implementation-defined                size_type;      // [:en] See [#container.requirements]
    typedef implementation-defined                difference_type;// [:en] See [#container.requirements]
    typedef typename allocator_traits<Allocator>::pointer           pointer;
    typedef typename allocator_traits<Allocator>::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // [:en] [#set.cons], construct/copy/destroy:
    set() : set(Compare()) { }
    explicit set(const Compare& comp, const Allocator& = Allocator());
    template <class InputIterator>
      set(InputIterator first, InputIterator last,
          const Compare& comp = Compare(), const Allocator& = Allocator());
    set(const set& x);
    set(set&& x);
    explicit set(const Allocator&);
    set(const set&, const Allocator&);
    set(set&&, const Allocator&);
    set(initializer_list<value_type>, const Compare& = Compare(),
        const Allocator& = Allocator());
    template <class InputIterator>
      set(InputIterator first, InputIterator last, const Allocator& a)
        : set(first, last, Compare(), a) { }
    set(initializer_list<value_type> il, const Allocator& a)
      : set(il, Compare(), a) { }
   ~set();
    set& operator=(const set& x);
    set& operator=(set&& x)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable<Compare>::value);
    set& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // [:en] iterators:
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // [:en] capacity:
    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // [:en] modifiers:
    template <class... Args> pair<iterator, bool> emplace(Args&&... args);
    template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator,bool> insert(const value_type& x);
    pair<iterator,bool> insert(value_type&& x);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    template <class InputIterator>
      void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(set&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               noexcept(swap(declval<Compare&>(), declval<Compare&>())));
    void      clear() noexcept;

    // [:en] observers:
    key_compare key_comp() const;
    value_compare value_comp() const;

    // [:en] set operations:
    iterator       find(const key_type& x);
    const_iterator find(const key_type& x) const;
    template <class K> iterator       find(const K& x);
    template <class K> const_iterator find(const K& x) const;

    size_type      count(const key_type& x) const;
    template <class K> size_type count(const K& x) const;

    iterator       lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    template <class K> iterator       lower_bound(const K& x);
    template <class K> const_iterator lower_bound(const K& x) const;

    iterator       upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    template <class K> iterator       upper_bound(const K& x);
    template <class K> const_iterator upper_bound(const K& x) const;

    pair<iterator, iterator>               equal_range(const key_type& x);
    pair<const_iterator, const_iterator>   equal_range(const key_type& x) const;
    template <class K>
      pair<iterator, iterator>             equal_range(const K& x);
    template <class K>
      pair<const_iterator, const_iterator> equal_range(const K& x) const;
  };

  template <class Key, class Compare, class Allocator>
    bool operator==(const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator< (const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator!=(const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator> (const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator>=(const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator<=(const set<Key, Compare, Allocator>& x,
                    const set<Key, Compare, Allocator>& y);

  // [:en] specialized algorithms:
  template <class Key, class Compare, class Allocator>
    void swap(set<Key, Compare, Allocator>& x,
              set<Key, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
[codeblock:end]
[%@library set[!operator==]]
[%@library set[!operator<]]

[/     3[set.cons]{[`set} constructors, copy, and assignment}/]
[section#set.cons
    [:en] [`set] constructors, copy, and assignment
]

[%@library set[!set]]
[codeblock:declaration]
explicit set(const Compare& comp, const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty set using the specified comparison objects and
allocator.

[para:complexity]
[:en] Constant.
[exit:description]

[%@library set[!set]]
[codeblock:declaration]
template <class InputIterator>
  set(InputIterator first, InputIterator last,
      const Compare& comp = Compare(), const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty [`set] using the specified comparison object and
allocator, and inserts elements from the range [=range[first,last)].

[para:requires]
[:en] If the iterator[=']s indirection operator returns an lvalue or a non-const
rvalue, then [`Key] shall be [`CopyInsertable] into [`*this].

[para:complexity]
[:en] Linear in [$N] if the range [=range[first,last)] is already sorted using
[`comp] and otherwise [$N] log([$N]), where [$N] is [`last - first].
[exit:description]

[/     3[set.special]{[`set} specialized algorithms}/]
[section#set.special
    [:en] [`set] specialized algorithms
]

[%@library swap[!set]]
[%@library set[!swap]]
[codeblock:declaration]
template <class Key, class Compare, class Allocator>
  void swap(set<Key, Compare, Allocator>& x,
            set<Key, Compare, Allocator>& y)
    noexcept(noexcept(x.swap(y)));
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
x.swap(y);
[codeblock:end]
[exit:description]

[/     2[multiset]{Class template [`multiset}}/]
[section#multiset
    [:en] Class template [`multiset]
]

[/     3[multiset.overview]{Class template [`multiset} overview}/]
[section#multiset.overview
    [:en] Class template [`multiset] overview
]

[para]
[%@library multiset]
[:en] A [`multiset] is an associative container that supports equivalent keys
(possibly contains multiple copies of the same key value) and provides for fast
retrieval of the keys themselves.

[:en] The [`multiset] class supports bidirectional iterators.

[para]
[:en] A [`multiset] satisfies all of the requirements of a container, of a
reversible container ([#container.requirements]), of an associative container
([#associative.reqmts]), and of an allocator-aware container (Table
[#tab:containers.allocatoraware]).

[:en] [`multiset] also provides most operations described in
([#associative.reqmts]) for duplicate keys.

[:en] This means that a [`multiset] supports the [`a_eq] operations in
([#associative.reqmts]) but not the [`a_uniq] operations.

[:en] For a [`multiset<Key>] both the [`key_type] and [`value_type] are [`Key].

[:en] Descriptions are provided here only for operations on [`multiset] that are
not described in one of these tables and for operations where there is
additional semantic information.

[codeblock:synopsis [special implementation-defined] ]
namespace std {
  template <class Key, class Compare = less<Key>,
            class Allocator = allocator<Key> >
  class multiset {
  public:
    // [:en] types:
    typedef Key                                                     key_type;
    typedef Key                                                     value_type;
    typedef Compare                                                 key_compare;
    typedef Compare                                                 value_compare;
    typedef Allocator                                               allocator_type;
    typedef value_type&                                             reference;
    typedef const value_type&                                       const_reference;
    typedef implementation-defined                iterator;       // [:en] see [#container.requirements]
    typedef implementation-defined                const_iterator; // [:en] see [#container.requirements]
    typedef implementation-defined                size_type;      // [:en] see [#container.requirements]
    typedef implementation-defined                difference_type;// [:en] see [#container.requirements]
    typedef typename allocator_traits<Allocator>::pointer           pointer;
    typedef typename allocator_traits<Allocator>::const_pointer     const_pointer;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

    // [:en] construct/copy/destroy:
    multiset() : multiset(Compare()) { }
    explicit multiset(const Compare& comp, const Allocator& = Allocator());
    template <class InputIterator>
      multiset(InputIterator first, InputIterator last,
               const Compare& comp = Compare(), const Allocator& = Allocator());
    multiset(const multiset& x);
    multiset(multiset&& x);
    explicit multiset(const Allocator&);
    multiset(const multiset&, const Allocator&);
    multiset(multiset&&, const Allocator&);
    multiset(initializer_list<value_type>, const Compare& = Compare(),
             const Allocator& = Allocator());
    template <class InputIterator>
      multiset(InputIterator first, InputIterator last, const Allocator& a)
        : multiset(first, last, Compare(), a) { }
    multiset(initializer_list<value_type> il, const Allocator& a)
      : multiset(il, Compare(), a) { }
   ~multiset();
    multiset& operator=(const multiset& x);
    multiset& operator=(multiset&& x)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable<Compare>::value);
    multiset& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // [:en] iterators:
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;

    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;

    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    // [:en] capacity:
    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // [:en] modifiers:
    template <class... Args> iterator emplace(Args&&... args);
    template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    iterator insert(const value_type& x);
    iterator insert(value_type&& x);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    template <class InputIterator>
      void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(multiset&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               noexcept(swap(declval<Compare&>(), declval<Compare&>())));
    void      clear() noexcept;

    // [:en] observers:
    key_compare key_comp() const;
    value_compare value_comp() const;

    // [:en] set operations:
    iterator       find(const key_type& x);
    const_iterator find(const key_type& x) const;
    template <class K> iterator       find(const K& x);
    template <class K> const_iterator find(const K& x) const;

    size_type      count(const key_type& x) const;
    template <class K> size_type count(const K& x) const;

    iterator       lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    template <class K> iterator       lower_bound(const K& x);
    template <class K> const_iterator lower_bound(const K& x) const;

    iterator       upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    template <class K> iterator       upper_bound(const K& x);
    template <class K> const_iterator upper_bound(const K& x) const;

    pair<iterator, iterator>               equal_range(const key_type& x);
    pair<const_iterator, const_iterator>   equal_range(const key_type& x) const;
    template <class K>
      pair<iterator, iterator>             equal_range(const K& x);
    template <class K>
      pair<const_iterator, const_iterator> equal_range(const K& x) const;
  };

  template <class Key, class Compare, class Allocator>
    bool operator==(const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator< (const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator!=(const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator> (const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator>=(const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);
  template <class Key, class Compare, class Allocator>
    bool operator<=(const multiset<Key, Compare, Allocator>& x,
                    const multiset<Key, Compare, Allocator>& y);

  // [:en] specialized algorithms:
  template <class Key, class Compare, class Allocator>
    void swap(multiset<Key, Compare, Allocator>& x,
              multiset<Key, Compare, Allocator>& y)
      noexcept(noexcept(x.swap(y)));
}
[codeblock:end]
[%@library multiset[!operator==]]
[%@library multiset[!operator<]]

[/     3[multiset.cons]{[`multiset} constructors}/]
[section#multiset.cons
    [:en] [`multiset] constructors
]

[%@library multiset[!multiset]]
[codeblock:declaration]
explicit multiset(const Compare& comp, const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty set using the specified comparison object and
allocator.

[para:complexity]
[:en] Constant.
[exit:description]

[%@library multiset[!multiset]]
[codeblock:declaration]
template <class InputIterator>
  multiset(InputIterator first, InputIterator last,
           const Compare& comp = Compare(), const Allocator& = Allocator());
[codeblock:end]

[enter:description]
[para:requires]
[:en] If the iterator[=']s indirection operator returns an lvalue or a const
rvalue, then [`Key] shall be [`CopyInsertable] into [`*this].

[para:effects]
[:en] Constructs an empty [`multiset] using the specified comparison object and
allocator, and inserts elements from the range [=range[first,last)].

[para:complexity]
[:en] Linear in [$N] if the range [=range[first,last)] is already sorted using
[`comp] and otherwise [$N] log([$N]), where [$N] is [`last - first].
[exit:description]

[/     3[multiset.special]{[`multiset} specialized algorithms}/]
[section#multiset.special
    [:en] [`multiset] specialized algorithms
]

[%@library swap[!multiset]]
[%@library multiset[!swap]]
[codeblock:declaration]
template <class Key, class Compare, class Allocator>
  void swap(multiset<Key, Compare, Allocator>& x,
            multiset<Key, Compare, Allocator>& y)
    noexcept(noexcept(x.swap(y)));
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
x.swap(y);
[codeblock:end]
[exit:description]

[/     1[unord]{Unordered associative containers}/]
[section#unord
    [:en] Unordered associative containers
]

[/     2[unord.general]{In general}/]
[section#unord.general
    [:en] In general
]

[para]
[:en] The header [`<unordered_map>] defines the class templates [`unordered_map]
and [`unordered_multimap]; the header [`<unordered_set>] defines the class
templates [`unordered_set] and [`unordered_multiset].

[/     2[unord.map.syn]{Header [`<unordered_map>} synopsis]]/]
[section#unord.map.syn
    [:en] Header [`<unordered_map>] synopsis
]

[%@library <unordered_map> [sortas unordered_map]]
[%@library unordered_map]
[%@library unordered_multimap]
[codeblock:synopsis]
#include <initializer_list>

namespace std {
  // [:en] [#unord.map], class template unordered_map:
  template <class Key,
            class T,
            class Hash = hash<Key>,
            class Pred = std::equal_to<Key>,
            class Alloc = std::allocator<std::pair<const Key, T> > >
    class unordered_map;

  // [:en] [#unord.multimap], class template unordered_multimap:
  template <class Key,
            class T,
            class Hash = hash<Key>,
            class Pred = std::equal_to<Key>,
            class Alloc = std::allocator<std::pair<const Key, T> > >
    class unordered_multimap;

  template <class Key, class T, class Hash, class Pred, class Alloc>
    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
              unordered_map<Key, T, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));

  template <class Key, class T, class Hash, class Pred, class Alloc>
    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
              unordered_multimap<Key, T, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));

  template <class Key, class T, class Hash, class Pred, class Alloc>
    bool operator==(const unordered_map<Key, T, Hash, Pred, Alloc>& a,
                    const unordered_map<Key, T, Hash, Pred, Alloc>& b);
  template <class Key, class T, class Hash, class Pred, class Alloc>
    bool operator!=(const unordered_map<Key, T, Hash, Pred, Alloc>& a,
                    const unordered_map<Key, T, Hash, Pred, Alloc>& b);
  template <class Key, class T, class Hash, class Pred, class Alloc>
    bool operator==(const unordered_multimap<Key, T, Hash, Pred, Alloc>& a,
                    const unordered_multimap<Key, T, Hash, Pred, Alloc>& b);
  template <class Key, class T, class Hash, class Pred, class Alloc>
    bool operator!=(const unordered_multimap<Key, T, Hash, Pred, Alloc>& a,
                    const unordered_multimap<Key, T, Hash, Pred, Alloc>& b);
} // namespace std
[codeblock:end]

[/     2[unord.set.syn]{Header [`<unordered_set>} synopsis]]/]
[section#unord.set.syn
    [:en] Header [`<unordered_set>] synopsis
]

[%@library <unordered_set>[sortas unordered_set]]
[%@library unordered_set]
[%@library unordered_multiset]
[codeblock:synopsis]
#include <initializer_list>

namespace std {
  // [:en] [#unord.set], class template unordered_set:
  template <class Key,
            class Hash = hash<Key>,
            class Pred = std::equal_to<Key>,
            class Alloc = std::allocator<Key> >
    class unordered_set;

  // [:en] [#unord.multiset], class template unordered_multiset:
  template <class Key,
            class Hash = hash<Key>,
            class Pred = std::equal_to<Key>,
            class Alloc = std::allocator<Key> >
    class unordered_multiset;

  template <class Key, class Hash, class Pred, class Alloc>
    void swap(unordered_set<Key, Hash, Pred, Alloc>& x,
              unordered_set<Key, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));

  template <class Key, class Hash, class Pred, class Alloc>
    void swap(unordered_multiset<Key, Hash, Pred, Alloc>& x,
              unordered_multiset<Key, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));

  template <class Key, class Hash, class Pred, class Alloc>
    bool operator==(const unordered_set<Key, Hash, Pred, Alloc>& a,
                    const unordered_set<Key, Hash, Pred, Alloc>& b);
  template <class Key, class Hash, class Pred, class Alloc>
    bool operator!=(const unordered_set<Key, Hash, Pred, Alloc>& a,
                    const unordered_set<Key, Hash, Pred, Alloc>& b);
  template <class Key, class Hash, class Pred, class Alloc>
    bool operator==(const unordered_multiset<Key, Hash, Pred, Alloc>& a,
                    const unordered_multiset<Key, Hash, Pred, Alloc>& b);
  template <class Key, class Hash, class Pred, class Alloc>
    bool operator!=(const unordered_multiset<Key, Hash, Pred, Alloc>& a,
                    const unordered_multiset<Key, Hash, Pred, Alloc>& b);
} // namespace std
[codeblock:end]

[/     2[unord.map]{Class template [`unordered_map}]]/]
[section#unord.map
    [:en] Class template [`unordered_map]
]

[%@library unordered_map]

[/     3[unord.map.overview]{Class template [`unordered_map} overview}/]
[section#unord.map.overview
    [:en] Class template [`unordered_map] overview
]

[para]
[:en]
[%[`unordered_map][!unique keys]]
[%unordered associative containers[!unique keys]]
An [`unordered_map] is an unordered associative container that supports unique
keys (an [`unordered_map] contains at most one of each key value) and that
associates values of another type [`mapped_type] with the keys.

[:en] The [`unordered_map] class supports forward iterators.

[para]
[:en] An [`unordered_map] satisfies all of the requirements of a container, of
an unordered associative container, and of an allocator-aware container (Table
[#tab:containers.allocatoraware]).

[:en] It provides the operations described in the preceding requirements table
for unique keys; that is, an [`unordered_map] supports the [`a_uniq] operations
in that table, not the [`a_eq] operations.

[:en] For an [`unordered_map<Key, T>] the [`key type] is [`Key], the mapped type
is [`T], and the value type is [`std::pair<const Key, T>].

[para]
[:en] This section only describes operations on [`unordered_map] that are not
described in one of the requirement tables, or for which there is additional
semantic information.

[%@library unordered_map]
[codeblock:synopsis [special implementation-defined] ]
namespace std {
  template <class Key,
            class T,
            class Hash = hash<Key>,
            class Pred = std::equal_to<Key>,
            class Allocator = std::allocator<std::pair<const Key, T> > >
  class unordered_map
  {
  public:
    // [:en] types
    typedef Key                                                 key_type;
    typedef std::pair<const Key, T>                             value_type;
    typedef T                                                   mapped_type;
    typedef Hash                                                hasher;
    typedef Pred                                                key_equal;
    typedef Allocator                                           allocator_type;
    typedef typename allocator_traits<Allocator>::pointer       pointer;
    typedef typename allocator_traits<Allocator>::const_pointer const_pointer;
    typedef value_type&                                         reference;
    typedef const value_type&                                   const_reference;
    typedef implementation-defined                              size_type;
    typedef implementation-defined                              difference_type;

    typedef implementation-defined                              iterator;
    typedef implementation-defined                              const_iterator;
    typedef implementation-defined                              local_iterator;
    typedef implementation-defined                              const_local_iterator;

    // [:en] construct/destroy/copy
    unordered_map();
    explicit unordered_map(size_type n,
                           const hasher& hf = hasher(),
                           const key_equal& eql = key_equal(),
                           const allocator_type& a = allocator_type());
    template <class InputIterator>
      unordered_map(InputIterator f, InputIterator l,
                    size_type n = [=Seebelow],
                    const hasher& hf = hasher(),
                    const key_equal& eql = key_equal(),
                    const allocator_type& a = allocator_type());
    unordered_map(const unordered_map&);
    unordered_map(unordered_map&&);
    explicit unordered_map(const Allocator&);
    unordered_map(const unordered_map&, const Allocator&);
    unordered_map(unordered_map&&, const Allocator&);
    unordered_map(initializer_list<value_type> il,
                  size_type n = [=Seebelow],
                  const hasher& hf = hasher(),
                  const key_equal& eql = key_equal(),
                  const allocator_type& a = allocator_type());
    unordered_map(size_type n, const allocator_type& a)
      : unordered_map(n, hasher(), key_equal(), a) { }
    unordered_map(size_type n, const hasher& hf, const allocator_type& a)
      : unordered_map(n, hf, key_equal(), a) { }
    template <class InputIterator>
      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
        : unordered_map(f, l, n, hasher(), key_equal(), a) { }
    template <class InputIterator>
      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher& hf,
                    const allocator_type& a)
        : unordered_map(f, l, n, hf, key_equal(), a) { }
    unordered_map(initializer_list<value_type> il, size_type n, const allocator_type& a)
      : unordered_map(il, n, hasher(), key_equal(), a) { }
    unordered_map(initializer_list<value_type> il, size_type n, const hasher& hf,
                  const allocator_type& a)
      : unordered_map(il, n, hf, key_equal(), a) { }
    ~unordered_map();
    unordered_map& operator=(const unordered_map&);
    unordered_map& operator=(unordered_map&&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable<Hash>::value &&
               is_nothrow_move_assignable<Pred>::value);
    unordered_map& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // [:en] iterators
    iterator       begin() noexcept;
    const_iterator begin() const noexcept;
    iterator       end() noexcept;
    const_iterator end() const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator cend() const noexcept;

    // [:en] size and capacity
    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // [:en] modifiers
    template <class... Args> pair<iterator, bool> emplace(Args&&... args);
    template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator, bool> insert(const value_type& obj);
    pair<iterator, bool> insert(value_type&& obj);
    template <class P> pair<iterator, bool> insert(P&& obj);
    iterator       insert(const_iterator hint, const value_type& obj);
    iterator       insert(const_iterator hint, value_type&& obj);
    template <class P> iterator insert(const_iterator hint, P&& obj);
    template <class InputIterator> void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    template <class... Args>
      pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
    template <class... Args>
      pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
    template <class... Args>
      iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
    template <class... Args>
      iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
    template <class M>
      pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
    template <class M>
      pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
    template <class M>
      iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
    template <class M>
      iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(unordered_map&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               noexcept(swap(declval<Hash&>(), declval<Hash&>())) &&
               noexcept(swap(declval<Pred&>(), declval<Pred&>())));
    void      clear() noexcept;

    // [:en] observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // [:en] lookup
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type      count(const key_type& k) const;
    std::pair<iterator, iterator>             equal_range(const key_type& k);
    std::pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    mapped_type& operator[](const key_type& k);
    mapped_type& operator[](key_type&& k);
    mapped_type& at(const key_type& k);
    const mapped_type& at(const key_type& k) const;

    // [:en] bucket interface
    size_type bucket_count() const noexcept;
    size_type max_bucket_count() const noexcept;
    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n);
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    // [:en] hash policy
    float load_factor() const noexcept;
    float max_load_factor() const noexcept;
    void max_load_factor(float z);
    void rehash(size_type n);
    void reserve(size_type n);
  };

  template <class Key, class T, class Hash, class Pred, class Alloc>
    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
              unordered_map<Key, T, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));

  template <class Key, class T, class Hash, class Pred, class Alloc>
    bool operator==(const unordered_map<Key, T, Hash, Pred, Alloc>& a,
                    const unordered_map<Key, T, Hash, Pred, Alloc>& b);
  template <class Key, class T, class Hash, class Pred, class Alloc>
    bool operator!=(const unordered_map<Key, T, Hash, Pred, Alloc>& a,
                    const unordered_map<Key, T, Hash, Pred, Alloc>& b);
}
[codeblock:end]

[/     3[unord.map.cnstr]{[`unordered_map} constructors}/]
[section#unord.map.cnstr
    [:en] [`unordered_map] constructors
]

[%@library unordered_map[!unordered_map]]
[codeblock:declaration]
unordered_map() : unordered_map(size_type([=Seebelow])) { }
explicit unordered_map(size_type n,
                       const hasher& hf = hasher(),
                       const key_equal& eql = key_equal(),
                       const allocator_type& a = allocator_type());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty [`unordered_map] using the specified hash function,
key equality function, and allocator, and using at least [`n] buckets.

[:en] For the default constructor, the number of buckets is [%@impldef default
number of buckets in [`unordered_map]] implementation-defined.

[:en] [`max_load_factor()] returns 1.0.

[para:complexity]
[:en] Constant.
[exit:description]

[%@library unordered_map[!unordered_map]]
[codeblock:declaration]
template <class InputIterator>
  unordered_map(InputIterator f, InputIterator l,
                size_type n = [=Seebelow],
                const hasher& hf = hasher(),
                const key_equal& eql = key_equal(),
                const allocator_type& a = allocator_type());
unordered_map(initializer_list<value_type> il,
              size_type n = [=Seebelow],
              const hasher& hf = hasher(),
              const key_equal& eql = key_equal(),
              const allocator_type& a = allocator_type());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty [`unordered_map] using the specified hash function,
key equality function, and allocator, and using at least [`n] buckets.

[:en] If [`n] is not provided, the number of buckets is [%@impldef default
number of buckets in [`unordered_map]] implementation-defined.

[:en] Then inserts elements from the range [=range[f,l)] for the first form, or
from the range [=range[il.begin(),il.end())] for the second form.

[:en] [`max_load_factor()] returns 1.0.

[para:complexity]
[:en] Average case linear, worst case quadratic.
[exit:description]

[/     3[unord.map.elem]{[`unordered_map} element access}/]
[section#unord.map.elem
    [:en] [`unordered_map] element access
]

[%@library unordered_map[!operator'[']]]
[%@library operator'['][!unordered_map]]
[%[`unordered_map][!element access]]
[codeblock:declaration]
mapped_type& operator[](const key_type& k);
mapped_type& operator[](key_type&& k);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`mapped_type] shall be [`DefaultInsertable] into [`*this].

[:en] For the first operator, [`key_type] shall be [`CopyInsertable] into
[`*this].

[:en] For the second operator, [`key_type] shall be [`MoveConstructible].

[para:effects]
[:en] If the [`unordered_map] does not already contain an element whose key is
equivalent to [`[$k]], the first operator inserts the value [`value_type(k,
mapped_type())] and the second operator inserts the value
[`value_type(std::move(k), mapped_type())].

[para:returns]
[:en] A reference to [`x.second], where [`x] is the (unique) element whose key
is equivalent to [`[$k]].

[para:complexity]
[:en] Average case [$[=bigoh](1)], worst case [$[=bigoh]([`size()])].
[exit:description]

[%@library unordered_map][!at]]
[%@library at[!unordered_map]]
[%[`unordered_map][!element access]]
[codeblock:declaration]
mapped_type& at(const key_type& k);
const mapped_type& at(const key_type& k) const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] A reference to [`x.second], where [`x] is the (unique) element whose key
is equivalent to [`k].

[para:throws]
[:en] An exception object of type [`out_of_range] if no such element is present.
[exit:description]

[/     3[unord.map.modifiers]{[`unordered_map} modifiers}/]
[section#unord.map.modifiers
    [:en] [`unordered_map] modifiers
]

[%@library unordered_map[!insert]]
[%@library insert[!unordered_map]]
[codeblock:declaration]
template <class P>
  pair<iterator, bool> insert(P&& obj);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Equivalent to [`return emplace(std::forward<P>(obj))]. 

[para:remarks]
[:en] This signature shall not participate in overload resolution unless
[`std::is_constructible<value_type, P&&>::value] is [`true].
[exit:description]

[%@library unordered_map[!insert]]
[%@library insert[!unordered_map]]
[codeblock:declaration]
template <class P>
  iterator insert(const_iterator hint, P&& obj);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Equivalent to  [`return emplace_hint(hint, std::forward<P>(obj))].

[para:remarks]
[:en] This signature shall not participate in overload resolution unless
[`std::is_constructible<value_type, P&&>::value] is [`true].
[exit:description]

[%@library try_emplace[!unordered_map]]
[%@library unordered_map[!try_emplace]]
[codeblock:declaration]
template <class... Args> pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
template <class... Args> pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
template <class... Args> iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
template <class... Args> iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If the key [`k] already exists in the map, there is no effect.

[:en] Otherwise, inserts an element into the map.

[:en] In the first and third forms, the element is constructed from the
arguments as [`value_type(k, std::forward<Args>(args)...)].

[:en] In the second and fourth forms, the element is constructed from the
arguments as [`value_type(std::move(k), std::forward<Args>(args)...)].

[:en] In the first two overloads, the [`bool] component of the returned pair is
[`true] if and only if the insertion took place.

[:en] The returned [`iterator] points to the element of the map whose key is
equivalent to [`k].

[para:complexity]
[:en] The same as [`emplace] and [`emplace_hint], respectively.
[exit:description]

[%@library insert_or_assign[!unordered_map]]
[%@library unordered_map[!insert_or_assign]]
[codeblock:declaration]
template <class M> pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
template <class M> pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
template <class M> iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
template <class M> iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If the key [`k] does not exist in the map, inserts an element into the
map.

[:en] In the first and third forms, the element is constructed from the
arguments as [`value_type(k, std::forward<Args>(args)...)].

[:en] In the second and fourth forms, the element is constructed from the
arguments as [`value_type(std::move(k), std::forward<Args>(args)...)].

[:en] If the key already exists, [`std::forward<M>(obj)] is assigned to the
[`mapped_type] corresponding to the key.

[:en] In the first two overloads, the [`bool] component of the returned value is
[`true] if and only if the insertion took place.

[:en] The returned [`iterator] points to the element that was inserted or
updated.

[para:complexity]
[:en] The same as [`emplace] and [`emplace_hint], respectively.
[exit:description]

[/     3[unord.map.swap]{[`unordered_map} swap}/]
[section#unord.map.swap
    [:en] [`unordered_map] swap
]

[%@library unordered_map[!swap]]
[%@library swap[!unordered_map]]
[codeblock:declaration]
template <class Key, class T, class Hash, class Pred, class Alloc>
  void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,
            unordered_map<Key, T, Hash, Pred, Alloc>& y)
    noexcept(noexcept(x.swap(y)));
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`x.swap(y)].
[exit:description]

[/     2[unord.multimap]{Class template [`unordered_multimap}]]/]
[section#unord.multimap
    [:en] Class template [`unordered_multimap]
]

[%@library unordered_multimap]

[/     3[unord.multimap.overview]{Class template [`unordered_multimap} overview}/]
[section#unord.multimap.overview
    [:en] Class template [`unordered_multimap] overview
]

[para]
[:en]
[%[`unordered_multimap][!equivalent keys]]
[%unordered associative containers[!equivalent keys]]
An [`unordered_multimap] is an unordered associative container that supports
equivalent keys (an instance of [`unordered_multimap] may contain multiple
copies of each key value) and that associates values of another type
[`mapped_type] with the keys.

[:en] The [`unordered_multimap] class supports forward iterators.

[para]
[:en] An [`unordered_multimap] satisfies all of the requirements of a container,
of an unordered associative container, and of an allocator-aware container
(Table [#tab:containers.allocatoraware]).

[:en] It provides the operations described in the preceding requirements table
for equivalent keys; that is, an [`unordered_multimap] supports the [`a_eq]
operations in that table, not the [`a_uniq] operations.

[:en] For an [`unordered_multimap<Key, T>] the [`key type] is [`Key], the
mapped type is [`T], and the value type is [`std::pair<const Key, T>].

[para]
[:en] This section only describes operations on [`unordered_multimap] that are
not described in one of the requirement tables, or for which there is additional
semantic information.

[%@library unordered_multimap]
[codeblock:synopsis [special implementation-defined] ]
namespace std {
  template <class Key,
            class T,
            class Hash = hash<Key>,
            class Pred = std::equal_to<Key>,
            class Allocator = std::allocator<std::pair<const Key, T> > >
  class unordered_multimap
  {
  public:
    // [:en] types
    typedef Key                                                 key_type;
    typedef std::pair<const Key, T>                             value_type;
    typedef T                                                   mapped_type;
    typedef Hash                                                hasher;
    typedef Pred                                                key_equal;
    typedef Allocator                                           allocator_type;
    typedef typename allocator_traits<Allocator>::pointer       pointer;
    typedef typename allocator_traits<Allocator>::const_pointer const_pointer;
    typedef value_type&                                         reference;
    typedef const value_type&                                   const_reference;
    typedef implementation-defined                              size_type;
    typedef implementation-defined                              difference_type;

    typedef implementation-defined                              iterator;
    typedef implementation-defined                              const_iterator;
    typedef implementation-defined                              local_iterator;
    typedef implementation-defined                              const_local_iterator;

    // [:en] construct/destroy/copy
    unordered_multimap();
    explicit unordered_multimap(size_type n,
                                const hasher& hf = hasher(),
                                const key_equal& eql = key_equal(),
                                const allocator_type& a = allocator_type());
    template <class InputIterator>
      unordered_multimap(InputIterator f, InputIterator l,
                         size_type n = [=Seebelow],
                         const hasher& hf = hasher(),
                         const key_equal& eql = key_equal(),
                         const allocator_type& a = allocator_type());
    unordered_multimap(const unordered_multimap&);
    unordered_multimap(unordered_multimap&&);
    explicit unordered_multimap(const Allocator&);
    unordered_multimap(const unordered_multimap&, const Allocator&);
    unordered_multimap(unordered_multimap&&, const Allocator&);
    unordered_multimap(initializer_list<value_type> il,
                       size_type n = [=Seebelow],
                       const hasher& hf = hasher(),
                       const key_equal& eql = key_equal(),
                       const allocator_type& a = allocator_type());
    unordered_multimap(size_type n, const allocator_type& a)
      : unordered_multimap(n, hasher(), key_equal(), a) { }
    unordered_multimap(size_type n, const hasher& hf, const allocator_type& a)
      : unordered_multimap(n, hf, key_equal(), a) { }
    template <class InputIterator>
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
        : unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
    template <class InputIterator>
      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher& hf, 
                         const allocator_type& a)
        : unordered_multimap(f, l, n, hf, key_equal(), a) { }
    unordered_multimap(initializer_list<value_type> il, size_type n, const allocator_type& a)
      : unordered_multimap(il, n, hasher(), key_equal(), a) { }
    unordered_multimap(initializer_list<value_type> il, size_type n, const hasher& hf, 
                       const allocator_type& a)
      : unordered_multimap(il, n, hf, key_equal(), a) { }
    ~unordered_multimap();
    unordered_multimap& operator=(const unordered_multimap&);
    unordered_multimap& operator=(unordered_multimap&&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable<Hash>::value &&
               is_nothrow_move_assignable<Pred>::value);
    unordered_multimap& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // [:en] iterators
    iterator       begin() noexcept;
    const_iterator begin() const noexcept;
    iterator       end() noexcept;
    const_iterator end() const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator cend() const noexcept;

    // [:en] size and capacity
    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // [:en] modifiers
    template <class... Args> iterator emplace(Args&&... args);
    template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    iterator insert(const value_type& obj);
    iterator insert(value_type&& obj);
    template <class P> iterator insert(P&& obj);
    iterator insert(const_iterator hint, const value_type& obj);
    iterator insert(const_iterator hint, value_type&& obj);
    template <class P> iterator insert(const_iterator hint, P&& obj);
    template <class InputIterator> void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(unordered_multimap&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               noexcept(swap(declval<Hash&>(), declval<Hash&>())) &&
               noexcept(swap(declval<Pred&>(), declval<Pred&>())));
    void      clear() noexcept;

    // [:en] observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // [:en] lookup
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type      count(const key_type& k) const;
    std::pair<iterator, iterator>             equal_range(const key_type& k);
    std::pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    // [:en] bucket interface
    size_type bucket_count() const noexcept;
    size_type max_bucket_count() const noexcept;
    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n);
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    // [:en] hash policy
    float load_factor() const noexcept;
    float max_load_factor() const noexcept;
    void max_load_factor(float z);
    void rehash(size_type n);
    void reserve(size_type n);
  };

  template <class Key, class T, class Hash, class Pred, class Alloc>
    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
              unordered_multimap<Key, T, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));

  template <class Key, class T, class Hash, class Pred, class Alloc>
    bool operator==(const unordered_multimap<Key, T, Hash, Pred, Alloc>& a,
                    const unordered_multimap<Key, T, Hash, Pred, Alloc>& b);
  template <class Key, class T, class Hash, class Pred, class Alloc>
    bool operator!=(const unordered_multimap<Key, T, Hash, Pred, Alloc>& a,
                    const unordered_multimap<Key, T, Hash, Pred, Alloc>& b);
}
[codeblock:end]

[/     3[unord.multimap.cnstr]{[`unordered_multimap} constructors}/]
[section#unord.multimap.cnstr
    [:en] [`unordered_multimap] constructors
]

[%@library unordered_multimap[!unordered_multimap]]
[codeblock:declaration]
unordered_multimap() : unordered_multimap(size_type([=Seebelow])) { }
explicit unordered_multimap(size_type n,
                            const hasher& hf = hasher(),
                            const key_equal& eql = key_equal(),
                            const allocator_type& a = allocator_type());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty [`unordered_multimap] using the specified hash
function, key equality function, and allocator, and using at least [`n] buckets.

[:en] For the default constructor, the number of buckets is [%@impldef default
number of buckets in [`unordered_multimap]] implementation-defined.

[:en] [`max_load_factor()] returns 1.0.

[para:complexity]
[:en] Constant.
[exit:description]

[%@library unordered_multimap[!unordered_multimap]]
[codeblock:declaration]
template <class InputIterator>
  unordered_multimap(InputIterator f, InputIterator l,
                     size_type n = [=Seebelow],
                     const hasher& hf = hasher(),
                     const key_equal& eql = key_equal(),
                     const allocator_type& a = allocator_type());
unordered_multimap(initializer_list<value_type> il,
                   size_type n = [=Seebelow],
                   const hasher& hf = hasher(),
                   const key_equal& eql = key_equal(),
                   const allocator_type& a = allocator_type());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty [`unordered_multimap] using the specified hash
function, key equality function, and allocator, and using at least [`n] buckets.

[:en] If [`n] is not provided, the number of buckets is [%@impldef default
number of buckets in [`unordered_multimap]] implementation-defined.

[:en] Then inserts elements from the range [=range[f,l)] for the first form, or
from the range  [=range[il.begin(),il.end())] for the second form.

[:en] [`max_load_factor()] returns 1.0.

[para:complexity]
[:en] Average case linear, worst case quadratic.
[exit:description]

[/     3[unord.multimap.modifiers]{[`unordered_multimap} modifiers}/]
[section#unord.multimap.modifiers
    [:en] [`unordered_multimap] modifiers
]

[%@library unordered_multimap[!insert]]
[%@library insert[!unordered_multimap]]
[codeblock:declaration]
template <class P>
  iterator insert(P&& obj);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Equivalent to [`return emplace(std::forward<P>(obj))]. 

[para:remarks]
[:en] This signature shall not participate in overload resolution unless
[`std::is_constructible<value_type, P&&>::value] is [`true].
[exit:description]

[%@library unordered_multimap[!insert]]
[%@library insert[!unordered_multimap]]
[codeblock:declaration]
template <class P>
  iterator insert(const_iterator hint, P&& obj);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Equivalent to  [`return emplace_hint(hint, std::forward<P>(obj))].

[para:remarks]
[:en] This signature shall not participate in overload resolution unless
[`std::is_constructible<value_type, P&&>::value] is [`true].
[exit:description]

[/     3[unord.multimap.swap]{[`unordered_multimap} swap}/]
[section#unord.multimap.swap
    [:en] [`unordered_multimap] swap
]

[%@library unordered_multimap[!swap]]
[%@library swap[!unordered_multimap]]
[codeblock:declaration]
template <class Key, class T, class Hash, class Pred, class Alloc>
  void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,
            unordered_multimap<Key, T, Hash, Pred, Alloc>& y)
    noexcept(noexcept(x.swap(y)));
[codeblock:end]


[enter:description]
[para:effects]
[:en] [`x.swap(y)].
[exit:description]

[/     2[unord.set]{Class template [`unordered_set}]]/]
[section#unord.set
    [:en] Class template [`unordered_set]
]

[%@library unordered_set]

[/     3[unord.set.overview]{Class template [`unordered_set} overview}/]
[section#unord.set.overview
    [:en] Class template [`unordered_set] overview
]

[para]
[:en]
[%[`unordered_set][!unique keys]]
[%unordered associative containers[!unique keys]]
An [`unordered_set] is an unordered associative container that supports unique
keys (an [`unordered_set] contains at most one of each key value) and in which
the elements[='] keys are the elements themselves.

[:en] The [`unordered_set] class supports forward iterators.

[para]
[:en] An [`unordered_set] satisfies all of the requirements of a container, of
an unordered associative container, and of an allocator-aware container (Table
[#tab:containers.allocatoraware]).

[:en] It provides the operations described in the preceding requirements table
for unique keys; that is, an [`unordered_set] supports the [`a_uniq] operations
in that table, not the [`a_eq] operations.

[:en] For an [`unordered_set<Key>] the [`key type] and the value type are both
[`Key].

[:en] The [`iterator] and [`const_iterator] types are both const iterator types.

[:en] It is unspecified whether they are the same type.

[para]
[:en] This section only describes operations on [`unordered_set] that are not
described in one of the requirement tables, or for which there is additional
semantic information.

[%@library unordered_set]
[codeblock:synopsis [special implementation-defined] ]
namespace std {
  template <class Key,
            class Hash = hash<Key>,
            class Pred = std::equal_to<Key>,
            class Allocator = std::allocator<Key> >
  class unordered_set
  {
  public:
    // [:en] types
    typedef Key                                                 key_type;
    typedef Key                                                 value_type;
    typedef Hash                                                hasher;
    typedef Pred                                                key_equal;
    typedef Allocator                                           allocator_type;
    typedef typename allocator_traits<Allocator>::pointer       pointer;
    typedef typename allocator_traits<Allocator>::const_pointer const_pointer;
    typedef value_type&                                         reference;
    typedef const value_type&                                   const_reference;
    typedef implementation-defined                              size_type;
    typedef implementation-defined                              difference_type;

    typedef implementation-defined                              iterator;
    typedef implementation-defined                              const_iterator;
    typedef implementation-defined                              local_iterator;
    typedef implementation-defined                              const_local_iterator;

    // [:en] construct/destroy/copy
    unordered_set();
    explicit unordered_set(size_type n,
                           const hasher& hf = hasher(),
                           const key_equal& eql = key_equal(),
                           const allocator_type& a = allocator_type());
    template <class InputIterator>
      unordered_set(InputIterator f, InputIterator l,
                    size_type n = [=Seebelow],
                    const hasher& hf = hasher(),
                    const key_equal& eql = key_equal(),
                    const allocator_type& a = allocator_type());
    unordered_set(const unordered_set&);
    unordered_set(unordered_set&&);
    explicit unordered_set(const Allocator&);
    unordered_set(const unordered_set&, const Allocator&);
    unordered_set(unordered_set&&, const Allocator&);
    unordered_set(initializer_list<value_type> il,
                  size_type n = [=Seebelow],
                  const hasher& hf = hasher(),
                  const key_equal& eql = key_equal(),
                  const allocator_type& a = allocator_type());
    unordered_set(size_type n, const allocator_type& a)
      : unordered_set(n, hasher(), key_equal(), a) { }
    unordered_set(size_type n, const hasher& hf, const allocator_type& a)
      : unordered_set(n, hf, key_equal(), a) { }
    template <class InputIterator>
      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
        : unordered_set(f, l, n, hasher(), key_equal(), a) { }
    template <class InputIterator>
      unordered_set(InputIterator f, InputIterator l, size_type n, const hasher& hf,
                    const allocator_type& a)
      : unordered_set(f, l, n, hf, key_equal(), a) { }
    unordered_set(initializer_list<value_type> il, size_type n, const allocator_type& a)
      : unordered_set(il, n, hasher(), key_equal(), a) { }
    unordered_set(initializer_list<value_type> il, size_type n, const hasher& hf,
                  const allocator_type& a)
      : unordered_set(il, n, hf, key_equal(), a) { }
    ~unordered_set();
    unordered_set& operator=(const unordered_set&);
    unordered_set& operator=(unordered_set&&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable<Hash>::value &&
               is_nothrow_move_assignable<Pred>::value);
    unordered_set& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // [:en] iterators
    iterator       begin() noexcept;
    const_iterator begin() const noexcept;
    iterator       end() noexcept;
    const_iterator end() const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator cend() const noexcept;

    // [:en] size and capacity
    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // [:en] modifiers
    template <class... Args> pair<iterator, bool> emplace(Args&&... args);
    template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator, bool> insert(const value_type& obj);
    pair<iterator, bool> insert(value_type&& obj);
    iterator insert(const_iterator hint, const value_type& obj);
    iterator insert(const_iterator hint, value_type&& obj);
    template <class InputIterator> void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(unordered_set&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               noexcept(swap(declval<Hash&>(), declval<Hash&>())) &&
               noexcept(swap(declval<Pred&>(), declval<Pred&>())));
    void      clear() noexcept;

    // [:en] observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // [:en] lookup
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type      count(const key_type& k) const;
    std::pair<iterator, iterator>             equal_range(const key_type& k);
    std::pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    // [:en] bucket interface
    size_type bucket_count() const noexcept;
    size_type max_bucket_count() const noexcept;
    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n);
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    // [:en] hash policy
    float load_factor() const noexcept;
    float max_load_factor() const noexcept;
    void max_load_factor(float z);
    void rehash(size_type n);
    void reserve(size_type n);
  };

  template <class Key, class Hash, class Pred, class Alloc>
    void swap(unordered_set<Key, Hash, Pred, Alloc>& x,
              unordered_set<Key, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));

  template <class Key, class Hash, class Pred, class Alloc>
    bool operator==(const unordered_set<Key, Hash, Pred, Alloc>& a,
                    const unordered_set<Key, Hash, Pred, Alloc>& b);
  template <class Key, class Hash, class Pred, class Alloc>
    bool operator!=(const unordered_set<Key, Hash, Pred, Alloc>& a,
                    const unordered_set<Key, Hash, Pred, Alloc>& b);
}
[codeblock:end]

[/     3[unord.set.cnstr]{[`unordered_set} constructors}/]
[section#unord.set.cnstr
    [:en] [`unordered_set] constructors
]

[%@library unordered_set[!unordered_set]]
[codeblock:declaration]
unordered_set() : unordered_set(size_type([=Seebelow])) { }
explicit unordered_set(size_type n,
                       const hasher& hf = hasher(),
                       const key_equal& eql = key_equal(),
                       const allocator_type& a = allocator_type());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty [`unordered_set] using the specified hash function,
key equality function, and allocator, and using at least [`n] buckets.

[:en] For the default constructor, the number of buckets is [%@impldef default
number of buckets in [`unordered_set]] implementation-defined.

[:en] [`max_load_factor()] returns 1.0.

[para:complexity]
[:en] Constant.
[exit:description]

[%@library unordered_set[!unordered_set]]
[codeblock:declaration]
template <class InputIterator>
  unordered_set(InputIterator f, InputIterator l,
                size_type n = [=Seebelow],
                const hasher& hf = hasher(),
                const key_equal& eql = key_equal(),
                const allocator_type& a = allocator_type());
unordered_set(initializer_list<value_type> il,
              size_type n = [=Seebelow],
              const hasher& hf = hasher(),
              const key_equal& eql = key_equal(),
              const allocator_type& a = allocator_type());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty [`unordered_set] using the specified hash function,
key equality function, and allocator, and using at least [`n] buckets.

[:en] If [`n] is not provided, the number of buckets is [%@impldef default
number of buckets in [`unordered_set]] implementation-defined.

[:en] Then inserts elements from the range [=range[f,l)] for the first form, or
from the range  [=range[il.begin(),il.end())] for the second form.

[:en] [`max_load_factor()] returns 1.0.

[para:complexity]
[:en] Average case linear, worst case quadratic.
[exit:description]

[/     3[unord.set.swap]{[`unordered_set} swap}/]
[section#unord.set.swap
    [:en] [`unordered_set] swap
]

[%@library unordered_set[!swap]]
[%@library swap[!unordered_set]]
[codeblock:declaration]
template <class Key, class Hash, class Pred, class Alloc>
  void swap(unordered_set<Key, Hash, Pred, Alloc>& x,
            unordered_set<Key, Hash, Pred, Alloc>& y)
    noexcept(noexcept(x.swap(y)));
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`x.swap(y)].
[exit:description]

[/     2[unord.multiset]{Class template [`unordered_multiset}]]/]
[section#unord.multiset
    [:en] Class template [`unordered_multiset]
]

[%@library unordered_multiset]

[/     3[unord.multiset.overview]{Class template [`unordered_multiset} overview}/]
[section#unord.multiset.overview
    [:en] Class template [`unordered_multiset] overview
]

[para]
[:en]
[%[`unordered_multiset][!equivalent keys]]
[%unordered associative containers[!equivalent keys]]
An [`unordered_multiset] is an unordered associative container that supports
equivalent keys (an instance of [`unordered_multiset] may contain multiple
copies of the same key value) and in which each element[=']s key is the element
itself.

[:en] The [`unordered_multiset] class supports forward iterators.

[para]
[:en] An [`unordered_multiset] satisfies all of the requirements of a container,
of an unordered associative container, and of an allocator-aware container
(Table [#tab:containers.allocatoraware]).

[:en] It provides the operations described in the preceding requirements table
for equivalent keys; that is, an [`unordered_multiset] supports the [`a_eq]
operations in that table, not the [`a_uniq] operations.

[:en] For an [`unordered_multiset<Key>] the [`key type] and the value type are
both [`Key]. The [`iterator] and [`const_iterator] types are both const iterator
types.

[:en] It is unspecified whether they are the same type.

[para]
[:en] This section only describes operations on [`unordered_multiset] that are
not described in one of the requirement tables, or for which there is additional
semantic information.

[%@library unordered_multiset]
[codeblock:synopsis [special implementation-defined] ]
namespace std {
  template <class Key,
            class Hash = hash<Key>,
            class Pred = std::equal_to<Key>,
            class Allocator = std::allocator<Key> >
  class unordered_multiset
  {
  public:
    // [:en] types
    typedef Key                                                 key_type;
    typedef Key                                                 value_type;
    typedef Hash                                                hasher;
    typedef Pred                                                key_equal;
    typedef Allocator                                           allocator_type;
    typedef typename allocator_traits<Allocator>::pointer       pointer;
    typedef typename allocator_traits<Allocator>::const_pointer const_pointer;
    typedef value_type&                                         reference;
    typedef const value_type&                                   const_reference;
    typedef implementation-defined                              size_type;
    typedef implementation-defined                              difference_type;

    typedef implementation-defined                              iterator;
    typedef implementation-defined                              const_iterator;
    typedef implementation-defined                              local_iterator;
    typedef implementation-defined                              const_local_iterator;

    // [:en] construct/destroy/copy
    unordered_multiset();
    explicit unordered_multiset(size_type n,
                                const hasher& hf = hasher(),
                                const key_equal& eql = key_equal(),
                                const allocator_type& a = allocator_type());
    template <class InputIterator>
      unordered_multiset(InputIterator f, InputIterator l,
                         size_type n = [=Seebelow],
                         const hasher& hf = hasher(),
                         const key_equal& eql = key_equal(),
                         const allocator_type& a = allocator_type());
    unordered_multiset(const unordered_multiset&);
    unordered_multiset(unordered_multiset&&);
    explicit unordered_multiset(const Allocator&);
    unordered_multiset(const unordered_multiset&, const Allocator&);
    unordered_multiset(unordered_multiset&&, const Allocator&);
    unordered_multiset(initializer_list<value_type> il,
                       size_type n = [=Seebelow],
                       const hasher& hf = hasher(),
                       const key_equal& eql = key_equal(),
                       const allocator_type& a = allocator_type());
    unordered_multiset(size_type n, const allocator_type& a)
      : unordered_multiset(n, hasher(), key_equal(), a) { }
    unordered_multiset(size_type n, const hasher& hf, const allocator_type& a)
      : unordered_multiset(n, hf, key_equal(), a) { }
    template <class InputIterator>
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
        : unordered_multiset(f, l, n, hasher(), key_equal(), a) { }
    template <class InputIterator>
      unordered_multiset(InputIterator f, InputIterator l, size_type n, const hasher& hf, 
                         const allocator_type& a)
      : unordered_multiset(f, l, n, hf, key_equal(), a) { }
    unordered_multiset(initializer_list<value_type> il, size_type n, const allocator_type& a)
      : unordered_multiset(il, n, hasher(), key_equal(), a) { }
    unordered_multiset(initializer_list<value_type> il, size_type n, const hasher& hf, 
                       const allocator_type& a)
      : unordered_multiset(il, n, hf, key_equal(), a) { }
    ~unordered_multiset();
    unordered_multiset& operator=(const unordered_multiset&);
    unordered_multiset& operator=(unordered_multiset&&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               is_nothrow_move_assignable<Hash>::value &&
               is_nothrow_move_assignable<Pred>::value);
    unordered_multiset& operator=(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;

    // [:en] iterators
    iterator       begin() noexcept;
    const_iterator begin() const noexcept;
    iterator       end() noexcept;
    const_iterator end() const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator cend() const noexcept;

    // [:en] size and capacity
    bool      empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // [:en] modifiers
    template <class... Args> iterator emplace(Args&&... args);
    template <class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    iterator insert(const value_type& obj);
    iterator insert(value_type&& obj);
    iterator insert(const_iterator hint, const value_type& obj);
    iterator insert(const_iterator hint, value_type&& obj);
    template <class InputIterator> void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type>);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(unordered_multiset&)
      noexcept(allocator_traits<Allocator>::is_always_equal::value &&
               noexcept(swap(declval<Hash&>(), declval<Hash&>())) &&
               noexcept(swap(declval<Pred&>(), declval<Pred&>())));
    void      clear() noexcept;

    // [:en] observers
    hasher hash_function() const;
    key_equal key_eq() const;

    // [:en] lookup
    iterator       find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type      count(const key_type& k) const;
    std::pair<iterator, iterator>             equal_range(const key_type& k);
    std::pair<const_iterator, const_iterator> equal_range(const key_type& k) const;

    // [:en] bucket interface
    size_type bucket_count() const noexcept;
    size_type max_bucket_count() const noexcept;
    size_type bucket_size(size_type n) const;
    size_type bucket(const key_type& k) const;
    local_iterator begin(size_type n);
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    // [:en] hash policy
    float load_factor() const noexcept;
    float max_load_factor() const noexcept;
    void max_load_factor(float z);
    void rehash(size_type n);
    void reserve(size_type n);
  };

  template <class Key, class Hash, class Pred, class Alloc>
    void swap(unordered_multiset<Key, Hash, Pred, Alloc>& x,
              unordered_multiset<Key, Hash, Pred, Alloc>& y)
      noexcept(noexcept(x.swap(y)));

  template <class Key, class Hash, class Pred, class Alloc>
    bool operator==(const unordered_multiset<Key, Hash, Pred, Alloc>& a,
                    const unordered_multiset<Key, Hash, Pred, Alloc>& b);
  template <class Key, class Hash, class Pred, class Alloc>
    bool operator!=(const unordered_multiset<Key, Hash, Pred, Alloc>& a,
                    const unordered_multiset<Key, Hash, Pred, Alloc>& b);
}
[codeblock:end]

[/     3[unord.multiset.cnstr]{[`unordered_multiset} constructors}/]
[section#unord.multiset.cnstr
    [:en] [`unordered_multiset] constructors
]

[%@library unordered_multiset[!unordered_multiset]]
[codeblock:declaration]
unordered_multiset() : unordered_multiset(size_type([=Seebelow])) { }
explicit unordered_multiset(size_type n,
                            const hasher& hf = hasher(),
                            const key_equal& eql = key_equal(),
                            const allocator_type& a = allocator_type());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty [`unordered_multiset] using the specified hash
function, key equality function, and allocator, and using at least [`n] buckets.

[:en] For the default constructor, the number of buckets is [%@impldef default
number of buckets in [`unordered_multiset]] implementation-defined.

[:en] [`max_load_factor()] returns 1.0.

[para:complexity]
[:en] Constant.
[exit:description]

[%@library unordered_multiset[!unordered_multiset]]
[codeblock:declaration]
template <class InputIterator>
  unordered_multiset(InputIterator f, InputIterator l,
                     size_type n = [=Seebelow],
                     const hasher& hf = hasher(),
                     const key_equal& eql = key_equal(),
                     const allocator_type& a = allocator_type());
unordered_multiset(initializer_list<value_type> il,
                   size_type n = [=Seebelow],
                   const hasher& hf = hasher(),
                   const key_equal& eql = key_equal(),
                   const allocator_type& a = allocator_type());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an empty [`unordered_multiset] using the specified hash
function, key equality function, and allocator, and using at least [`n] buckets.

[:en] If [`n] is not provided, the number of buckets is [%@impldef default
number of buckets in [`unordered_multiset]] implementation-defined.

[:en] Then inserts elements from the range [=range[f,l)] for the first form, or
from the range [=range[il.begin(),il.end())] for the second form.

[:en] [`max_load_factor()] returns 1.0.

[para:complexity]
[:en] Average case linear, worst case quadratic.
[exit:description]

[/     3[unord.multiset.swap]{[`unordered_multiset} swap}/]
[section#unord.multiset.swap
    [:en] [`unordered_multiset] swap
]

[%@library unordered_multiset[!swap]]
[%@library swap[!unordered_multiset]]
[codeblock:declaration]
template <class Key, class Hash, class Pred, class Alloc>
  void swap(unordered_multiset<Key, Hash, Pred, Alloc>& x,
            unordered_multiset<Key, Hash, Pred, Alloc>& y)
    noexcept(noexcept(x.swap(y)));
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`x.swap(y);]
[exit:description]

[%:end#unordered.associative.containers]

[/     1[container.adaptors]{Container adaptors}/]
[section#container.adaptors
    [:en] Container adaptors
]

[/     2[container.adaptors.general]{In general}/]
[section#container.adaptors.general
    [:en] In general
]

[para]
[:en] The headers [`<queue>] and [`<stack>] define the container adaptors
[`queue], [`priority_queue], and [`stack].

[para]
[:en] The container adaptors each take a [`Container] template parameter, and
each constructor takes a [`Container] reference argument.

[:en] This container is copied into the [`Container] member of each adaptor.

[:en] If the container takes an allocator, then a compatible allocator may be
passed in to the adaptor[=']s constructor.

[:en] Otherwise, normal copy or move construction is used for the container
argument.

[para]
[:en] For container adaptors, no [`swap] function throws an exception unless
that exception is thrown by the swap of the adaptor[=']s [`Container] or
[`Compare] object (if any).

[/     2[queue.syn]{Header [`<queue>} synopsis]]/]
[section#queue.syn
    [:en] Header [`<queue>] synopsis
]

[%@library <queue> [sortas queue]]

[codeblock:synopsis]
#include <initializer_list>

namespace std {
  template <class T, class Container = deque<T> > class queue;
  template <class T, class Container = vector<T>,
            class Compare = less<typename Container::value_type> >
    class priority_queue;

  template <class T, class Container>
    bool operator==(const queue<T, Container>& x, const queue<T, Container>& y);
  template <class T, class Container>
    bool operator< (const queue<T, Container>& x, const queue<T, Container>& y);
  template <class T, class Container>
    bool operator!=(const queue<T, Container>& x, const queue<T, Container>& y);
  template <class T, class Container>
    bool operator> (const queue<T, Container>& x, const queue<T, Container>& y);
  template <class T, class Container>
    bool operator>=(const queue<T, Container>& x, const queue<T, Container>& y);
  template <class T, class Container>
    bool operator<=(const queue<T, Container>& x, const queue<T, Container>& y);

  template <class T, class Container>
    void swap(queue<T, Container>& x, queue<T, Container>& y) noexcept(noexcept(x.swap(y)));
  template <class T, class Container, class Compare>
    void swap(priority_queue<T, Container, Compare>& x,
              priority_queue<T, Container, Compare>& y) noexcept(noexcept(x.swap(y)));
}
[codeblock:end]

[/     2[queue]{Class template [`queue}}/]
[section#queue
    [:en] Class template [`queue]
]

[/     3[queue.defn]{[`queue} definition}/]
[section#queue.defn
    [:en] [`queue] definition
]

[para]
[%@library queue]
[:en] Any sequence container supporting operations [`front()], [`back()],
[`push_back()] and [`pop_front()] can be used to instantiate [`queue].

[:en] In particular, [`list] ([#list]) and [`deque] ([#deque]) can be used.

[codeblock:synopsis]
namespace std {
  template <class T, class Container = deque<T> >
  class queue {
  public:
    typedef typename Container::value_type            value_type;
    typedef typename Container::reference             reference;
    typedef typename Container::const_reference       const_reference;
    typedef typename Container::size_type             size_type;
    typedef          Container                        container_type;

  protected:
    Container c;

  public:
    explicit queue(const Container&);
    explicit queue(Container&& = Container());
    template <class Alloc> explicit queue(const Alloc&);
    template <class Alloc> queue(const Container&, const Alloc&);
    template <class Alloc> queue(Container&&, const Alloc&);
    template <class Alloc> queue(const queue&, const Alloc&);
    template <class Alloc> queue(queue&&, const Alloc&);

    bool              empty() const     { return c.empty(); }
    size_type         size()  const     { return c.size(); }
    reference         front()           { return c.front(); }
    const_reference   front() const     { return c.front(); }
    reference         back()            { return c.back(); }
    const_reference   back() const      { return c.back(); }
    void push(const value_type& x)      { c.push_back(x); }
    void push(value_type&& x)           { c.push_back(std::move(x)); }
    template <class... Args>
      void emplace(Args&&... args)      { c.emplace_back(std::forward<Args>(args)...); }
    void pop()                          { c.pop_front(); }
    void swap(queue& q) noexcept(noexcept(swap(c, q.c)))
      { using std::swap; swap(c, q.c); }
  };

  template <class T, class Container>
    bool operator==(const queue<T, Container>& x, const queue<T, Container>& y);
  template <class T, class Container>
    bool operator< (const queue<T, Container>& x, const queue<T, Container>& y);
  template <class T, class Container>
    bool operator!=(const queue<T, Container>& x, const queue<T, Container>& y);
  template <class T, class Container>
    bool operator> (const queue<T, Container>& x, const queue<T, Container>& y);
  template <class T, class Container>
    bool operator>=(const queue<T, Container>& x, const queue<T, Container>& y);
  template <class T, class Container>
    bool operator<=(const queue<T, Container>& x, const queue<T, Container>& y);

  template <class T, class Container>
    void swap(queue<T, Container>& x, queue<T, Container>& y) noexcept(noexcept(x.swap(y)));

  template <class T, class Container, class Alloc>
    struct uses_allocator<queue<T, Container>, Alloc>
      : uses_allocator<Container, Alloc>::type { };
}
[codeblock:end]

[/     3[queue.cons]{[`queue} constructors}/]
[section#queue.cons
    [:en] [`queue] constructors
]

[codeblock:declaration]
explicit queue(const Container& cont);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`cont].
[exit:description]

[codeblock:declaration]
explicit queue(Container&& cont = Container());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`std::move(cont)].
[exit:description]

[/     3[queue.cons.alloc]{[`queue} constructors with allocators}/]
[section#queue.cons.alloc
    [:en] [`queue] constructors with allocators
]

[para]
[:en] If [`uses_allocator<container_type, Alloc>::value] is [`false] the
constructors in this subclause shall not participate in overload resolution.

[codeblock:declaration]
template <class Alloc> explicit queue(const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`a].
[exit:description]

[codeblock:declaration]
template <class Alloc> queue(const container_type& cont, const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`cont] as the first argument and [`a] as the second
argument.
[exit:description]

[codeblock:declaration]
template <class Alloc> queue(container_type&& cont, const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`std::move(cont)] as the first argument and [`a] as
the second argument.
[exit:description]

[codeblock:declaration]
template <class Alloc> queue(const queue& q, const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`q.c] as the first argument and [`a] as the second
argument.
[exit:description]

[codeblock:declaration]
template <class Alloc> queue(queue&& q, const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`std::move(q.c)] as the first argument and [`a] as
the second argument.
[exit:description]

[/     3[queue.ops]{[`queue} operators}/]
[section#queue.ops
    [:en] [`queue] operators
]

[%@library operator==[!queue]]
[codeblock:declaration]
template <class T, class Container>
  bool operator==(const queue<T, Container>& x, const queue<T, Container>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.c == y.c].
[exit:description]

[%@library operator!=[!queue]]
[codeblock:declaration]
template <class T, class Container>
  bool operator!=(const queue<T, Container>& x,  const queue<T, Container>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.c != y.c].
[exit:description]

[%@library operator<[!queue]]
[codeblock:declaration]
template <class T, class Container>
  bool operator< (const queue<T, Container>& x, const queue<T, Container>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.c < y.c].
[exit:description]

[%@library operator<=[!queue]]
[codeblock:declaration]
template <class T, class Container>
  bool operator<=(const queue<T, Container>& x, const queue<T, Container>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.c <= y.c].
[exit:description]

[%@library operator>[!queue]]
[codeblock:declaration]
template <class T, class Container>
  bool operator> (const queue<T, Container>& x, const queue<T, Container>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.c > y.c].
[exit:description]

[%@library operator>=[!queue]]
[codeblock:declaration]
template <class T, class Container>
    bool operator>=(const queue<T, Container>& x,
                    const queue<T, Container>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.c >= y.c].
[exit:description]

[/     3[queue.special]{[`queue} specialized algorithms}/]
[section#queue.special
    [:en] [`queue] specialized algorithms
]

[%@library swap[!queue]]
[%@library queue[!swap]]
[codeblock:declaration]
template <class T, class Container>
  void swap(queue<T, Container>& x, queue<T, Container>& y) noexcept(noexcept(x.swap(y)));
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`x.swap(y)].
[exit:description]

[/     2[priority.queue]{Class template [`priority_queue}}/]
[section#priority.queue
    [:en] Class template [`priority_queue]
]

[para]
[%@library priority_queue]
[:en] Any sequence container with random access iterator and supporting
operations [`front()], [`push_back()] and [`pop_back()] can be used to
instantiate [`priority_queue].

[:en] In particular, [`vector] ([#vector]) and [`deque] ([#deque]) can be used.

[:en] Instantiating [`priority_queue] also involves supplying a function or
function object for making priority comparisons; the library assumes that the
function or function object defines a strict weak ordering ([#alg.sorting]).

[codeblock:synopsis]
namespace std {
  template <class T, class Container = vector<T>,
    class Compare = less<typename Container::value_type> >
  class priority_queue {
  public:
    typedef typename Container::value_type            value_type;
    typedef typename Container::reference             reference;
    typedef typename Container::const_reference       const_reference;
    typedef typename Container::size_type             size_type;
    typedef          Container                        container_type;

  protected:
    Container c;
    Compare comp;

  public:
    priority_queue(const Compare& x, const Container&);
    explicit priority_queue(const Compare& x = Compare(), Container&& = Container());
    template <class InputIterator>
      priority_queue(InputIterator first, InputIterator last,
             const Compare& x, const Container&);
    template <class InputIterator>
      priority_queue(InputIterator first, InputIterator last,
             const Compare& x = Compare(), Container&& = Container());
    template <class Alloc> explicit priority_queue(const Alloc&);
    template <class Alloc> priority_queue(const Compare&, const Alloc&);
    template <class Alloc> priority_queue(const Compare&, const Container&, const Alloc&);
    template <class Alloc> priority_queue(const Compare&, Container&&, const Alloc&);
    template <class Alloc> priority_queue(const priority_queue&, const Alloc&);
    template <class Alloc> priority_queue(priority_queue&&, const Alloc&);

    bool      empty() const       { return c.empty(); }
    size_type size()  const       { return c.size(); }
    const_reference   top() const { return c.front(); }
    void push(const value_type& x);
    void push(value_type&& x);
    template <class... Args> void emplace(Args&&... args);
    void pop();
    void swap(priority_queue& q) noexcept(noexcept(swap(c, q.c)) &&
                                          noexcept(swap(comp, q.comp)))
      { using std::swap; swap(c, q.c); swap(comp, q.comp); }
  };

  // [:en] no equality is provided

  template <class T, class Container, class Compare>
    void swap(priority_queue<T, Container, Compare>& x,
              priority_queue<T, Container, Compare>& y) noexcept(noexcept(x.swap(y)));

  template <class T, class Container, class Compare, class Alloc>
    struct uses_allocator<priority_queue<T, Container, Compare>, Alloc>
      : uses_allocator<Container, Alloc>::type { };
}
[codeblock:end]

[/     3[priqueue.cons]{[`priority_queue} constructors}/]
[section#priqueue.cons
    [:en] [`priority_queue] constructors
]

[%@library priority_queue[!priority_queue]]
[codeblock:declaration]
priority_queue(const Compare& x,
               const Container& y);
explicit priority_queue(const Compare& x = Compare(),
               Container&& y = Container());
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`x] shall define a strict weak ordering ([#alg.sorting]).

[para:effects]
[:en] Initializes [`comp] with [`x] and [`c] with [`y] (copy constructing or
move constructing as appropriate); calls [`make_heap(c.begin(), c.end(), comp)].
[exit:description]

[%@library priority_queue[!priority_queue]]
[codeblock:declaration]
template <class InputIterator>
  priority_queue(InputIterator first, InputIterator last,
                 const Compare& x,
                 const Container& y);
template <class InputIterator>
  priority_queue(InputIterator first, InputIterator last,
                 const Compare& x = Compare(),
                 Container&& y = Container());
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`x] shall define a strict weak ordering ([#alg.sorting]).

[para:effects]
[:en] Initializes [`comp] with [`x] and [`c] with [`y] (copy constructing or
move constructing as appropriate); calls [`c.insert(c.end(), first, last)];
and finally calls [`make_heap(c.begin(), c.end(), comp)].
[exit:description]

[/     3[priqueue.cons.alloc]{[`priority_queue} constructors with allocators}/]
[section#priqueue.cons.alloc
    [:en] [`priority_queue] constructors with allocators
]

[para]
[:en] If [`uses_allocator<container_type, Alloc>::value] is [`false] the
constructors in this subclause shall not participate in overload resolution.

[codeblock:declaration]
template <class Alloc> explicit priority_queue(const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`a] and value-initializes [`comp].
[exit:description]

[codeblock:declaration]
template <class Alloc> priority_queue(const Compare& compare, const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`a] and initializes [`comp] with [`compare].
[exit:description]

[codeblock:declaration]
template <class Alloc>
  priority_queue(const Compare& compare, const Container& cont, const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`cont] as the first argument and [`a] as the second
argument, and initializes [`comp] with [`compare].
[exit:description]

[codeblock:declaration]
template <class Alloc>
  priority_queue(const Compare& compare, Container&& cont, const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`std::move(cont)] as the first argument and [`a]
as the second argument, and initializes [`comp] with [`compare].
[exit:description]

[codeblock:declaration]
template <class Alloc> priority_queue(const priority_queue& q, const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`q.c] as the first argument and [`a] as the second
argument, and initializes [`comp] with [`q.comp].
[exit:description]

[codeblock:declaration]
template <class Alloc> priority_queue(priority_queue&& q, const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`std::move(q.c)] as the first argument and [`a]
as the second argument, and initializes [`comp] with [`std::move(q.comp)].
[exit:description]

[/     3[priqueue.members]{[`priority_queue} members}/]
[section#priqueue.members
    [:en] [`priority_queue] members
]

[%@library push[!priority_queue]]
[codeblock:declaration]
void push(const value_type& x);
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
c.push_back(x);
push_heap(c.begin(), c.end(), comp);
[codeblock:end]
[exit:description]

[%@library push[!priority_queue]]
[codeblock:declaration]
void push(value_type&& x);
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
c.push_back(std::move(x));
push_heap(c.begin(), c.end(), comp);
[codeblock:end]
[exit:description]

[%@library emplace[!priority_queue]]
[%@library priority_queue[!emplace]]
[codeblock:declaration]
template <class... Args> void emplace(Args&&... args)
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
c.emplace_back(std::forward<Args>(args)...);
push_heap(c.begin(), c.end(), comp);
[codeblock:end]
[exit:description]

[%@library pop[!priority_queue]]
[codeblock:declaration]
void pop();
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
pop_heap(c.begin(), c.end(), comp);
c.pop_back();
[codeblock:end]
[exit:description]

[/     3[priqueue.special]{[`priority_queue} specialized algorithms}/]
[section#priqueue.special
    [:en] [`priority_queue] specialized algorithms
]

[%@library swap[!priority_queue]]
[%@library priority_queue[!swap]]
[codeblock:declaration]
template <class T, class Container, class Compare>
  void swap(priority_queue<T, Container, Compare>& x,
            priority_queue<T, Container, Compare>& y) noexcept(noexcept(x.swap(y)));
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`x.swap(y)].
[exit:description]

[/     2[stack]{Class template [`stack}}/]
[section#stack
    [:en] Class template [`stack]
]

[para]
[%@library stack]
[:en] Any sequence container supporting operations [`back()], [`push_back()] and
[`pop_back()] can be used to instantiate [`stack].

[:en] In particular, [`vector] ([#vector]), [`list] ([#list]) and [`deque]
([#deque]) can be used.

[/     3[stack.syn]{Header [`<stack>} synopsis]]/]
[section#stack.syn
    [:en] Header [`<stack>] synopsis
]

[%@library <stack> [sortas stack]]

[codeblock:synopsis]
#include <initializer_list>

namespace std {
  template <class T, class Container = deque<T> > class stack;
  template <class T, class Container>
    bool operator==(const stack<T, Container>& x, const stack<T, Container>& y);
  template <class T, class Container>
    bool operator< (const stack<T, Container>& x, const stack<T, Container>& y);
  template <class T, class Container>
    bool operator!=(const stack<T, Container>& x, const stack<T, Container>& y);
  template <class T, class Container>
    bool operator> (const stack<T, Container>& x, const stack<T, Container>& y);
  template <class T, class Container>
    bool operator>=(const stack<T, Container>& x, const stack<T, Container>& y);
  template <class T, class Container>
    bool operator<=(const stack<T, Container>& x, const stack<T, Container>& y);
  template <class T, class Container>
    void swap(stack<T, Container>& x, stack<T, Container>& y) noexcept(noexcept(x.swap(y)));
}
[codeblock:end]

[/     3[stack.defn]{[`stack} definition}/]
[section#stack.defn
    [:en] [`stack] definition
]

[codeblock:synopsis]
namespace std {
  template <class T, class Container = deque<T> >
  class stack {
  public:
    typedef typename Container::value_type            value_type;
    typedef typename Container::reference             reference;
    typedef typename Container::const_reference       const_reference;
    typedef typename Container::size_type             size_type;
    typedef          Container                        container_type;

  protected:
    Container c;

  public:
    explicit stack(const Container&);
    explicit stack(Container&& = Container());
    template <class Alloc> explicit stack(const Alloc&);
    template <class Alloc> stack(const Container&, const Alloc&);
    template <class Alloc> stack(Container&&, const Alloc&);
    template <class Alloc> stack(const stack&, const Alloc&);
    template <class Alloc> stack(stack&&, const Alloc&);

    bool      empty() const             { return c.empty(); }
    size_type size()  const             { return c.size(); }
    reference         top()             { return c.back(); }
    const_reference   top() const       { return c.back(); }
    void push(const value_type& x)      { c.push_back(x); }
    void push(value_type&& x)           { c.push_back(std::move(x)); }
    template <class... Args>
      void emplace(Args&&... args)      { c.emplace_back(std::forward<Args>(args)...); }
    void pop()                          { c.pop_back(); }
    void swap(stack& s) noexcept(noexcept(swap(c, s.c)))
      { using std::swap; swap(c, s.c); }
  };

  template <class T, class Container>
    bool operator==(const stack<T, Container>& x, const stack<T, Container>& y);
  template <class T, class Container>
    bool operator< (const stack<T, Container>& x, const stack<T, Container>& y);
  template <class T, class Container>
    bool operator!=(const stack<T, Container>& x, const stack<T, Container>& y);
  template <class T, class Container>
    bool operator> (const stack<T, Container>& x, const stack<T, Container>& y);
  template <class T, class Container>
    bool operator>=(const stack<T, Container>& x, const stack<T, Container>& y);
  template <class T, class Container>
    bool operator<=(const stack<T, Container>& x, const stack<T, Container>& y);
  template <class T, class Container>
    void swap(stack<T, Container>& x, stack<T, Container>& y) noexcept(noexcept(x.swap(y)));

  template <class T, class Container, class Alloc>
    struct uses_allocator<stack<T, Container>, Alloc>
      : uses_allocator<Container, Alloc>::type { };
}
[codeblock:end]

[/     3[stack.cons]{[`stack} constructors}/]
[section#stack.cons
    [:en] [`stack] constructors
]

[codeblock:declaration]
explicit stack(const Container& cont);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`cont].
[exit:description]

[codeblock:declaration]
explicit stack(Container&& cont = Container());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`std::move(cont)].
[exit:description]

[/     3[stack.cons.alloc]{[`stack} constructors with allocators}/]
[section#stack.cons.alloc
    [:en] [`stack] constructors with allocators
]

[para]
[:en] If [`uses_allocator<container_type, Alloc>::value] is [`false] the
constructors in this subclause shall not participate in overload resolution.

[codeblock:declaration]
template <class Alloc> explicit stack(const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`a].
[exit:description]

[codeblock:declaration]
template <class Alloc> stack(const container_type& cont, const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`cont] as the first argument and [`a] as the
second argument.
[exit:description]

[codeblock:declaration]
template <class Alloc> stack(container_type&& cont, const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`std::move(cont)] as the first argument and [`a]
as the second argument.
[exit:description]

[codeblock:declaration]
template <class Alloc> stack(const stack& s, const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`s.c] as the first argument and [`a] as the second
argument.
[exit:description]

[codeblock:declaration]
template <class Alloc> stack(stack&& s, const Alloc& a);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`c] with [`std::move(s.c)] as the first argument and [`a]
as the second argument.
[exit:description]

[/     3[stack.ops]{[`stack} operators}/]
[section#stack.ops
    [:en] [`stack] operators
]

[%@library operator==[!stack]]
[codeblock:declaration]
template <class T, class Container>
  bool operator==(const stack<T, Container>& x, const stack<T, Container>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.c == y.c].
[exit:description]

[%@library operator!=[!stack]]
[codeblock:declaration]
template <class T, class Container>
  bool operator!=(const stack<T, Container>& x, const stack<T, Container>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.c != y.c].
[exit:description]

[%@library operator<[!stack]]
[codeblock:declaration]
template <class T, class Container>
  bool operator< (const stack<T, Container>& x, const stack<T, Container>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.c < y.c].
[exit:description]

[%@library operator<=[!stack]]
[codeblock:declaration]
template <class T, class Container>
  bool operator<=(const stack<T, Container>& x, const stack<T, Container>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.c <= y.c].
[exit:description]

[%@library operator>[!stack]]
[codeblock:declaration]
template <class T, class Container>
  bool operator> (const stack<T, Container>& x, const stack<T, Container>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.c > y.c].
[exit:description]

[%@library operator>=[!stack]]
[codeblock:declaration]
template <class T, class Container>
    bool operator>=(const stack<T, Container>& x, const stack<T, Container>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.c >= y.c].
[exit:description]

[/     3[stack.special]{[`stack} specialized algorithms}/]
[section#stack.special
    [:en] [`stack] specialized algorithms
]

[%@library swap[!stack]]
[%@library stack[!swap]]
[codeblock:declaration]
template <class T, class Container>
  void swap(stack<T, Container>& x, stack<T, Container>& y) noexcept(noexcept(x.swap(y)));
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`x.swap(y)].
[exit:description]
