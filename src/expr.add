[section#expr.add
    [:en] Additive operators
    [:zh_CN]
]

[:en]
[%expression[!additive operators]]
[%operator[!additive]]

[para]
[:en]
The additive operators [`+] and [`-] group left-to-right.

[:en]
The usual arithmetic conversions are performed for operands of arithmetic or
enumeration type.

[:en]
[%addition operator]
[%[`+][see addition operator]]
[%subtraction operator]
[%[`-][see subtraction operator]]

[syntax]
[rule additive-expression [:zh_CN] ]
    [| multiplicative-expression ]
    [| additive-expression [`+] multiplicative-expression ]
    [| additive-expression [`-] multiplicative-expression ]
[rule:end]
[syntax:end]

[:en]
[%incomplete]
For addition, either both operands shall have arithmetic or unscoped enumeration
type, or one operand shall be a pointer to a completely-defined object type and
the other shall have integral or unscoped enumeration type.

[para]
[:en]
For subtraction, one of the following shall hold:

[list]
[item]
[:en]
both operands have arithmetic or unscoped enumeration type; or

[item]
[:en]
[%arithmetic[!pointer]]
both operands are pointers to cv-qualified or cv-unqualified versions of the
same completely-defined object type; or

[item]
[:en]
the left operand is a pointer to a completely-defined object type and the right
operand has integral or unscoped enumeration type.
[list:end]

[para]
[:en]
The result of the binary [`+] operator is the sum of the operands.

[:en]
The result of the binary [`-] operator is the difference resulting from the
subtraction of the second operand from the first.

[para]
[:en]
[%arithmetic[!pointer]]
When an expression that has integral type is added to or subtracted from a
pointer, the result has the type of the pointer operand.

[:en]
If the pointer operand points to an element of an array object

[footnote]
[:en]
An object that is not an array element is considered to belong to a
single-element array for this purpose; see [#expr.unary.op].
[footnote:end]

[:en@~]
, and the array is large enough, the result points to an element offset from the
original element such that the difference of the subscripts of the resulting and
original array elements equals the integral expression.

[:en]
In other words, if the expression [`P] points to the $i$-th element of an array
object, the expressions [`(P)+N] (equivalently, [`N+(P)]) and [`(P)-N] (where
[`N] has the value [$n]) point to, respectively, the [$i+n]-th and [$i-n]-th
elements of the array object, provided they exist.

[:en]
Moreover, if the expression [`P] points to the last element of an array object,
the expression [`(P)+1] points one past the last element of the array object,
and if the expression [`Q] points one past the last element of an array object,
the expression [`(Q)-1] points to the last element of the array object.

[:en]
If both the pointer operand and the result point to elements of the same array
object, or one past the last element of the array object, the evaluation shall
not produce an overflow; otherwise, the behavior is undefined.

[para]
[:en]
[%[`ptrdiff_t][!implementation defined type of]]
[%subtraction[!implementation defined pointer]]
[%[`ptrdiff_t]]
[%[`<cstddef>][sortas cstddef]]
[%comparison[!undefined pointer]]
When two pointers to elements of the same array object are subtracted, the
result is the difference of the subscripts of the two array elements.

[:en]
The type of the result is an [%@impldef type of [`ptrdiff_t]] signed integral
type; this type shall be the same type that is defined as [`std::ptrdiff_t] in
the [`<cstddef>] header ([#support.types]).

[:en]
As with any other arithmetic overflow, if the result does not fit in the space
provided, the behavior is undefined.

[:en]
In other words, if the expressions [`P] and [`Q] point to, respectively, the
[$i]-th and [$j]-th elements of an array object, the expression [`(P)-(Q)] has
the value [$i-j] provided the value fits in an object of type [`std::ptrdiff_t].

[:en]
Moreover, if the expression [`P] points either to an element of an array object
or one past the last element of an array object, and the expression [`Q] points
to the last element of the same array object, the expression [`((Q)+1)-(P)] has
the same value as [`((Q)-(P))+1] and as [`-((P)-((Q)+1))], and has the value
zero if the expression [`P] points one past the last element of the array
object, even though the expression [`(Q)+1] does not point to an element of the
array object.

[:en]
Unless both pointers point to elements of the same array object, or one past the
last element of the array object, the behavior is undefined.

[footnote]
[:en]
Another way to approach pointer arithmetic is first to convert the pointer(s) to
character pointer(s): In this scheme the integral value of the expression added
to or subtracted from the converted pointer is first multiplied by the size of
the object originally pointed to, and the resulting pointer is converted back to
the original type.

[:en]
For pointer subtraction, the result of the difference between the character
pointers is similarly divided by the size of the object originally pointed to.

[:en]
When viewed in this way, an implementation need only provide one extra byte
(which might overlap another object in the program) just after the end of the
object in order to satisfy the ["one past the last element] requirements.
[footnote:end]

[para]
[:en]
For addition or subtraction, if the expressions [`P] or [`Q] have type ["pointer
to [$cv] [`T]], where [`T] and the array element type are not similar
([#conv.qual]), the behavior is undefined.

[enter:note]
[:en]
In particular, a pointer to a base class cannot be used for pointer arithmetic
when the array contains objects of a derived class type.
[exit:note]

[para]
[:en]
If the value 0 is added to or subtracted from a pointer value, the result
compares equal to the original pointer value.

[:en]
If two pointers point to the same object or both point one past the end of the
same array or both are null, and the two pointers are subtracted, the result
compares equal to the value 0 converted to the type [`std::ptrdiff_t].
