[section#expr.const.cast
    [:en] Const cast
    [:zh_CN]
]

[para]
[:en]
[%expression[!const cast]]
[%cast[!const]]
The result of the expression [`const_cast<T>(v)] is of type [`T].

[:en]
If [`T] is an lvalue reference to object type, the result is an lvalue; if [`T]
is an rvalue reference to object type, the result is an xvalue; otherwise, the
result is a prvalue and the lvalue-to-rvalue ([#conv.lval]), array-to-pointer
([#conv.array]), and function-to-pointer ([#conv.func]) standard conversions are
performed on the expression [`v].

[:en]
Conversions that can be performed explicitly using [`const_cast] are listed
below.

[:en]
No other conversion shall be performed explicitly using [`const_cast].

[para]
[enter:note]
[:en]
Subject to the restrictions in this section, an expression may be cast to its
own type using a [`const_cast] operator.
[exit:note]

[para]
[:en]
For two similar types [`T1] and [`T2] ([#conv.qual]), a prvalue of type [`T1]
may be explicitly converted to the type [`T2] using a [`const_cast].

[:en]
The result of a [`const_cast] refers to the original entity.

[enter:example]
[codeblock]
typedef int *A[3];               // [:en] array of 3 pointer to [`int]
typedef const int *const CA[3];  // [:en] array of 3 const pointer to [`const int]

CA &&r = A{}; // [:en] OK, reference binds to temporary array object after qualification conversion to type [`CA]
A &&r1 = const_cast<A>(CA{});   // [:en] error: temporary array decayed to pointer
A &&r2 = const_cast<A&&>(CA{}); // OK
[codeblock:end]
[exit:example]

[para]
[:en]
For two object types [`T1] and [`T2], if a pointer to [`T1] can be explicitly
converted to the type ["pointer to [`T2]] using a [`const_cast], then the
following conversions can also be made:

[list]
[item]
[:en]
an lvalue of type [`T1] can be explicitly converted to an lvalue of type [`T2]
using the cast [`const_cast<T2&>];

[item]
[:en]
a glvalue of type [`T1] can be explicitly converted to an xvalue of type [`T2]
using the cast [`const_cast<T2&&>]; and

[item]
[:en]
if [`T1] is a class type, a prvalue of type [`T1] can be explicitly converted to
an xvalue of type [`T2] using the cast [`const_cast<T2&&>].
[list:end]

[:en]
The result of a reference [`const_cast] refers to the original object.

[para]
[:en]
A null pointer value ([#conv.ptr]) is converted to the null pointer value of the
destination type.

[:en]
The null member pointer value ([#conv.mem]) is converted to the null member
pointer value of the destination type.

[para]
[enter:note]
[:en]
Depending on the type of the object, a write operation through the pointer,
lvalue or pointer to data member resulting from a [`const_cast] that casts away
a const-qualifier

[footnote]
[:en]
[`const_cast] is not limited to conversions that cast away a const-qualifier.
[footnote:end]

[:en@~]
may produce undefined behavior ([#dcl.type.cv]).
[exit:note]

[para]
[:en]
[%[`const][!cast away]]
A conversion from a type [`T1] to a type [`T2] [def casts away constness
[%casting away constness]] if [`T1] and [`T2] are different, there is a
cv-decomposition ([#conv.qual]) of [`T1] yielding [$n] such that [`T2] has a
cv-decomposition of the form

[syntax:explanation]
[$cv[_0][^2]] [$P[_0][^2]] [$cv[_1][^2]] [$P[_1][^2]] [=cdots] [$cv[_n-1][^2]] [$P[_n-1][^2]] [$cv[_n][^2]] [`U][_2],
[syntax:end]

[:en@~]
and there is no qualification conversion that converts [`T1] to

[syntax:explanation]
[$cv[_0][^2]] [$P[_0][^1]] [$cv[_1][^2]] [$P[_1][^1]] [=cdots] [$cv[_n-1][^2]] [$P[_n-1][^1]] [$cv[_n][^2]] [`U][_1].
[syntax:end]

[para]
[:en]
Casting from an lvalue of type [`T1] to an lvalue of type [`T2] using an lvalue
reference cast or casting from an expression of type [`T1] to an xvalue of type
[`T2] using an rvalue reference cast casts away constness if a cast from a
prvalue of type ["pointer to [`T1]] to the type ["pointer to [`T2]] casts away
constness.

[para]
[enter:note]
[:en]
some conversions which involve only changes in cv-qualification cannot be done
using [`const_cast].

[:en]
For instance, conversions between pointers to functions are not covered because
such conversions lead to values whose use causes undefined behavior.

[:en]
For the same reasons, conversions between pointers to member functions, and in
particular, the conversion from a pointer to a const member function to a
pointer to a non-const member function, are not covered.
[exit:note]
