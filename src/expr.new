[section#expr.new
    [:en] New
    [:zh_CN]
]

[para]
[:en]
[%expression[![`new]]]
[%free store[seealso [`new]][seealso [`delete]]]
[%memory management[seealso [`new]][seealso [`delete]]]
[%storage management[see [`new]][see [`delete]]]
[%[`new]]
The [~new-expression] attempts to create an object of the [~type-id]
([#dcl.name]) or [~new-type-id] to which it is applied.

[:en]
The type of that object is the [+allocated type].

[:en]
[%type[!incomplete]]
This type shall be a complete object type, but not an abstract class type or
array thereof ([#intro.object], [#basic.types], [#class.abstract]).

[:en]
It is [%@impldef support for over-aligned types] implementation-defined whether
over-aligned types are supported ([#basic.align]).

[enter:note]
[:en]
because references are not objects, references cannot be created by
[~new-expression]s.
[exit:note]

[enter:note]
[:en]
the [~type-id] may be a cv-qualified type, in which case the object created by
the [~new-expression] has a cv-qualified type.
[exit:note]

[syntax]
[rule new-expression [:zh_CN] ]
    [| [`:opt ::] [`new] [~:opt new-placement] new-type-id [~:opt new-initializer] ]
    [| [`:opt ::] [`new] [~:opt new-placement] [`(] type-id [`)] [~:opt new-initializer] ]
[rule:end]

[%
    [:en] [`new] [! storage allocation]
]

[rule new-placement [:zh_CN] ]
    [| [`(] expression-list [`)] ]
[rule:end]

[rule new-type-id [:zh_CN] ]
    [| type-specifier-seq [~:opt new-declarator] ]
[rule:end]

[rule new-declarator [:zh_CN] ]
    [| ptr-operator [~:opt new-declarator] ]
    [| noptr-new-declarator ]
[rule:end]

[rule noptr-new-declarator [:zh_CN] ]
    [| [`[] expression [``]] [~:opt attribute-specifier-seq] ]
    [| noptr-new-declarator [`[] constant-expression [``]] [~:opt attribute-specifier-seq] ]
[rule:end]

[rule new-initializer [:zh_CN] ]
    [| [`(] [~:opt expression-list] [`)] ]
    [| braced-init-list ]
[rule:end]
[syntax:end]

[:en]
[%storage duration[!dynamic]]
Entities created by a [~new-expression] have dynamic storage duration
([#basic.stc.dynamic]).

[enter:note]
[:en]
[%[`new][!scoping and]]
the lifetime of such an entity is not necessarily restricted to the scope in
which it is created.
[exit:note]

[:en]
If the entity is a non-array object, the [~new-expression] returns a pointer to
the object created.

[:en]
If it is an array, the [~new-expression] returns a pointer to the initial
element of the array.

[para]
[:en]
If a placeholder type ([#dcl.spec.auto]) appears in the [~type-specifier-seq] of
a [~new-type-id] or [~type-id] of a [~new-expression], the [~new-expression]
shall contain a [~new-initializer] of the form

[syntax:explanation]
[`(] [~assignment-expression] [`)]
[syntax:end]

[:en]
The allocated type is deduced from the [~new-initializer] as follows: Let [`e]
be the [~assignment-expression] in the [~new-initializer] and [`T] be the
[~new-type-id] or [~type-id] of the [~new-expression], then the allocated type
is the type deduced for the variable [`x] in the invented declaration
([#dcl.spec.auto]):

[codeblock:notation]
T x(e);
[codeblock:end]

[enter:example]
[codeblock]
new auto(1);                    // [:en] allocated type is [`int]
auto x = new auto('a');         // [:en] allocated type is [`char], [`x] is of type [`char*]
[codeblock:end]
[exit:example]

[para]
[:en]
The [~new-type-id] in a [~new-expression] is the longest possible sequence of
[~new-declarator]s.

[enter:note]
[:en]
this prevents ambiguities between the declarator operators [`&], [`&&], [`*],
and [`[`]] and their expression counterparts.
[exit:note]

[enter:example]
[codeblock]
new int * i;                    // [:en] syntax error: parsed as [`(new int*) i], not as [`(new int)*i]
[codeblock:end]

[:en]
The [`*] is the pointer declarator and not the multiplication operator.
[exit:example]

[para]
[enter:note]
[:en]
[%ambiguity[!parentheses and]]
parentheses in a [~new-type-id] of a [~new-expression] can have surprising
effects.
[enter:example]

[codeblock]
new int(*[10])();               // [:en] error
[codeblock:end]

[:en]
is ill-formed because the binding is

[codeblock]
(new int) (*[10])();            // [:en] error
[codeblock:end]

[:en]
Instead, the explicitly parenthesized version of the [`new] operator can be used
to create objects of compound types ([#basic.compound]):

[codeblock]
new (int (*[10])());
[codeblock:end]

[:en]
allocates an array of [`10] pointers to functions (taking no argument and
returning [`int].
[exit:example]
[exit:note]

[para]
[:en]
[%array[![`new]]]
When the allocated object is an array (that is, the [~noptr-new-declarator]
syntax is used or the [~new-type-id] or [~type-id] denotes an array type), the
[~new-expression] yields a pointer to the initial element (if any) of the array.

[enter:note]
[:en]
both [`new int] and [`new int[10`]] have type [`int*] and the type of [`new
int[i`][10`]] is [`int (*)[10`]]
[exit:note]

[:en]
The [~attribute-specifier-seq] in a [~noptr-new-declarator] appertains to the
associated array type.

[para]
[:en]
Every [~constant-expression] in a [~noptr-new-declarator] shall be a converted
constant expression ([#expr.const]) of type [`std::size_t] and shall evaluate to
a strictly positive value.

[:en]
[%[`new]]
The [~expression] in a [~noptr-new-declarator]is implicitly converted to
[`std::size_t].

[enter:example]
[:en]
given the definition [`int n = 42], [`new float[n`][5`]] is well-formed (because
[`n] is the [~expression] of a [~noptr-new-declarator]), but [`new
float[5`][n`]] is ill-formed (because [`n] is not a constant expression).
[exit:example]

[para]
[:en]
[%function[!allocation]]
The [~expression] in a [~noptr-new-declarator] is erroneous if:

[list]
[item]
[:en]
the expression is of non-class type and its value before converting to
[`std::size_t] is less than zero;

[item]
[:en]
the expression is of class type and its value before application of the second
standard conversion ([#over.ics.user])

[footnote]
[:en]
If the conversion function returns a signed integer type, the second standard
conversion converts to the unsigned type [`std::size_t] and thus thwarts any
attempt to detect a negative value afterwards.
[footnote:end]

[:en@~]
is less than zero;

[item]
[:en]
its value is such that the size of the allocated object would exceed the
implementation-defined limit (annex [#implimits]); or

[item]
[:en]
the [~new-initializer] is a [~braced-init-list] and the number of array elements
for which initializers are provided (including the terminating [`'\0'] in a
string literal ([#lex.string])) exceeds the number of elements to initialize.
[list:end]

[:en]
If the [~expression], after converting to [`std::size_t], is a core constant
expression and the expression is erroneous, the program is ill-formed.

[:en]
Otherwise, a [~new-expression] with an erroneous expression does not call an
allocation function and terminates by throwing an exception of a type that would
match a handler ([#except.handle]) of type [`std::bad_array_new_length]
([#new.badlength]).

[:en]
When the value of the [~expression] is zero, the allocation function is called
to allocate an array with no elements.

[para]
[:en]
A [~new-expression] may obtain storage for the object by calling an [+allocation
function] ([#basic.stc.dynamic.allocation]).

[:en]
If the [~new-expression] terminates by throwing an exception, it may release
storage by calling a deallocation function ([#basic.stc.dynamic.deallocation]).

[:en]
If the allocated type is a non-array type, the allocation function[=']s name is
[%[`operator new]]
[%[`operator delete]]
[`operator new] and the deallocation function[=']s name is [`operator delete].

[:en]
If the allocated type is an array type, the allocation function[=']s name is
[%[`operator new]]
[%[`operator delete]]
[`operator new[`]]
and the deallocation function[=']s name is [`operator delete[`]].

[enter:note]
[:en]
an implementation shall provide default definitions for the global allocation
functions ([#basic.stc.dynamic], [#new.delete.single], [#new.delete.array]).

[:en]
A [=Cpp] program can provide alternative definitions of these functions
([#replacement.functions]) and/or class-specific versions ([#class.free]).
[exit:note]

[para]
[:en]
[%operator[!scope resolution]]
If the [~new-expression] begins with a unary [`::] operator, the allocation
function[=']s name is looked up in the global scope.

[:en]
Otherwise, if the allocated type is a class type [`T] or array thereof, the
allocation function[=']s name is looked up in the scope of [`T].

[:en]
If this lookup fails to find the name, or if the allocated type is not a class
type, the allocation function[=']s name is looked up in the global scope.

[para]
[:en]
An implementation is allowed to omit a call to a replaceable global allocation
function ([#new.delete.single], [#new.delete.array]).

[:en]
When it does so, the storage is instead provided by the implementation or
provided by extending the allocation of another [~new-expression].

[:en]
The implementation may extend the allocation of a [~new-expression] [`e1] to
provide storage for a [~new-expression] [`e2] if the following would be true
were the allocation not extended:

[list]
[item]
[:en]
the evaluation of [`e1] is sequenced before the evaluation of [`e2], and

[item]
[:en]
[`e2] is evaluated whenever [`e1] obtains storage, and

[item]
[:en]
both [`e1] and [`e2] invoke the same replaceable global allocation function, and

[item]
[:en]
if the allocation function invoked by [`e1] and [`e2] is throwing, any
exceptions thrown in the evaluation of either [`e1] or [`e2] would be first
caught in the same handler, and

[item]
[:en]
the pointer values produced by [`e1] and [`e2] are operands to evaluated
[~delete-expression]s, and

[item]
[:en]
the evaluation of [`e2] is sequenced before the evaluation of the
[~delete-expression] whose operand is the pointer value produced by [`e1].
[list:end]

[enter:example]
[codeblock]
  void mergeable(int x) {
    // [:en] These allocations are safe for merging:
    std::unique_ptr<char[]> a{new (std::nothrow) char[8]};
    std::unique_ptr<char[]> b{new (std::nothrow) char[8]};
    std::unique_ptr<char[]> c{new (std::nothrow) char[x]};

    g(a.get(), b.get(), c.get());
  }

  void unmergeable(int x) {
    std::unique_ptr<char[]> a{new char[8]};
    try {
      // [:en] Merging this allocation would change its catch handler.
      std::unique_ptr<char[]> b{new char[x]};
    } catch (const std::bad_alloc& e) {
      std::cerr << "Allocation failed: " << e.what() << std::endl;
      throw;
    }
  }
[codeblock:end]
[exit:example]

[para]
[:en]
When a [~new-expression] calls an allocation function and that allocation has
not been extended, the [~new-expression] passes the amount of space requested to
the allocation function as the first argument of type [`std::size_t].

[:en]
That argument shall be no less than the size of the object being created; it may
be greater than the size of the object being created only if the object is an
array.

[:en]
For arrays of [`char] and [`unsigned char], the difference between the result of
the [~new-expression] and the address returned by the allocation function shall
be an integral multiple of the strictest fundamental alignment requirement
([#basic.align]) of any object type whose size is no greater than the size of
the array being created.

[enter:note]
[:en]
[%allocation[!alignment storage]]
Because allocation functions are assumed to return pointers to storage that is
appropriately aligned for objects of any type with fundamental alignment, this
constraint on array allocation overhead permits the common idiom of allocating
character arrays into which objects of other types will later be placed.
[exit:note]

[para]
[:en]
When a [~new-expression] calls an allocation function and that allocation has
been extended, the size argument to the allocation call shall be no greater than
the sum of the sizes for the omitted calls as specified above, plus the size for
the extended call had it not been extended, plus any padding necessary to align
the allocated objects within the allocated memory.

[para]
[:en]
[%placement syntax[![`new]]]
The [~new-placement] syntax is used to supply additional arguments to an
allocation function.

[:en]
If used, overload resolution is performed on a function call created by
assembling an argument list consisting of the amount of space requested (the
first argument) and the expressions in the [~new-placement] part of the
[~new-expression] (the second and succeeding arguments).

[:en]
The first of these arguments has type [`std::size_t] and the remaining arguments
have the corresponding types of the expressions in the [~new-placement]; such an
expression is called a [def placement [~new-expression]].

[para]
[enter:example]

[list]
[item]
[:en@~]
[`new T] results in a call of [`operator new(sizeof(T))],

[item]
[:en@~]
[`new(2,f) T] results in a call of [`operator new(sizeof(T),2,f)],

[item]
[:en@~]
[`new T[5]] results in a call of [`operator new[`](sizeof(T)*5+x)], and

[item]
[:en@~]
[`new(2,f) T[5]] results in a call of [`operator new[`](sizeof(T)*5+y,2,f)].
[list:end]

[:en]
Here, [`x] and [`y] are non-negative unspecified values representing array
allocation overhead; the result of the [~new-expression] will be offset by this
amount from the value returned by [`operator new[`]].

[:en]
This overhead may be applied in all array [~new-expression]s, including those
referencing the library function [`operator new[`](std::size_t, void*)] and
other placement allocation functions.

[:en]
The amount of overhead may vary from one invocation of [`new] to another.
[exit:example]

[para]
[enter:note]
[:en]
unless an allocation function has a non-throwing exception specification
([#except.spec]), it indicates failure to allocate storage by throwing a
[%[`bad_alloc]]
[%@library bad_alloc]
[`std::bad_alloc] exception ([#basic.stc.dynamic.allocation], Clause [#except],
[#bad.alloc]); it returns a non-null pointer otherwise.

[:en]
If the allocation function has a non-throwing exception specification, it
returns null to indicate failure to allocate storage and a non-null pointer
otherwise.

[exit:note]
[:en]
If the allocation function is a reserved placement allocation function
([#new.delete.placement]) that returns null, the behavior is undefined.

[:en]
Otherwise, if the allocation function returns null, initialization shall not be
done, the deallocation function shall not be called, and the value of the
[~new-expression] shall be null.

[para]
[enter:note]
[:en]
when the allocation function returns a value other than null, it must be a
pointer to a block of storage in which space for the object has been reserved.

[:en]
The block of storage is assumed to be appropriately aligned and of the requested
size.

[:en]
The address of the created object will not necessarily be the same as that of
the block if the object is an array.
[exit:note]

[para]
[:en]
[%[`new][!array of class objects and]]
[%[`new][!initialization and]]
[%[`new][!constructor and]]
[%[`new][!default constructor and]]
[%constructor[!default][see default constructor]]
[%trivial type]
[%trivial class type]
A [~new-expression] that creates an object of type [`T] initializes that object
as follows:

[list]
[item]
[:en]
If the [~new-initializer] is omitted, the object is default-initialized
([#dcl.init]).

[enter:note]
[:en]
If no initialization is performed, the object has an indeterminate value.
[exit:note]

[item]
[:en]
Otherwise, the [~new-initializer] is interpreted according to the initialization
rules of [#dcl.init] for direct-initialization.
[list:end]

[para]
[:en]
[%[`new][!unspecified order of evaluation]]
[%[`new][!unspecified constructor and]]
The invocation of the allocation function is indeterminately sequenced with
respect to the evaluations of expressions in the [~new-initializer].

[:en]
Initialization of the allocated object is sequenced before the
[%value computation]
value computation of the [~new-expression].

[:en]
[%constructor[!unspecified argument to]]
It is unspecified whether expressions in the [~new-initializer] are evaluated if
the allocation function returns the null pointer or exits using an exception.

[para]
[:en]
If the [~new-expression] creates an object or an array of objects of class type,
access and ambiguity control are done for the allocation function, the
deallocation function ([#class.free]), and the constructor ([#class.ctor]).

[:en]
If the [~new-expression] creates an array of objects of class type, the
destructor is potentially invoked ([#class.dtor]).

[para]
[:en]
[%[`new][!exception and]]
If any part of the object initialization described above

[footnote]
[:en]
This may include evaluating a [~new-initializer] and/or calling a constructor.
[footnote:end]

[:en@~]
terminates by throwing an exception, storage has been obtained for the object,
and a suitable deallocation function can be found, the deallocation function is
called to free the memory in which the object was being constructed, after which
the exception continues to propagate in the context of the [~new-expression].

[:en]
If no unambiguous matching deallocation function can be found, propagating the
exception does not cause the object[=']s memory to be freed.

[enter:note]
[:en]
This is appropriate when the called allocation function does not allocate
memory; otherwise, it is likely to result in a memory leak.
[exit:note]

[para]
[:en]
If the [~new-expression] begins with a unary [`::] operator, the deallocation
function[=']s name is looked up in the global scope.

[:en]
Otherwise, if the allocated type is a class type [`T] or an array thereof, the
deallocation function[=']s name is looked up in the scope of [`T].

[:en]
If this lookup fails to find the name, or if the allocated type is not a class
type or array thereof, the deallocation function[=']s name is looked up in the
global scope.

[para]
[:en]
A declaration of a placement deallocation function matches the declaration of a
placement allocation function if it has the same number of parameters and, after
parameter transformations ([#dcl.fct]), all parameter types except the first are
identical.

[:en]
If the lookup finds a single matching deallocation function, that function will
be called; otherwise, no deallocation function will be called.

[:en]
If the lookup finds the two-parameter form of a usual deallocation function
([#basic.stc.dynamic.deallocation]) and that function, considered as a placement
deallocation function, would have been selected as a match for the allocation
function, the program is ill-formed.

[:en]
For a non-placement allocation function, the normal deallocation function lookup
is used to find the matching deallocation function ([#expr.delete])

[enter:example]
[codeblock]
struct S {
  // [:en] Placement allocation function:
  static void* operator new(std::size_t, std::size_t);

  // [:en] Usual (non-placement) deallocation function:
  static void operator delete(void*, std::size_t);
};

S* p = new (0) S;   // [:en] ill-formed: non-placement deallocation function matches
                    // [:en@~] placement allocation function
[codeblock:end]
[exit:example]

[para]
[:en]
If a [~new-expression] calls a deallocation function, it passes the value
returned from the allocation function call as the first argument of type
[`void*].

[:en]
If a placement deallocation function is called, it is passed the same additional
arguments as were passed to the placement allocation function, that is, the same
arguments as those specified with the [~new-placement] syntax.

[:en]
If the implementation is allowed to make a copy of any argument as part of the
call to the allocation function, it is allowed to make a copy (of the same
original value) as part of the call to the deallocation function or to reuse the
copy made as part of the call to the allocation function.

[:en]
If the copy is elided in one place, it need not be elided in the other.
