[section#expr.static.cast
    [:en] Static cast
    [:zh_CN]
]

[para]
[:en]
[%expression[!static cast]]
[%cast[!static]]
The result of the expression [`static_cast<T>(v)] is the result of converting
the expression [`v] to type [`T].

[:en]
[%cast[!static[!lvalue]]]
[%cast[!lvalue]]
If [`T] is an lvalue reference type or an rvalue reference to function type, the
result is an lvalue; if [`T] is an rvalue reference to object type, the result
is an xvalue; otherwise, the result is a prvalue.

[:en]
The [`static_cast] operator shall not cast away constness ([#expr.const.cast]).

[para]
[:en]
[%cast[!static[!reference]]]
[%cast[!reference]]
An lvalue of type ["[$cv1] [`B],] where [`B] is a class type, can be cast to
type ["reference to [$cv2] [`D],] where [`D] is a class derived (Clause
[#class.derived]) from [`B], if a valid standard conversion from ["pointer to
[`D]] to ["pointer to [`B]] exists ([#conv.ptr]), [$cv2] is the same
cv-qualification as, or greater cv-qualification than, [$cv1], and [`B] is
neither a virtual base class of [`D] nor a base class of a virtual base class of
[`D].

[:en]
The result has type ["[$cv2] [`D].]

[:en]
An xvalue of type ["[$cv1] [`B]] may be cast to type ["rvalue reference to
[$cv2] [`D]] with the same constraints as for an lvalue of type ["[$cv1] [`B].]

[:en]
If the object of type ["[$cv1] [`B]] is actually a subobject of an object of
type [`D], the result refers to the enclosing object of type [`D].

[:en]
Otherwise, the behavior is undefined.

[enter:example]
[codeblock]
struct B { };
struct D : public B { };
D d;
B &br = d;

static_cast<D&>(br);            // [:en] produces lvalue to the original [`d] object
[codeblock:end]
[exit:example]

[para]
[:en]
A glvalue, class prvalue, or array prvalue of type ["[$cv1] [`T1]] can be cast
to type ["rvalue reference to [$cv2] [`T2]] if ["[$cv2] [`T2]] is
reference-compatible with ["[$cv1] [`T1]] ([#dcl.init.ref]).

[:en]
If the value is not a bit-field, the result refers to the object or the
specified base class subobject thereof; otherwise, the lvalue-to-rvalue
conversion ([#conv.lval]) is applied to the bit-field and the resulting prvalue
is used as the [~expression] of the [`static_cast] for the remainder of this
section.

[:en]
If [`T2] is an inaccessible (Clause [#class.access]) or ambiguous
([#class.member.lookup]) base class of [`T1], a program that necessitates such a
cast is ill-formed.

[para]
[:en]
An expression [`e] can be explicitly converted to a type [`T] using a
[`static_cast] of the form [`static_cast<T>(e)] if the declaration [`T t(e);]
is well-formed, for some invented temporary variable [`t] ([#dcl.init]).

[:en]
The effect of such an explicit conversion is the same as performing the
declaration and initialization and then using the temporary variable as the
result of the conversion.

[:en]
The expression [`e] is used as a glvalue if and only if the initialization uses
it as a glvalue.

[para]
[:en]
Otherwise, the [`static_cast] shall perform one of the conversions listed below.

[:en]
No other conversion shall be performed explicitly using a [`static_cast].

[para]
[:en]
Any expression can be explicitly converted to type [$cv] [`void], in which case
it becomes a discarded-value expression (Clause [#expr]).

[enter:note]
[:en]
however, if the value is in a temporary object ([#class.temporary]), the
destructor for that object is not executed until the usual time, and the value
of the object is preserved for the purpose of executing the destructor.
[exit:note]

[para]
[:en]
The inverse of any standard conversion sequence (Clause [#conv]) not containing
an lvalue-to-rvalue ([#conv.lval]), array-to-pointer ([#conv.array]),
function-to-pointer ([#conv.func]), null pointer ([#conv.ptr]), null member
pointer ([#conv.mem]), or boolean ([#conv.bool]) conversion, can be performed
explicitly using [`static_cast].

[:en]
A program is ill-formed if it uses [`static_cast] to perform the inverse of an
ill-formed standard conversion sequence.

[enter:example]
[codeblock]
struct B { };
struct D : private B { };
void f() {
  static_cast<D*>((B*)0);               // [:en] Error: B is a private base of D.
  static_cast<int B::*>((int D::*)0);   // [:en] Error: B is a private base of D.
}
[codeblock:end]
[exit:example]

[para]
[:en]
The lvalue-to-rvalue ([#conv.lval]), array-to-pointer ([#conv.array]), and
function-to-pointer ([#conv.func]) conversions are applied to the operand.

[:en]
Such a [`static_cast] is subject to the restriction that the explicit conversion
does not cast away constness ([#expr.const.cast]), and the following additional
rules for specific cases:

[para]
[:en]
A value of a scoped enumeration type ([#dcl.enum]) can be explicitly converted
to an integral type.

[:en]
When that type is [$cv] [`bool], the resulting value is [`false] if the original
value is zero and [`true] for all other values.

[:en]
For the remaining integral types, the value is unchanged if the original value
can be represented by the specified type.

[:en]
Otherwise, the resulting value is unspecified.

[:en]
A value of a scoped enumeration type can also be explicitly converted to a
floating-point type; the result is the same as that of converting from the
original value to the floating-point type.

[para]
[:en]
[%enumeration type[!conversion to]]
[%enumeration type[![`static_cast][!conversion to]]]
A value of integral or enumeration type can be explicitly converted to a
complete enumeration type.

[:en]
The value is unchanged if the original value is within the range of the
enumeration values ([#dcl.enum]).

[:en]
Otherwise, the behavior is undefined.

[:en]
A value of floating-point type can also be explicitly converted to an
enumeration type.

[:en]
The resulting value is the same as converting the original value to the
underlying type of the enumeration ([#conv.fpint]), and subsequently to the
enumeration type.

[para]
[:en]
[%cast[!base class]]
[%cast[!derived class]]
A prvalue of type ["pointer to [$cv1] [`B],] where [`B] is a class type, can be
converted to a prvalue of type ["pointer to [$cv2] [`D],] where [`D] is a class
derived (Clause [#class.derived]) from [`B], if a valid standard conversion from
["pointer to [`D]] to ["pointer to [`B]] exists ([#conv.ptr]), [$cv2] is the
same cv-qualification as, or greater cv-qualification than, [$cv1], and [`B] is
neither a virtual base class of [`D] nor a base class of a virtual base class of
[`D].

[:en]
The null pointer value ([#conv.ptr]) is converted to the null pointer value of
the destination type.

[:en]
If the prvalue of type ["pointer to [$cv1] [`B]] points to a [`B] that is
actually a subobject of an object of type [`D], the resulting pointer points to
the enclosing object of type [`D].

[:en]
Otherwise, the behavior is undefined.

[para]
[:en]
[%cast[!pointer-to-member]]
A prvalue of type ["pointer to member of [`D] of type [$cv1] [`T]] can be
converted to a prvalue of type ["pointer to member of [`B]] of type [$cv2] [`T],
where [`B] is a base class (Clause [#class.derived]) of [`D], if a valid
standard conversion from ["pointer to member of [`B] of type [`T]] to ["pointer
to member of [`D] of type [`T]] exists ([#conv.mem]), and [$cv2] is the same
cv-qualification as, or greater cv-qualification than, [$cv1].

[footnote]
[:en]
Function types (including those used in pointer to member function types) are
never cv-qualified; see [#dcl.fct].
[footnote:end]

[:en]
The null member pointer value ([#conv.mem]) is converted to the null member
pointer value of the destination type.

[:en]
If class [`B] contains the original member, or is a base or derived class of the
class containing the original member, the resulting pointer to member points to
the original member. Otherwise, the behavior is undefined.

[enter:note]
[:en]
although class [`B] need not contain the original member, the dynamic type of
the object with which indirection through the pointer to member is performed
must contain the original member; see [#expr.mptr.oper].
[exit:note]

[para]
[:en]
A prvalue of type ["pointer to [$cv1] [`void]] can be converted to a prvalue of
type ["pointer to [$cv2] [`T],] where [`T] is an object type and [$cv2] is the
same cv-qualification as, or greater cv-qualification than, [$cv1].

[:en]
The null pointer value is converted to the null pointer value of the destination
type.

[:en]
If the original pointer value represents the address [`A] of a byte in memory
and [`A] satisfies the alignment requirement of [`T], then the resulting pointer
value represents the same address as the original pointer value, that is, [`A].

[:en]
The result of any other such pointer conversion is unspecified.

[:en]
A value of type pointer to object converted to ["pointer to [$cv] [`void]] and
back, possibly with different cv-qualification, shall have its original value.

[enter:example]
[codeblock]
T* p1 = new T;
const T* p2 = static_cast<const T*>(static_cast<void*>(p1));
bool b = p1 == p2;  // [:en] [`b] will have the value [`true].
[codeblock:end]
[exit:example]
