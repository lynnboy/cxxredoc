[section:chapter#input.output
    [:en] Input/output library
]

[/     1[input.output.general]{General]/]
[section#input.output.general
    [:en] General
]

[para]
[:en] This Clause describes components that [=Cpp] programs may use to perform
input/output operations.

[para]
[:en] The following subclauses describe requirements for stream parameters, and
components for forward declarations of iostreams, predefined iostreams objects,
base iostreams classes, stream buffering, stream formatting and manipulators,
string streams, and file streams, as summarized in Table
[#tab:iostreams.lib.summary].

[table:listing#tab:iostreams.lib.summary
    [:en] Input/output library summary
    [columns
        [column@headercenter@vcenter
            [:en] Subclause
        ]
        [column@vcenter@header~]
        [column@code
            [:en] Header(s)
        ]
    ]
    [border:group@both]
]

[|] [#iostreams.requirements]
[|] [:en] Requirements
[|]

[|] [#iostream.forward]
[|] [:en] Forward declarations
[|] <iosfwd>

[|] [#iostream.objects]
[|] [:en] Standard iostream objects
[|] <iostream>

[|] [#iostreams.base]
[|] [:en] Iostreams base classes
[|] <ios>

[|] [#stream.buffers]
[|] [:en] Stream buffers
[|] <streambuf>

[|] [#iostream.format]
[|] [:en] Formatting and manipulators
[|] <istream> [br] <ostream> [br] <iomanip>

[|] [#string.streams]
[|] [:en] String streams
[|] <sstream>

[|] [#file.streams]
[|] [:en] File streams
[|] <fstream> [br] <cstdio> [br] <cinttypes>

[table:end]

[para]
[:en] Figure [#fig:streampos] illustrates relationships among various types
described in this clause.

[:en] A line from [$@bf A] to [$@bf B] indicates that [$@bf A] is an alias (e.g.
a typedef) for [$@bf B] or that [$@bf A] is defined in terms of [$@bf B].

[figure:graphviz@dot#fig:streampos
    [:en] Stream position, offset, and size types [non-normative]
    [:zh_CN]
]
[:en]
digraph figstreampos
{
  traits_pos_type_char [label="char_traits<char>\n::pos_type"];
  traits_pos_type_wchar_t [label="char_traits<wchar_t>\n::pos_type"];
  traits_pos_type_char -> streampos [label=" iostreams.limits.pos"];
  traits_pos_type_wchar_t -> wstreampos [label=" iostreams.limits.pos"];
  streampos -> fpos [label=" iostream.forward"];
  fpos [label="fpos<mbstate_t>"];

  traits_off_type_char [label="char_traits<char>\n::off_type"];
  traits_off_type_wchar_t [label="char_traits<wchar_t>\n::off_type"];
  traits_off_type_char -> streamoff [label=" iostreams.limits.pos"];
  traits_off_type_wchar_t -> streamoff [label=" iostreams.limits.pos"];
  wstreampos -> fpos [label=" iostream.forward"];

  streamoff -> streamoff_type [label=" stream.types"];
  streamoff_type  [label="signed integer type\nsufficient for\n O/S maximum file size"];

  streamsize -> streamsize_type [label=" stream.types"];
  streamsize_type [label="signed integer type\nrepresents characters xfered\nor buffer sizes"];
}
[:zh_CN]
[figure:end]

[/     1[iostreams.requirements]{Iostreams requirements]/]
[section#iostreams.requirements
    [:en] Iostreams requirements
]

[/     2[iostream.limits.imbue]{Imbue limitations]/]
[section#iostream.limits.imbue
    [:en] Imbue limitations
]

[para]
[:en] No function described in Clause [#input.output] except for
[`ios_base::imbue] and [`basic_filebuf::pubimbue] causes any instance of
[`basic_ios::imbue] or [`basic_streambuf::imbue] to be called.

[:en] If any user function called from a function declared in Clause
[#input.output] or as an overriding virtual function of any class declared in
Clause [#input.output] calls [`imbue], the behavior is undefined.

[/     2[iostreams.limits.pos]{Positioning type limitations]/]
[section#iostreams.limits.pos
    [:en] Positioning type limitations
]

[para]
[:en] The classes of Clause [#input.output] with template arguments [`charT] and
[`traits] behave as described if [`traits::pos_type] and [`traits::off_type] are
[`streampos] and [`streamoff] respectively.

[:en] Except as noted explicitly below, their behavior when [`traits::pos_type]
and [`traits::off_type] are other types is
[%[`streambuf][!implementation-defined]]
[%@impldef behavior of iostream classes when [`traits::pos_type] is not
[`streampos] or when [`traits::off_type] is not [`streamoff]]
implementation-defined.

[para]
[:en] In the classes of Clause [#input.output], a template parameter with name
[`charT] represents a member of the set of types containing [`char], [`wchar_t],
and any other implementation-defined character types that satisfy the
requirements for a character on which any of the iostream components can be
instantiated.

[/     2[iostreams.threadsafety]{Thread safety]/]
[section#iostreams.threadsafety
    [:en] Thread safety
]

[para]
[:en] Concurrent access to a stream object ([#string.streams], [#file.streams]),
stream buffer object ([#stream.buffers]), or C Library stream ([#c.files]) by
multiple threads may result in a data race ([#intro.multithread]) unless
otherwise specified ([#iostream.objects]).

[enter:note]
[:en] Data races result in undefined behavior ([#intro.multithread]).
[exit:note]

[para]
[:en] If one thread makes a library call [$a] that writes a value to a stream
and, as a result, another thread reads this value from the stream through a
library call [$b] such that this does not result in a data race, then [$a][=']s
write synchronizes with [$b][=']s read.

[/     1[iostream.forward]{Forward declarations]/]
[section#iostream.forward
    [:en] Forward declarations
]

[para:synopsis]
[:en] Header [`<iosfwd>] synopsis

[%@library <iosfwd> [sortas iosfwd]]

[%@library basic_ios]
[%@library basic_streambuf]
[%@library basic_istream]
[%@library basic_ostream]
[%@library basic_stringbuf]
[%@library basic_istringstream]
[%@library basic_ostringstream]
[%@library basic_stringstream]
[%@library basic_filebuf]
[%@library basic_ifstream]
[%@library basic_ofstream]
[%@library basic_fstream]
[%@library basic_istreambuf_iterator]
[%@library basic_ostreambuf_iterator]
[%@library ios]
[%@library streambuf]
[%@library istream]
[%@library ostream]
[%@library stringbuf]
[%@library istringstream]
[%@library ostringstream]
[%@library stringstream]
[%@library filebuf]
[%@library ifstream]
[%@library ofstream]
[%@library fstream]
[%@library wstreambuf]
[%@library wistream]
[%@library wostream]
[%@library wstringbuf]
[%@library wistringstream]
[%@library wostringstream]
[%@library wstringstream]
[%@library wfilebuf]
[%@library wifstream]
[%@library wofstream]
[%@library wfstream]
[codeblock:synopsis]
namespace std {
  template<class charT> class char_traits;
  template<> class char_traits<char>;
  template<> class char_traits<char16_t>;
  template<> class char_traits<char32_t>;
  template<> class char_traits<wchar_t>;

  template<class T> class allocator;

  template <class charT, class traits = char_traits<charT> >
    class basic_ios;
  template <class charT, class traits = char_traits<charT> >
    class basic_streambuf;
  template <class charT, class traits = char_traits<charT> >
    class basic_istream;
  template <class charT, class traits = char_traits<charT> >
    class basic_ostream;
  template <class charT, class traits = char_traits<charT> >
    class basic_iostream;

  template <class charT, class traits = char_traits<charT>,
      class Allocator = allocator<charT> >
    class basic_stringbuf;
  template <class charT, class traits = char_traits<charT>,
      class Allocator = allocator<charT> >
    class basic_istringstream;
  template <class charT, class traits = char_traits<charT>,
      class Allocator = allocator<charT> >
    class basic_ostringstream;
  template <class charT, class traits = char_traits<charT>,
      class Allocator = allocator<charT> >
    class basic_stringstream;

  template <class charT, class traits = char_traits<charT> >
    class basic_filebuf;
  template <class charT, class traits = char_traits<charT> >
    class basic_ifstream;
  template <class charT, class traits = char_traits<charT> >
    class basic_ofstream;
  template <class charT, class traits = char_traits<charT> >
    class basic_fstream;

  template <class charT, class traits = char_traits<charT> >
    class istreambuf_iterator;
  template <class charT, class traits = char_traits<charT> >
    class ostreambuf_iterator;

  typedef basic_ios<char>       ios;
  typedef basic_ios<wchar_t>    wios;

  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char>   istream;
  typedef basic_ostream<char>   ostream;
  typedef basic_iostream<char>  iostream;

  typedef basic_stringbuf<char>     stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char>  stringstream;

  typedef basic_filebuf<char>  filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char>  fstream;

  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t>   wistream;
  typedef basic_ostream<wchar_t>   wostream;
  typedef basic_iostream<wchar_t>  wiostream;

  typedef basic_stringbuf<wchar_t>     wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t>  wstringstream;

  typedef basic_filebuf<wchar_t>  wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t>  wfstream;

  template <class state> class fpos;
  typedef fpos<char_traits<char>::state_type>    streampos;
  typedef fpos<char_traits<wchar_t>::state_type> wstreampos;
}
[codeblock:end]

[para]
[:en] Default template arguments are described as appearing both in [`<iosfwd>]
and in the synopsis of other headers but it is well-formed to include both
[`<iosfwd>] and one or more of the other headers.

[footnote]
[:en] It is the implementation[=']s responsibility to implement headers so that
including [`<iosfwd>] and other headers does not violate the rules about
multiple occurrences of default arguments.
[footnote:end]

[para]
[enter:note]
[:en] The class template specialization [`basic_ios<charT,traits>] serves as a
virtual base class for the class templates [`basic_istream], [`basic_ostream],
and class templates derived from them.

[:en] [`basic_iostream] is a class template derived from both
[`basic_istream<charT,traits>] and [`basic_ostream<charT,traits>].

[para]
[:en] The class template specialization [`basic_streambuf<charT,traits>]
serves as a base class for class templates [`basic_stringbuf] and
[`basic_filebuf].

[para]
[:en] The class template specialization [`basic_istream<charT,traits>] serves as
a base class for class templates [`basic_istringstream] and [`basic_ifstream].

[para]
[:en] The class template specialization [`basic_ostream<charT,traits>] serves as
a base class for class templates [`basic_ostringstream] and [`basic_ofstream].

[para]
[:en] The class template specialization [`basic_iostream<charT,traits>] serves
as a base class for class templates [`basic_stringstream] and [`basic_fstream].

[para]
[:en] Other typedefs define instances of class templates specialized for [`char]
or [`wchar_t] types.

[para]
[:en] Specializations of the class template [`fpos] are used for specifying file
position information.

[para]
[:en] The types [`streampos] and [`wstreampos] are used for positioning streams
specialized on [`char] and [`wchar_t] respectively.

[para]
[:en] This synopsis suggests a circularity between [`streampos] and
[`char_traits<char>].

[:en] An implementation can avoid this circularity by substituting equivalent
types.

[:en] One way to do this might be

[codeblock]
template<class stateT> class fpos { ... };      // [:en] depends on nothing
typedef ... _STATE;             // [:en] implementation private declaration of [`stateT]

typedef fpos<_STATE> streampos;

template<> struct char_traits<char> {
  typedef streampos
  pos_type;
}
[codeblock:end]
[exit:note]

[/     1[iostream.objects]{Standard iostream objects]/]
[section#iostream.objects
    [:en] Standard iostream objects
]

[/     2[iostream.objects.overview]{Overview]/]
[section#iostream.objects.overview
    [:en] Overview
]

[para:synopsis]
[:en] Header [`<iostream>] synopsis

[%@library <iostream> [sortas iostream]]

[codeblock:synopsis]
#include <ios>
#include <streambuf>
#include <istream>
#include <ostream>

namespace std {
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;

  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;
}
[codeblock:end]

[para]
[:en] The header [`<iostream>] declares objects that associate objects with the
standard C streams provided for by the functions declared in [%@library <cstdio>
[sortas cstdio]] [`<cstdio>] ([#c.files]), and includes all the headers
necessary to use these objects.

[para]
[:en] The objects are constructed and the associations are established at some
time prior to or during the first time an object of class [`ios_base::Init] is
constructed, and in any case before the body of [`main] begins execution.

[footnote]
[:en] If it is possible for them to do so, implementations are encouraged to
initialize the objects earlier than required.
[footnote:end]

[:en] The objects are not destroyed during program execution.

[footnote]
[:en] Constructors and destructors for static objects can access these objects
to read input from [`stdin] or write output to [`stdout] or [`stderr].
[footnote:end]

[:en] The results of including [`<iostream>] in a translation unit shall be as
if [`<iostream>] defined an instance of [`ios_base::Init] with static storage
duration.

[:en] Similarly, the entire program shall behave as if there were at least one
instance of [`ios_base::Init] with static storage duration.

[para]
[:en] Mixing operations on corresponding wide- and narrow-character streams
follows the same semantics as mixing such operations on [`FILE]s, as specified
in Amendment 1 of the ISO C standard.

[para]
[:en] Concurrent access to a synchronized ([#ios.members.static]) standard
iostream object[=']s formatted and unformatted input ([#istream]) and output
([#ostream]) functions or a standard C stream by multiple threads shall not
result in a data race ([#intro.multithread]).

[enter:note]
[:en] Users must still synchronize concurrent use of these objects and streams
by multiple threads if they wish to avoid interleaved characters.
[exit:note]

[/     2[narrow.stream.objects]{Narrow stream objects]/]
[section#narrow.stream.objects
    [:en] Narrow stream objects
]

[%@library cin]
[codeblock:declaration]
istream cin;
[codeblock:end]

[enter:description]
[para]
[:en] The object [`cin] controls input from a stream buffer associated with the
object [`stdin], declared in [%@library <cstdio> [sortas cstdio]] [`<cstdio>].

[para]
[:en] After the object [`cin] is initialized, [`cin.tie()] returns [`&cout].

[:en] Its state is otherwise the same as required for [`basic_ios<char>::init]
([#basic.ios.cons]).
[exit:description]

[%@library cout]
[codeblock:declaration]
ostream cout;
[codeblock:end]

[enter:description]
[para]
[:en] The object [`cout] controls output to a stream buffer associated with the
object [`stdout], declared in [%@library <cstdio> [sortas cstdio]] [`<cstdio>]
([#c.files]).
[exit:description]

[%@library cerr]
[codeblock:declaration]
ostream cerr;
[codeblock:end]

[enter:description]
[para]
[:en] The object [`cerr] controls output to a stream buffer associated with the
object [`stderr], declared in [%@library <cstdio> [sortas cstdio]] [`<cstdio>]
([#c.files]).

[para]
[:en] After the object [`cerr] is initialized, [`cerr.flags() & unitbuf] is
nonzero and [`cerr.tie()] returns [`&cout].

[:en] Its state is otherwise the same as required for [`basic_ios<char>::init]
([#basic.ios.cons]).
[exit:description]

[%@library clog]
[codeblock:declaration]
ostream clog;
[codeblock:end]

[enter:description]
[para]
[:en] The object [`clog] controls output to a stream buffer associated with the
object [`stderr], declared in [%@library <cstdio> [sortas cstdio]] [`<cstdio>]
([#c.files]).
[exit:description]

[/     2[wide.stream.objects]{Wide stream objects]/]
[section#wide.stream.objects
    [:en] Wide stream objects
]

[%@library wcin]
[codeblock:declaration]
wistream wcin;
[codeblock:end]

[enter:description]
[para]
[:en] The object [`wcin] controls input from a stream buffer associated with the
object [`stdin], declared in [%@library <cstdio> [sortas cstdio]] [`<cstdio>].

[para]
[:en] After the object [`wcin] is initialized, [`wcin.tie()] returns [`&wcout].

[:en] Its state is otherwise the same as required for
[`basic_ios<wchar_t>::init] ([#basic.ios.cons]).
[exit:description]

[%@library wcout]
[codeblock:declaration]
wostream wcout;
[codeblock:end]

[enter:description]
[para]
[:en] The object [`wcout] controls output to a stream buffer associated with the
object [`stdout], declared in [%@library <cstdio> [sortas cstdio]] [`<cstdio>]
([#c.files]).
[exit:description]

[%@library wcerr]
[codeblock:declaration]
wostream wcerr;
[codeblock:end]

[enter:description]
[para]
[:en] The object [`wcerr] controls output to a stream buffer associated with the
object [`stderr], declared in [%@library <cstdio> [sortas cstdio]] [`<cstdio>]
([#c.files]).

[para]
[:en] After the object [`wcerr] is initialized, [`wcerr.flags() & unitbuf] is
nonzero and [`wcerr.tie()] returns [`&wcout].

[:en] Its state is otherwise the same as required for
[`basic_ios<wchar_t>::init] ([#basic.ios.cons]).
[exit:description]

[%@library wclog]
[codeblock:declaration]
wostream wclog;
[codeblock:end]

[enter:description]
[para]
[:en] The object [`wclog] controls output to a stream buffer associated with the
object [`stderr], declared in [%@library <cstdio> [sortas cstdio]] [`<cstdio>]
([#c.files]).
[exit:description]

[/     1[iostreams.base]{Iostreams base classes]/]
[section#iostreams.base
    [:en] Iostreams base classes
]

[/     2[iostreams.base.overview]{Overview]/]
[section#iostreams.base.overview
    [:en] Overview
]

[para:synopsis]
[:en] Header [`<ios>] synopsis

[%@library <ios> [sortas ios]]

[codeblock:synopsis [special implementation-defined] ]
#include <iosfwd>

namespace std {
  typedef implementation-defined streamoff;
  typedef implementation-defined streamsize;
  template <class stateT> class fpos;

  class ios_base;
  template <class charT, class traits = char_traits<charT> >
    class basic_ios;

  // [:en] [#std.ios.manip], manipulators:
  ios_base& boolalpha  (ios_base& str);
  ios_base& noboolalpha(ios_base& str);

  ios_base& showbase   (ios_base& str);
  ios_base& noshowbase (ios_base& str);

  ios_base& showpoint  (ios_base& str);
  ios_base& noshowpoint(ios_base& str);

  ios_base& showpos    (ios_base& str);
  ios_base& noshowpos  (ios_base& str);

  ios_base& skipws     (ios_base& str);
  ios_base& noskipws   (ios_base& str);

  ios_base& uppercase  (ios_base& str);
  ios_base& nouppercase(ios_base& str);

  ios_base& unitbuf    (ios_base& str);
  ios_base& nounitbuf  (ios_base& str);

  // [:en] [#adjustfield.manip] adjustfield:
  ios_base& internal   (ios_base& str);
  ios_base& left       (ios_base& str);
  ios_base& right      (ios_base& str);

  // [:en] [#basefield.manip] basefield:
  ios_base& dec        (ios_base& str);
  ios_base& hex        (ios_base& str);
  ios_base& oct        (ios_base& str);

  // [:en] [#floatfield.manip] floatfield:
  ios_base& fixed      (ios_base& str);
  ios_base& scientific (ios_base& str);
  ios_base& hexfloat   (ios_base& str);
  ios_base& defaultfloat(ios_base& str);

  // [:en] [#error.reporting] error reporting:
  enum class io_errc {
    stream = 1
  };

  template <> struct is_error_code_enum<io_errc> : public true_type { };
  error_code make_error_code(io_errc e) noexcept;
  error_condition make_error_condition(io_errc e) noexcept;
  const error_category& iostream_category() noexcept;
}
[codeblock:end]
[%@library ios]
[%@library basic_ios<char>]
[%@library wios]
[%@library basic_ios<wchar_t>]
[%@library fpos]

[/     2[stream.types]{Types]/]
[section#stream.types
    [:en] Types
]

[%@library streamoff]
[codeblock:declaration [special implementation-defined] ]
typedef implementation-defined streamoff;
[codeblock:end]

[enter:description]
[para]
[:en] The type [`streamoff] is a synonym for one of the signed basic integral
types of sufficient size to represent the maximum possible file size for the
operating system.

[footnote]
[:en] Typically [`long long].
[footnote:end]
[exit:description]

[%@library streamsize]
[codeblock:declaration [special implementation-defined] ]
typedef implementation-defined streamsize;
[codeblock:end]

[enter:description]
[para]
[:en] The type [`streamsize] is a synonym for one of the signed basic integral
types.

[:en] It is used to represent the number of characters transferred in an I/O
operation, or the size of I/O buffers.

[footnote]
[:en] [`streamsize] is used in most places where ISO C would use [`size_t].

[:en] Most of the uses of [`streamsize] could use [`size_t], except for the
[`strstreambuf] constructors, which require negative values.

[:en] It should probably be the signed type corresponding to [`size_t] (which is
what Posix.2 calls [`ssize_t]).
[footnote:end]
[exit:description]

[/     2[ios.base]{Class [`ios_base]]/]
[section#ios.base
    [:en] Class [`ios_base]
]

[%@library ios_base]
[codeblock:synopsis [special unspecified T1 T2 T3 T4] ]
namespace std {
  class ios_base {
  public:
    class failure;

    // [:en] [#ios::fmtflags] [`fmtflags]
    typedef T1 fmtflags;
    static constexpr fmtflags boolalpha = unspecified;
    static constexpr fmtflags dec = unspecified;
    static constexpr fmtflags fixed = unspecified;
    static constexpr fmtflags hex = unspecified;
    static constexpr fmtflags internal = unspecified;
    static constexpr fmtflags left = unspecified;
    static constexpr fmtflags oct = unspecified;
    static constexpr fmtflags right = unspecified;
    static constexpr fmtflags scientific = unspecified;
    static constexpr fmtflags showbase = unspecified;
    static constexpr fmtflags showpoint = unspecified;
    static constexpr fmtflags showpos = unspecified;
    static constexpr fmtflags skipws = unspecified;
    static constexpr fmtflags unitbuf = unspecified;
    static constexpr fmtflags uppercase = unspecified;
    static constexpr fmtflags adjustfield = [=Seebelow];
    static constexpr fmtflags basefield = [=Seebelow];
    static constexpr fmtflags floatfield = [=Seebelow];

    // [:en] [#ios::iostate] [`iostate]
    typedef T2 iostate;
    static constexpr iostate badbit = unspecified;
    static constexpr iostate eofbit = unspecified;
    static constexpr iostate failbit = unspecified;
    static constexpr iostate goodbit = [=Seebelow];

    // [:en] [#ios::openmode] [`openmode]
    typedef T3 openmode;
    static constexpr openmode app = unspecified;
    static constexpr openmode ate = unspecified;
    static constexpr openmode binary = unspecified;
    static constexpr openmode in = unspecified;
    static constexpr openmode out = unspecified;
    static constexpr openmode trunc = unspecified;

    // [:en] [#ios::seekdir] [`seekdir]
    typedef T4 seekdir;
    static constexpr seekdir beg = unspecified;
    static constexpr seekdir cur = unspecified;
    static constexpr seekdir end = unspecified;

    class Init;

    // [:en] [#fmtflags.state] fmtflags state:
    fmtflags flags() const;
    fmtflags flags(fmtflags fmtfl);
    fmtflags setf(fmtflags fmtfl);
    fmtflags setf(fmtflags fmtfl, fmtflags mask);
    void unsetf(fmtflags mask);

    streamsize precision() const;
    streamsize precision(streamsize prec);
    streamsize width() const;
    streamsize width(streamsize wide);

    // [:en] [#ios.base.locales] locales:
    locale imbue(const locale& loc);
    locale getloc() const;

    // [:en] [#ios.base.storage] storage:
    static int xalloc();
    long&  iword(int index);
    void*& pword(int index);

    // [:en] destructor
    virtual ~ios_base();

    // [:en] [#ios.base.callback] callbacks;
    enum event { erase_event, imbue_event, copyfmt_event };
    typedef void (*event_callback)(event, ios_base&, int index);
    void register_callback(event_callback fn, int index);

    ios_base(const ios_base&) = delete;
    ios_base& operator=(const ios_base&) = delete;

    static bool sync_with_stdio(bool sync = true);

  protected:
    ios_base();

  private:
    static int index;  // [=Expos]
    long* iarray;      // [=Expos]
    void** parray;     // [=Expos]
  };
}
[codeblock:end]

[para]
[:en] [`ios_base] defines several member types:

[list]
[item]
[:en] a class [`failure] derived from [`system_error];
[item]
[:en] a class [`Init];
[item]
[:en] three bitmask types, [`fmtflags], [`iostate], and [`openmode];
[item]
[:en] an enumerated type, [`seekdir].
[list:end]

[para]
[:en] It maintains several kinds of data:

[list]
[item]
[:en] state information that reflects the integrity of the stream buffer;
[item]
[:en] control information that influences how to interpret (format) input
sequences and how to generate (format) output sequences;
[item]
[:en] additional information that is stored by the program for its private use.
[list:end]

[para]
[enter:note]
[:en] For the sake of exposition, the maintained data is presented here as:

[list]
[item]
[:en] [`static int index], specifies the next available unique index for the
integer or pointer arrays maintained for the private use of the program,
initialized to an unspecified value;
[item]
[:en] [`long* iarray], points to the first element of an arbitrary-length
[`long] array maintained for the private use of the program;
[item]
[:en] [`void** parray], points to the first element of an arbitrary-length
pointer array maintained for the private use of the program.
[exit:note]
[list:end]

[/     3[ios.types]{Types]/]
[section#ios.types
    [:en] Types
]

[/     4[ios::failure]{Class [`ios_base::failure]]/]
[section#ios::failure
    [:en] Class [`ios_base::failure]
]

[%@library ios_base::failure]
[codeblock:synopsis]
namespace std {
  class ios_base::failure : public system_error {
  public:
    explicit failure(const string& msg, const error_code& ec = io_errc::stream);
    explicit failure(const char* msg, const error_code& ec = io_errc::stream);
  };
}
[codeblock:end]

[para]
[:en] The class [`failure] defines the base class for the types of all objects
thrown as exceptions, by functions in the iostreams library, to report errors
detected during stream buffer operations.

[para]
[:en] When throwing [`ios_base::failure] exceptions, implementations should
provide values of [`ec] that identify the specific reason for the failure.

[enter:note]
[:en] Errors arising from the operating system would typically be reported as
[`system_category()] errors with an error value of the error number reported by
the operating system.

[:en] Errors arising from within the stream library would typically be reported
as [`error_code(io_errc::stream, iostream_category())].
[exit:note]

[%@library failure[!ios_base::failure]]
[codeblock:declaration]
explicit failure(const string& msg, const error_code& ec = io_errc::stream);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`failure] by constructing the base class
with [`msg] and [`ec].
[exit:description]

[%@library failure[!ios_base::failure]]
[codeblock:declaration]
explicit failure(const char* msg, const error_code& ec = io_errc::stream);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`failure] by constructing the base class
with [`msg] and [`ec].
[exit:description]

[/     4[ios::fmtflags]{Type [`ios_base::fmtflags]]/]
[section#ios::fmtflags
    [:en] Type [`ios_base::fmtflags]
]

[%@library fmtflags[!ios_base]]
[codeblock:declaration [special T1] ]
typedef T1 fmtflags;
[codeblock:end]

[enter:description]
[para]
[:en] The type [`fmtflags] is a bitmask type ([#bitmask.types]).

[:en] Setting its elements has the effects indicated in Table
[#tab:iostreams.fmtflags.effects].

[table:listing#tab:iostreams.fmtflags.effects
    [:en] [`fmtflags] effects
    [columns
        [column@headercenter@code
            [:en] Element
        ]
        [column@headercenter
            [:en] Effects(s) if set
        ]
    ]
    [border:cell@none]
]

[|] boolalpha
[|] [:en] insert and extract [`bool] type in alphabetic format

[|] dec
[|] [:en] converts integer input or generates integer output in decimal base

[|] fixed
[|] [:en] generate floating-point output in fixed-point notation

[|] hex
[|] [:en] converts integer input or generates integer output in hexadecimal base

[|] internal
[|] [:en] adds fill characters at a designated internal point in certain
    generated output, or identical to [`right] if no such point is designated

[|] left
[|] [:en] adds fill characters on the right (final positions) of certain
    generated output

[|] oct
[|] [:en] converts integer input or generates integer output in octal base

[|] right
[|] [:en] adds fill characters on the left (initial positions) of certain
    generated output

[|] scientific
[|] [:en] generates floating-point output in scientific notation

[|] showbase
[|] [:en] generates a prefix indicating the numeric base of generated integer
    output

[|] showpoint
[|] [:en] generates a decimal-point character unconditionally in generated
    floating-point output

[|] showpos
[|] [:en] generates a [`+] sign in non-negative generated numeric output

[|] skipws
[|] [:en] skips leading whitespace before certain input operations

[|] unitbuf
[|] [:en] flushes output after each output operation

[|] uppercase
[|] [:en] replaces certain lowercase letters with their uppercase equivalents in
    generated output

[table:end]

[para]
[:en] Type [`fmtflags] also defines the constants indicated in Table
[#tab:iostreams.fmtflags.constants].

[table:listing#tab:iostreams.fmtflags.constants
    [:en] [`fmtflags] constants
    [columns
        [column@headercenter@code
            [:en] Constant
        ]
        [column@headercenter@code
            [:en] Allowable values
        ]
    ]
    [border:cell@none]
]

[|] adjustfield
[|] left | right | internal

[|] basefield
[|] dec | oct | hex

[|] floatfield
[|] scientific | fixed

[table:end]

[exit:description]

[/     4[ios::iostate]{Type [`ios_base::iostate]]/]
[section#ios::iostate
    [:en] Type [`ios_base::iostate]
]

[%@library iostate[!ios_base]]
[%@library ios_base[!iostate]]
[codeblock:declaration [special T2] ]
typedef T2 iostate;
[codeblock:end]

[enter:description]
[para]
[:en] The type [`iostate] is a bitmask type ([#bitmask.types]) that contains the
elements indicated in Table [#tab:iostreams.iostate.effects].

[table:listing#tab:iostreams.iostate.effects
    [:en] [`iostate] effects
    [columns
        [column@headercenter@code
            [:en] Element
        ]
        [column@headercenter
            [:en] Effects(s) if set
        ]
    ]
    [border:cell@none]
]

[|] badbit
[|] [:en] indicates a loss of integrity in an input or output sequence (such as
    an irrecoverable read error from a file);

[|] eofbit
[|] [:en] indicates that an input operation reached the end of an input
    sequence;

[|] failbit
[|] [:en] indicates that an input operation failed to read the expected
    characters, or that an output operation failed to generate the desired
    characters.

[table:end]

[para]
[:en] Type [`iostate] also defines the constant:

[list]
[item]
[:en] [`goodbit], the value zero.
[list:end]
[exit:description]

[/     4[ios::openmode]{Type [`ios_base::openmode]]/]
[section#ios::openmode
    [:en] Type [`ios_base::openmode]
]

[%@library openmode[!ios_base]]
[codeblock:declaration [special T3] ]
typedef T3 openmode;
[codeblock:end]

[enter:description]
[para]
[:en] The type [`openmode] is a bitmask type ([#bitmask.types]).

[:en] It contains the elements indicated in Table
[#tab:iostreams.openmode.effects].

[table:listing#tab:iostreams.openmode.effects
    [:en] [`openmode] effects
    [columns
        [column@headercenter@code
            [:en] Element
        ]
        [column@headercenter
            [:en] Effects(s) if set
        ]
    ]
    [border:cell@none]
]

[|] app
[|] [:en] seek to end before each write

[|] ate
[|] [:en] open and seek to end immediately after opening

[|] binary
[|] [:en] perform input and output in binary mode (as opposed to text mode)

[|] in
[|] [:en] open for input

[|] out
[|] [:en] open for output

[|] trunc
[|] [:en] truncate an existing stream when opening

[table:end]

[exit:description]

[/     4[ios::seekdir]{Type [`ios_base::seekdir]]/]
[section#ios::seekdir
    [:en] Type [`ios_base::seekdir]
]

[%@library seekdir[!ios_base]]
[codeblock:declaration [special T4] ]
typedef T4 seekdir;
[codeblock:end]

[enter:description]
[para]
[:en] The type [`seekdir] is an enumerated type ([#enumerated.types]) that
contains the elements indicated in Table [#tab:iostreams.seekdir.effects].

[table:listing#tab:iostreams.seekdir.effects
    [:en] [`seekdir] effects
    [columns
        [column@headercenter@code
            [:en] Element
        ]
        [column@headercenter
            [:en] Effects(s) if set
        ]
    ]
    [border:cell@none]
]

[|] beg
[|] [:en] request a seek (for subsequent input or output) relative to the
    beginning of the stream

[|] cur
[|] [:en] request a seek relative to the current position within the sequence

[|] end
[|] [:en] request a seek relative to the current end of the sequence

[table:end]
[exit:description]

[/     4[ios::Init]{Class [`ios_base::Init}}/]
[section#ios::Init
    [:en] Class [`ios_base::Init]
]

[%@library ios_base::Init]
[codeblock:synopsis]
namespace std {
  class ios_base::Init {
  public:
    Init();
   ~Init();
  private:
    static int init_cnt; // [=Expos]
  };
}
[codeblock:end]

[para]
[:en] The class [`Init] describes an object whose construction ensures the
construction of the eight objects declared in [`<iostream>]
([#iostream.objects]) that associate file stream buffers with the standard C
streams provided for by the functions declared in [`<cstdio>] ([#c.files]).

[para]
[:en] For the sake of exposition, the maintained data is presented here as:

[list]
[item]
[:en] [`static int init_cnt], counts the number of constructor and destructor
calls for class [`Init], initialized to zero.
[list:end]

[%@library Init[!ios_base::Init]]
[codeblock:declaration]
Init();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`Init].

[:en] Constructs and initializes the objects [`cin], [`cout], [`cerr], [`clog],
[`wcin], [`wcout], [`wcerr], and [`wclog] if they have not already been
constructed and initialized.
[exit:description]

[%@library ios_base::Init[![:en]destructor]]
[codeblock:declaration]
~Init();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Destroys an object of class [`Init].

[:en] If there are no other instances of the class still in existence, calls
[%@library flush] [`cout.flush()], [`cerr.flush()], [`clog.flush()],
[`wcout.flush()], [`wcerr.flush()], [`wclog.flush()].
[exit:description]

[/     3[fmtflags.state]{[`ios_base] state functions]/]
[section#fmtflags.state
    [:en] [`ios_base] state functions
]

[%@library flags[!ios_base]]
[codeblock:declaration]
fmtflags flags() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] The format control information for both input and output.
[exit:description]

[%@library fmtflags[!ios_base]]
[%@library ios_base[!fmtflags]]
[codeblock:declaration]
fmtflags flags(fmtflags fmtfl);
[codeblock:end]

[enter:description]
[para:postcondition]
[:en] [`fmtfl == flags()].

[para:returns]
[:en] The previous value of [`flags()].
[exit:description]

[%@library setf[!ios_base]]
[codeblock:declaration]
fmtflags setf(fmtflags fmtfl);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Sets [`fmtfl] in [`flags()].

[para:returns]
[:en] The previous value of [`flags()].
[exit:description]

[%@library setf[!ios_base]]
[%@library ios_base[!setf]]
[codeblock:declaration]
fmtflags setf(fmtflags fmtfl, fmtflags mask);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Clears [`mask] in [`flags()], sets [`fmtfl & mask] in [`flags()].

[para:returns]
[:en] The previous value of [`flags()].
[exit:description]

[%@library unsetf[!ios_base]]
[codeblock:declaration]
void unsetf(fmtflags mask);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Clears [`mask] in [`flags()].
[exit:description]

[%@library precision[!ios_base]]
[codeblock:declaration]
streamsize precision() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] The precision to generate on certain output conversions.
[exit:description]

[%@library precision[!ios_base]]
[%@library ios_base[!precision]]
[codeblock:declaration]
streamsize precision(streamsize prec);
[codeblock:end]

[enter:description]
[para:postcondition]
[:en] [`prec == precision()].

[para:returns]
[:en] The previous value of [`precision()].
[exit:description]

[%@library width[!ios_base]]
[codeblock:declaration]
streamsize width() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] The minimum field width (number of characters) to generate on certain
output conversions.
[exit:description]

[%@library streamsize[!ios_base]]
[%@library ios_base[!streamsize]]
[codeblock:declaration]
streamsize width(streamsize wide);
[codeblock:end]

[enter:description]
[para:postcondition]
[:en] [`wide == width()].

[para:returns]
[:en] The previous value of [`width()].
[exit:description]

[/     3[ios.base.locales]{[`ios_base] functions]/]
[section#ios.base.locales
    [:en] [`ios_base] functions
]

[%@library imbue[!ios_base]]
[codeblock:declaration]
locale imbue(const locale& loc);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls each registered callback pair [`(fn,index)] ([#ios.base.callback])
as [`(*fn)(imbue_event,*this,index)] at such a time that a call to
[`ios_base::getloc()] from within [`fn] returns the new locale value [`loc].

[para:returns]
[:en] The previous value of [`getloc()].

[para:postcondition]
[:en] [`loc == getloc()].
[exit:description]

[%@library getloc[!ios_base]]
[codeblock:declaration]
locale getloc() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] If no locale has been imbued, a copy of the global [=Cpp] locale,
[`locale()], in effect at the time of construction.

[:en] Otherwise, returns the imbued locale, to be used to perform
locale-dependent input and output operations.
[exit:description]

[/     3[ios.members.static]{[`ios_base] static members]/]
[section#ios.members.static
    [:en] [`ios_base] static members
]

[%@library sync_with_stdio[!ios_base]]
[codeblock:declaration]
bool sync_with_stdio(bool sync = true);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`true] if the previous state of the standard iostream objects
([#iostream.objects]) was synchronized and otherwise returns [`false].

[:en] The first time it is called, the function returns [`true].

[para:effects]
[:en] If any input or output operation has occurred using the standard streams
prior to the call, the effect is [%implementation-defined] [%@impldef effect of
calling [`ios_base::sync_with_stdio] after any input or output operation on
standard streams] implementation-defined.

[:en] Otherwise, called with a false argument, it allows the standard streams to
operate independently of the standard C streams.

[para]
[:en] When a standard iostream object [`str] is [+synchronized] with a standard
stdio stream [`f], the effect of inserting a character [`c] by

[codeblock:notation]
fputc(f, c);
[codeblock:end]

[:en@~] is the same as the effect of

[codeblock:notation]
str.rdbuf()->sputc(c);
[codeblock:end]

[:en@~] for any sequences of characters; the effect of extracting a character
[`c] by

[codeblock:notation]
c = fgetc(f);
[codeblock:end]

[:en@~] is the same as the effect of

[codeblock:notation]
c = str.rdbuf()->sbumpc();
[codeblock:end]

[:en@~] for any sequences of characters; and the effect of pushing back a
character [`c] by

[codeblock:notation]
ungetc(c, f);
[codeblock:end]

[:en@~] is the same as the effect of

[codeblock:notation]
str.rdbuf()->sputbackc(c);
[codeblock:end]

[:en@~] for any sequence of characters.

[footnote]
[:en] This implies that operations on a standard iostream object can be mixed
arbitrarily with operations on the corresponding stdio stream.

[:en] In practical terms, synchronization usually means that a standard iostream
object and a standard stdio object share a buffer.
[footnote:end]
[exit:description]

[/     3[ios.base.storage]{[`ios_base] storage functions]/]
[section#ios.base.storage
    [:en] [`ios_base] storage functions
]

[%@library xalloc[!ios_base]]
[codeblock:declaration]
static int xalloc();
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`index++].

[para:remarks]
[:en] Concurrent access to this function by multiple threads shall not result in
a data race ([#intro.multithread]).
[exit:description]

[%@library iword[!ios_base]]
[codeblock:declaration]
long& iword(int idx);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`iarray] is a null pointer, allocates an array of [`long] of
unspecified size and stores a pointer to its first element in [`iarray].

[:en] The function then extends the array pointed at by [`iarray] as necessary
to include the element [`iarray[idx`]].

[:en] Each newly allocated element of the array is initialized to zero.

[:en] The reference returned is invalid after any other operations on the
object.

[footnote]
[:en] An implementation is free to implement both the integer array pointed at
by [`iarray] and the pointer array pointed at by [`parray] as sparse data
structures, possibly with a one-element cache for each.
[footnote:end]

[:en] However, the value of the storage referred to is retained, so that until
the next call to [`copyfmt], calling [`iword] with the same index yields another
reference to the same value.

[:en] If the function fails

[footnote]
[:en] for example, because it cannot allocate space.
[footnote:end]

[:en@~] and [`*this] is a base subobject of a [`basic_ios<>] object or
subobject, the effect is equivalent to calling [`basic_ios<>::setstate(badbit)]
on the derived object (which may throw [`failure]).

[para:returns]
[:en] On success [`iarray[idx`]].

[:en] On failure, a valid [`long&] initialized to 0.
[exit:description]

[%@library pword[!ios_base]]
[codeblock:declaration]
void*& pword(int idx);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`parray] is a null pointer, allocates an array of pointers to [`void]
of unspecified size and stores a pointer to its first element in [`parray].

[:en] The function then extends the array pointed at by [`parray] as necessary
to include the element [`parray[idx`]].

[:en] Each newly allocated element of the array is initialized to a null
pointer.

[:en] The reference returned is invalid after any other operations on the
object.

[:en] However, the value of the storage referred to is retained, so that until
the next call to [`copyfmt], calling [`pword] with the same index yields another
reference to the same value.

[:en] If the function fails

[footnote]
[:en] for example, because it cannot allocate space.
[footnote:end]

[:en@~] and [`*this] is a base subobject of a [`basic_ios<>] object or
subobject, the effect is equivalent to calling [`basic_ios<>::setstate(badbit)]
on the derived object (which may throw [`failure]).

[para:returns]
[:en] On success [`parray[idx`]].

[:en] On failure a valid [`void*&] initialized to 0.

[para:notes]
[:en] After a subsequent call to [`pword(int)] for the same object, the earlier
return value may no longer be valid.
[exit:description]

[/     3[ios.base.callback]{[`ios_base] callbacks]/]
[section#ios.base.callback
    [:en] [`ios_base] callbacks
]

[%@library register_callback[!ios_base]]
[codeblock:declaration]
void register_callback(event_callback fn, int index);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Registers the pair [`(fn,index)] such that during calls to [`imbue()]
([#ios.base.locales]), [`copyfmt()], or [`~ios_base()] ([#ios.base.cons]), the
function [`fn] is called with argument [`index].

[:en] Functions registered are called when an event occurs, in opposite order of
registration.

[:en] Functions registered while a callback function is active are not called
until the next event.

[para:requires]
[:en] The function [`fn] shall not throw exceptions.

[para:notes]
[:en] Identical pairs are not merged.

[:en] A function registered twice will be called twice.
[exit:description]

[/     3[ios.base.cons]{[`ios_base] constructors/destructor]/]
[section#ios.base.cons
    [:en] [`ios_base] constructors/destructor
]

[%@library ios_base[!ios_base]]
[codeblock:declaration]
ios_base();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Each [`ios_base] member has an indeterminate value after construction.

[:en] The object[=']s members shall be initialized by calling [`basic_ios::init]
before the object[=']s first use or before it is destroyed, whichever comes
first; otherwise the behavior is undefined.
[exit:description]

[%@library ios_base[![:en]destructor]]
[codeblock:declaration]
~ios_base();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Destroys an object of class [`ios_base].

[:en] Calls each registered callback pair [`(fn, index)] ([#ios.base.callback])
as [`(*fn)(erase_event, *this, index)] at such time that any [`ios_base] member
function called from within [`fn] has well defined results.
[exit:description]

[/     2[fpos]{Class template [`fpos]]/]
[section#fpos
    [:en] Class template [`fpos]
]

[%@library fpos]
[codeblock:synopsis]
namespace std {
  template <class stateT> class fpos {
  public:
    // [:en] [#fpos.members] Members
    stateT state() const;
    void state(stateT);
  private;
    stateT st; // [=Expos]
  };
}
[codeblock:end]

[/     3[fpos.members]{[`fpos] members]/]
[section#fpos.members
    [:en] [`fpos] members
]

[%@library state[!fpos]]
[codeblock:declaration]
void state(stateT s);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Assign [`s] to [`st].
[exit:description]

[%@library state[!fpos]]
[%@library fpos[!state]]
[codeblock:declaration]
stateT state() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] Current value of [`st].
[exit:description]

[/     3[fpos.operations]{[`fpos] requirements]/]
[section#fpos.operations
    [:en] [`fpos] requirements
]

[para]
[%@library fpos]
[%@library streamoff]
[:en] Operations specified in Table [#tab:iostreams.position.requirements] are
permitted.

[:en] In that table,
[list]
[item]
[:en] [`P] refers to an instance of [`fpos],
[item]
[:en] [`p] and [`q] refer to values of type [`P],
[item]
[:en] [`O] refers to type [`streamoff],
[item]
[:en] [`o] refers to a value of type [`streamoff],
[item]
[:en] [`sz] refers to a value of type [`streamsize] and
[item]
[:en] [`i] refers to a value of type [`int].
[list:end]

[table:listing#tab:iostreams.position.requirements
    [:en] Position type requirements
    [columns
        [column@headercenter@code
            [:en] Expression
        ]
        [column@headercenter
            [:en] Return type
        ]
        [column@headercenter
            [:en] Operational semantics
        ]
        [column@headercenter
            [:en] Assertion/note [br] pre-/post-condition
        ]
    ]
    [border:row@both]
]

[|] P(i)
[|]
[|]
[|] [`p == P(i)] [br]
    [:en] note: a destructor is assumed.

[|] P p(i); [br] P p = i;
[|]
[|]
[|] [:en] post: [`p == P(i)].

[|] P(o)
[|] [`fpos]
[|] [:en] converts from [`offset]
[|]

[|] O(p)
[|] [`streamoff]
[|] [:en] converts to [`offset]
[|] [`P(O(p)) == p]

[|] p == q
[|] [:en] convertible to [`bool]
[|]
[|] [:en] [`==] is an equivalence relation

[|] p != q
[|] [:en] convertible to [`bool]
[|] [`!(p == q)]
[|]

[|] q = p + o [br] p += o
[|] [`fpos]
[|] [:en] [`+] offset
[|] [`q - o == p]

[|] q = p - o [br] p -= o
[|] [`fpos]
[|] [:en] [`-] offset
[|] [`q + o == p]

[|] o = p - q
[|] [`streamoff]
[|] [:en] distance
[|] [`q + o == p]

[|] streamsize(o)
[|] [`streamsize]
[|] [:en] converts
[|] [`streamsize(O(sz)) == sz]

[|] O(sz)
[|] [`streamoff]
[|] [:en] converts
[|] [`streamsize(O(sz)) == sz]

[table:end]

[para]
[enter:note]
[:en] Every implementation is required to supply overloaded operators on [`fpos]
objects to satisfy the requirements of [#fpos.operations].

[:en] It is unspecified whether these operators are members of [`fpos], global
operators, or provided in some other way.
[exit:note]

[para]
[:en] Stream operations that return a value of type [`traits::pos_type] return
[`P(O(-1))] as an invalid value to signal an error.

[:en] If this value is used as an argument to any [`istream], [`ostream], or
[`streambuf] member that accepts a value of type [`traits::pos_type] then the
behavior of that function is [%undefined] undefined.

[/     2[ios]{Class template [`basic_ios]]/]
[section#ios
    [:en] Class template [`basic_ios]
]

[/     3[ios.overview]{Overview]/]
[section#ios.overview
    [:en] Overview
]

[%@library basic_ios]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT> >
  class basic_ios : public ios_base {
  public:

    // [:en] types:
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;

    explicit operator bool() const;
    bool operator!() const;
    iostate rdstate() const;
    void clear(iostate state = goodbit);
    void setstate(iostate state);
    bool good() const;
    bool eof()  const;
    bool fail() const;
    bool bad()  const;

    iostate exceptions() const;
    void exceptions(iostate except);

    // [:en] [#basic.ios.cons] Constructor/destructor:
    explicit basic_ios(basic_streambuf<charT,traits>* sb);
    virtual ~basic_ios();

    // [:en] [#basic.ios.members] Members:
    basic_ostream<charT,traits>* tie() const;
    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);

    basic_streambuf<charT,traits>* rdbuf() const;
    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);

    basic_ios& copyfmt(const basic_ios& rhs);

    char_type fill() const;
    char_type fill(char_type ch);

    locale imbue(const locale& loc);

    char     narrow(char_type c, char dfault) const;
    char_type widen(char c) const;

    basic_ios(const basic_ios&) = delete;
    basic_ios& operator=(const basic_ios&) = delete;

  protected:
    basic_ios();
    void init(basic_streambuf<charT,traits>* sb);
    void move(basic_ios& rhs);
    void move(basic_ios&& rhs);
    void swap(basic_ios& rhs) noexcept;
    void set_rdbuf(basic_streambuf<charT, traits>* sb);

  };
}
[codeblock:end]

[/     3[basic.ios.cons]{[`basic_ios] constructors]/]
[section#basic.ios.cons
    [:en] [`basic_ios] constructors
]

[%@library basic_ios[!basic_ios]]
[codeblock:declaration]
explicit basic_ios(basic_streambuf<charT,traits>* sb);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_ios], assigning initial values to
its member objects by calling [`init(sb)].
[exit:description]

[%@library basic_ios[![:en]constructor]]
[codeblock:declaration]
basic_ios();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_ios] ([#ios.base.cons]) leaving its
member objects uninitialized.

[:en] The object shall be initialized by calling [`basic_ios::init] before its
first use or before it is destroyed, whichever comes first; otherwise the
behavior is undefined.
[exit:description]

[%@library basic_ios[![:en]destructor]]
[codeblock:declaration]
~basic_ios();
[codeblock:end]

[enter:description]
[para:notes]
[:en] The destructor does not destroy [`rdbuf()].
[exit:description]

[%@library init[!basic_ios]]
[%@library basic_ios[!init]]
[codeblock:declaration]
void init(basic_streambuf<charT,traits>* sb);
[codeblock:end]

[enter:description]
[para:postconditions]
[:en] The postconditions of this function are indicated in Table
[#tab:iostreams.basicios.init.effects].

[table:listing#tab:iostreams.basicios.init.effects
    [:en] [`basic_ios::init()] effects
    [columns
        [column@headercenter@code
            [:en] Element
        ]
        [column@headercenter
            [:en] Effects(s) if set
        ]
    ]
    [border:cell@none]
]

[|] rdbuf()
[|] [`sb]

[|] tie()
[|] [`0]

[|] rdstate()
[|] [:en] [`goodbit] if [`sb] is not a null pointer, otherwise [`badbit].

[|] exceptions()
[|] [`goodbit]

[|] flags()
[|] [`skipws | dec]

[|] width()
[|] [`0]

[|] precision()
[|] [`6]

[|] fill()
[|] [`widen(' ');]

[|] getloc()
[|] [:en] a copy of the value returned by [`locale()]

[|] [$iarray]
[|] [:en] a null pointer

[|] [$parray]
[|] [:en] a null pointer

[table:end]
[exit:description]

[/     3[basic.ios.members]{Member functions]/]
[section#basic.ios.members
    [:en] Member functions
]

[%@library tie[!basic_ios]]
[codeblock:declaration]
basic_ostream<charT,traits>* tie() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] An output sequence that is [+tied] to (synchronized with) the sequence
controlled by the stream buffer.
[exit:description]

[%@library tie[!basic_ios]]
[%@library basic_ios[!tie]]
[codeblock:declaration]
basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);
[codeblock:end]

[enter:description]
[para:requires]
[:en] If [`tiestr] is not null, [`tiestr] must not be reachable by traversing
the linked list of tied stream objects starting from [`tiestr->tie()].

[para:postcondition]
[:en] [`tiestr == tie()].

[para:returns]
[:en] The previous value of [`tie()].
[exit:description]

[%@library rdbuf[!basic_ios]]
[codeblock:declaration]
basic_streambuf<charT,traits>* rdbuf() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] A pointer to the [`streambuf] associated with the stream.
[exit:description]

[%@library rdbuf[!basic_ios]]
[%@library basic_ios[!rdbuf]]
[codeblock:declaration]
basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);
[codeblock:end]

[enter:description]
[para:postcondition]
[:en] [`sb == rdbuf()].

[para:effects]
[:en] Calls [`clear()].

[para:returns]
[:en] The previous value of [`rdbuf()].
[exit:description]

[%@library imbue[!basic_ios]]
[codeblock:declaration]
locale imbue(const locale& loc);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`ios_base::imbue(loc)] ([#ios.base.locales]) and if [`rdbuf()!=0]
then [`rdbuf()->pubimbue(loc)] ([#streambuf.locales]).

[para:returns]
[:en] The prior value of [`ios_base::imbue()].
[exit:description]

[%@library narrow[!basic_ios]]
[codeblock:declaration]
char narrow(char_type c, char dfault) const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`use_facet< ctype<char_type> >(getloc()).narrow(c,dfault)]
[exit:description]

[%@library widen[!basic_ios]]
[codeblock:declaration]
char_type widen(char c) const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`use_facet< ctype<char_type> >(getloc()).widen(c)]
[exit:description]

[%@library fill[!basic_ios]]
[codeblock:declaration]
char_type fill() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] The character used to pad (fill) an output conversion to the specified
field width.
[exit:description]

[%@library fill[!basic_ios]]
[%@library basic_ios[!fill]]
[codeblock:declaration]
char_type fill(char_type fillch);
[codeblock:end]

[enter:description]
[para:postcondition]
[:en] [`traits::eq(fillch, fill())]

[para:returns]
[:en] The previous value of [`fill()].
[exit:description]

[%@library copyfmt[!basic_ios]]
[codeblock:declaration]
basic_ios& copyfmt(const basic_ios& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`(this == &rhs)] does nothing.

[:en] Otherwise assigns to the member objects of [`*this] the corresponding
member objects of [`rhs] as follows:

[list:ol@ndot]
[item]
[:en] calls each registered callback pair [`(fn, index)] as
[`(*fn)(erase_event, *this, index)];

[item]
[:en] assigns to the member objects of [`*this] the corresponding member objects
of [`rhs], except that

[list]
[item]
[:en] [`rdstate()], [`rdbuf()], and [`exceptions()] are left unchanged;

[item]
[:en] the contents of arrays pointed at by [`pword] and [`iword] are copied,
not the pointers themselves;

[footnote]
[:en] This suggests an infinite amount of copying, but the implementation can
keep track of the maximum element of the arrays that is non-zero.
[footnote:end]

[:en@~] and

[item]
[:en] if any newly stored pointer values in [`*this] point at objects stored
outside the object [`rhs] and those objects are destroyed when [`rhs] is
destroyed, the newly stored pointer values are altered to point at newly
constructed copies of the objects;
[list:end]

[item]
[:en] calls each callback pair that was copied from [`rhs] as
[`(*fn)(copyfmt_event, *this, index)];

[item]
[:en] calls [`exceptions(rhs.except())].

[list:end]

[para:realnote]
[:en] The second pass through the callback pairs permits a copied [`pword] value
to be zeroed, or to have its referent deep copied or reference counted, or to
have other special action taken.

[para:postconditions]
[:en] The postconditions of this function are indicated in Table
[#tab:iostreams.copyfmt.effects].

[table:listing#tab:iostreams.copyfmt.effects
    [:en] [`basic_ios::copyfmt()] effects
    [columns
        [column@headercenter@code
            [:en] Element
        ]
        [column@headercenter
            [:en] Value
        ]
    ]
    [border:cell@none]
]

[|] rdbuf()
[|] [:en] [em unchanged]

[|] tie()
[|] [`rhs.tie()]

[|] rdstate()
[|] [:en] [em unchanged]

[|] exceptions()
[|] [`rhs.exceptions()]

[|] flags()
[|] [`rhs.flags()]

[|] width()
[|] [`rhs.width()]

[|] precision()
[|] [`rhs.precision()]

[|] fill()
[|] [`rhs.fill()]

[|] getloc()]
[|] [`rhs.getloc()]

[table:end]

[para:returns]
[:en] [`*this].
[exit:description]

[%@library move[!basic_ios]]
[%@library basic_ios[!move]]
[codeblock:declaration]
void move(basic_ios& rhs);
void move(basic_ios&& rhs);
[codeblock:end]

[enter:description]
[para:postconditions]
[:en] [`*this] shall have the state that [`rhs] had before the function call,
except that [`rdbuf()] shall return 0.

[:en] [`rhs] shall be in a valid but unspecified state, except that
[`rhs.rdbuf()] shall return the same value as it returned before the function
call, and [`rhs.tie()] shall return 0.
[exit:description]

[%@library swap[!basic_ios]]
[%@library basic_ios[!swap]]
[codeblock:declaration]
void swap(basic_ios& rhs) noexcept;
[codeblock:end]

[enter:description]
[para:effects]
[:en] The states of [`*this] and [`rhs] shall be exchanged, except that
[`rdbuf()] shall return the same value as it returned before the function call,
and [`rhs.rdbuf()] shall return the same value as it returned before the
function call.
[exit:description]

[%@library set_rdbuf[!basic_ios]]
[%@library basic_ios[!set_rdbuf]]
[codeblock:declaration]
void set_rdbuf(basic_streambuf<charT, traits>* sb);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`sb != nullptr].

[para:effects]
[:en] Associates the [`basic_streambuf] object pointed to by [`sb] with this
stream without calling [`clear()].

[para:postconditions]
[:en] [`rdbuf() == sb].

[para:throws]
[:en] Nothing.
[exit:description]

[/     3[iostate.flags]{[`basic_ios] flags functions]/]
[section#iostate.flags
    [:en] [`basic_ios] flags functions
]

[%@library operator bool[!basic_ios]]
[codeblock:declaration]
explicit operator bool() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`!fail()].
[exit:description]

[%@library operator![!basic_ios]]
[codeblock:declaration]
bool operator!() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`fail()].
[exit:description]

[%@library rdstate[!basic_ios]]
[codeblock:declaration]
iostate rdstate() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] The error state of the stream buffer.
[exit:description]

[%@library clear[!basic_ios]]
[codeblock:declaration]
void clear(iostate state = goodbit);
[codeblock:end]

[enter:description]
[para:postcondition]
[:en] If [`rdbuf()!=0] then [`state == rdstate()]; otherwise
[`rdstate()==(state | ios_base::badbit)].

[para:effects]
[:en] If [`((state | (rdbuf() ? goodbit : badbit)) & exceptions()) == 0],
returns.

[:en] Otherwise, the function throws an object [`fail] of class
[`basic_ios::failure] ([#ios::failure]), constructed with
[%[`basic_ios::failure] argument[!implementation-defined]]
[%@impldef argument values to construct [`basic_ios::failure]]
implementation-defined argument values.
[exit:description]

[%@library setstate[!basic_ios]]
[codeblock:declaration]
void setstate(iostate state);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`clear(rdstate() | state)] (which may throw [`basic_ios::failure]
([#ios::failure])).
[exit:description]

[%@library good[!basic_ios]]
[codeblock:declaration]
bool good() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`rdstate() == 0]
[exit:description]

[%@library eof[!basic_ios]]
[codeblock:declaration]
bool eof() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`true] if [`eofbit] is set in [`rdstate()].
[exit:description]

[%@library fail[!basic_ios]]
[codeblock:declaration]
bool fail() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`true] if [`failbit] or [`badbit] is set in [`rdstate()].

[footnote]
[:en] Checking [`badbit] also for [`fail()] is historical practice.
[footnote:end]
[exit:description]

[%@library bad[!basic_ios]]
[codeblock:declaration]
bool bad() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`true] if [`badbit] is set in [`rdstate()].
[exit:description]

[%@library exceptions[!basic_ios]]
[codeblock:declaration]
iostate exceptions() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] A mask that determines what elements set in [`rdstate()] cause exceptions
to be thrown.
[exit:description]

[%@library exceptions[!basic_ios]]
[%@library basic_ios[!exceptions]]
[codeblock:declaration]
void exceptions(iostate except);
[codeblock:end]

[enter:description]
[para:postcondition]
[:en] [`except == exceptions()].

[para:effects]
[:en] Calls [`clear(rdstate())].
[exit:description]

[/     2[std.ios.manip]{[`ios_base] manipulators]/]
[section#std.ios.manip
    [:en] [`ios_base] manipulators
]

[/     3[fmtflags.manip]{[`fmtflags] manipulators]/]
[section#fmtflags.manip
    [:en] [`fmtflags] manipulators
]

[%@library boolalpha]
[codeblock:declaration]
ios_base& boolalpha(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.setf(ios_base::boolalpha)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library noboolalpha]
[codeblock:declaration]
ios_base& noboolalpha(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.unsetf(ios_base::boolalpha)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library showbase]
[codeblock:declaration]
ios_base& showbase(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.setf(ios_base::showbase)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library noshowbase]
[codeblock:declaration]
ios_base& noshowbase(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.unsetf(ios_base::showbase)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library showpoint]
[codeblock:declaration]
ios_base& showpoint(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.setf(ios_base::showpoint)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library noshowpoint]
[codeblock:declaration]
ios_base& noshowpoint(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.unsetf(ios_base::showpoint)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library showpos]
[codeblock:declaration]
ios_base& showpos(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.setf(ios_base::showpos)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library noshowpos]
[codeblock:declaration]
ios_base& noshowpos(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.unsetf(ios_base::showpos)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library skipws]
[codeblock:declaration]
ios_base& skipws(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.setf(ios_base::skipws)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library noskipws]
[codeblock:declaration]
ios_base& noskipws(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.unsetf(ios_base::skipws)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library uppercase]
[codeblock:declaration]
ios_base& uppercase(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.setf(ios_base::uppercase)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library nouppercase]
[codeblock:declaration]
ios_base& nouppercase(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.unsetf(ios_base::uppercase)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library unitbuf]
[codeblock:declaration]
ios_base& unitbuf(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.setf(ios_base::unitbuf)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library nounitbuf]
[codeblock:declaration]
ios_base& nounitbuf(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.unsetf(ios_base::unitbuf)].

[para:returns]
[:en] [`str].
[exit:description]

[/     3[adjustfield.manip]{[`adjustfield] manipulators]/]
[section#adjustfield.manip
    [:en] [`adjustfield] manipulators
]

[%@library internal]
[codeblock:declaration]
ios_base& internal(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.setf(ios_base::internal, ios_base::adjustfield)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library left]
[codeblock:declaration]
ios_base& left(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.setf(ios_base::left, ios_base::adjustfield)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library right]
[codeblock:declaration]
ios_base& right(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.setf(ios_base::right, ios_base::adjustfield)].

[para:returns]
[:en] [`str].
[exit:description]

[/     3[basefield.manip]{[`basefield] manipulators]/]
[section#basefield.manip
    [:en] [`basefield] manipulators
]

[%@library dec]
[codeblock:declaration]
ios_base& dec(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.setf(ios_base::dec, ios_base::basefield)].

[para:returns]
[:en] [`str]

[footnote]
[:en] The function signature [`dec(ios_base&)] can be called by the function
signature [`basic_ostream& stream::operator<<(ios_base& (*)(ios_base&))] to
permit expressions of the form [`cout << dec] to change the format flags stored
in [`cout].
[footnote:end]

[:en@~] .
[exit:description]

[%@library hex]
[codeblock:declaration]
ios_base& hex(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.setf(ios_base::hex, ios_base::basefield)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library oct]
[codeblock:declaration]
ios_base& oct(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.setf(ios_base::oct, ios_base::basefield)].

[para:returns]
[:en] [`str].
[exit:description]

[/     3[floatfield.manip]{[`floatfield] manipulators]/]
[section#floatfield.manip
    [:en] [`floatfield] manipulators
]

[%@library fixed]
[codeblock:declaration]
ios_base& fixed(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.setf(ios_base::fixed, ios_base::floatfield)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library scientific]
[codeblock:declaration]
ios_base& scientific(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.setf(ios_base::scientific, ios_base::floatfield)].

[para:returns]
[:en] [`str].
[exit:description]

[%@library hexfloat]
[codeblock:declaration]
ios_base& hexfloat(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls
[`str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield)].

[para:returns]
[:en] [`str].
[exit:description]

[para]
[enter:note]
[:en] The more obvious use of [`ios_base::hex] to specify hexadecimal
floating-point format would change the meaning of existing well defined
programs.

[:en] C++2003 gives no meaning to the combination of [`fixed] and [`scientific].
[exit:note]

[%@library defaultfloat]
[codeblock:declaration]
ios_base& defaultfloat(ios_base& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`str.unsetf(ios_base::floatfield)].

[para:returns]
[:en] [`str].
[exit:description]

[/     3[error.reporting]{Error reporting}/]
[section#error.reporting
    [:en] Error reporting
]

[%@library make_error_code]
[codeblock:declaration]
error_code make_error_code(io_errc e) noexcept;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`error_code(static_cast<int>(e), iostream_category())].
[exit:description]

[%@library make_error_condition]
[codeblock:declaration]
error_condition make_error_condition(io_errc e) noexcept;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`error_condition(static_cast<int>(e), iostream_category())].
[exit:description]

[%@library iostream_category]
[codeblock:declaration]
const error_category& iostream_category() noexcept;
[codeblock:end]

[enter:description]
[para:returns]
[:en] A reference to an object of a type derived from class [`error_category].

[para]
[:en] The object[=']s [`default_error_condition] and [`equivalent] virtual
functions shall behave as specified for the class [`error_category].

[:en] The object[=']s [`name] virtual function shall return a pointer to the
string [`"iostream"].
[exit:description]

[/     1[stream.buffers]{Stream buffers]/]
[section#stream.buffers
    [:en] Stream buffers
]

[/     2[stream.buffers.overview]{Overview]/]
[section#stream.buffers.overview
    [:en] Overview
]

[para:synopsis]
[:en] Header [`<streambuf>] synopsis

[%@library <streambuf> [sortas streambuf]]

[%@library streambuf]
[%@library basic_streambuf<char>]
[%@library wstreambuf]
[%@library basic_streambuf<wchar_t>]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT> >
    class basic_streambuf;
  typedef basic_streambuf<char>     streambuf;
  typedef basic_streambuf<wchar_t> wstreambuf;
}
[codeblock:end]

[para]
[:en] The header [`<streambuf>] defines types that control input from and output
to [+character] sequences.

[/     2[streambuf.reqts]{Stream buffer requirements]/]
[section#streambuf.reqts
    [:en] Stream buffer requirements
]

[para]
[:en] Stream buffers can impose various constraints on the sequences they
control.

[:en] Some constraints are:
[list]
[item]
[:en] The controlled input sequence can be not readable.
[item]
[:en] The controlled output sequence can be not writable.
[item]
[:en] The controlled sequences can be associated with the contents of other
representations for character sequences, such as external files.
[item]
[:en] The controlled sequences can support operations [+directly] to or from
associated sequences.
[item]
[:en] The controlled sequences can impose limitations on how the program can
read characters from a sequence, write characters to a sequence, put characters
back into an input sequence, or alter the stream position.
[list:end]

[para]
[:en] Each sequence is characterized by three pointers which, if non-null, all
point into the same [`charT] array object.

[:en] The array object represents, at any moment, a (sub)sequence of characters
from the sequence.

[:en] Operations performed on a sequence alter the values stored in these
pointers, perform reads and writes directly to or from associated sequences, and
alter ["the stream position] and conversion state as needed to maintain this
subsequence relationship.

[:en] The three pointers are:
[list]
[item]
[:en] the [+beginning pointer], or lowest element address in the array (called
[`xbeg] here);
[item]
[:en] the [+next pointer], or next element address that is a current candidate
for reading or writing (called [`xnext] here);
[item]
[:en] the [+end pointer], or first element address beyond the end of the array
(called [`xend] here).
[list:end]

[para]
[:en] The following semantic constraints shall always apply for any set of three
pointers for a sequence, using the pointer names given immediately above:

[list]
[item]
[:en] If [`xnext] is not a null pointer, then [`xbeg] and [`xend] shall also be
non-null pointers into the same [`charT] array, as described above; otherwise,
[`xbeg] and [`xend] shall also be null.

[item]
[:en] If [`xnext] is not a null pointer and [`xnext < xend] for an output
sequence, then a [+write position] is available.

[:en] In this case, [`*xnext] shall be assignable as the next element to write
(to put, or to store a character value, into the sequence).

[item]
[:en] If [`xnext] is not a null pointer and [`xbeg < xnext] for an input
sequence, then a [+putback position] is available.

[:en] In this case, [`xnext[-1`]] shall have a defined value and is the next
(preceding) element to store a character that is put back into the input
sequence.

[item]
[:en] If [`xnext] is not a null pointer and [`xnext < xend] for an input
sequence, then a [+read position] is available.

[:en] In this case, [`*xnext] shall have a defined value and is the next element
to read (to get, or to obtain a character value, from the sequence).
[list:end]

[/     2[streambuf]{Class template [`basic_streambuf<charT,traits>]]/]
[section#streambuf
    [:en] Class template [`basic_streambuf<charT,traits>]
]

[%@library basic_streambuf]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT> >
  class basic_streambuf {
  public:

    // [:en] types:
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;

    virtual ~basic_streambuf();

    // [:en] [#streambuf.locales] locales:
    locale   pubimbue(const locale& loc);
    locale   getloc() const;

    // [:en] [#streambuf.buffer] buffer and positioning:
    basic_streambuf<char_type,traits>*
       pubsetbuf(char_type* s, streamsize n);
    pos_type pubseekoff(off_type off, ios_base::seekdir way,
      ios_base::openmode which =
          ios_base::in | ios_base::out);
    pos_type pubseekpos(pos_type sp,
      ios_base::openmode which =
          ios_base::in | ios_base::out);
    int      pubsync();

    // Get and put areas:
    // [:en] [#streambuf.pub.get] Get area:
    streamsize in_avail();
    int_type snextc();
    int_type sbumpc();
    int_type sgetc();
    streamsize sgetn(char_type* s, streamsize n);

    // [:en] [#streambuf.pub.pback] Putback:
    int_type sputbackc(char_type c);
    int_type sungetc();

    // [:en] [#streambuf.pub.put] Put area:
    int_type   sputc(char_type c);
    streamsize sputn(const char_type* s, streamsize n);

  protected:
    basic_streambuf();
    basic_streambuf(const basic_streambuf& rhs);
    basic_streambuf& operator=(const basic_streambuf& rhs);

    void swap(basic_streambuf& rhs);

    // [:en] [#streambuf.get.area] Get area:
    char_type* eback() const;
    char_type* gptr()  const;
    char_type* egptr() const;
    void       gbump(int n);
    void       setg(char_type* gbeg, char_type* gnext, char_type* gend);

    // [:en] [#streambuf.put.area] Put area:
    char_type* pbase() const;
    char_type* pptr() const;
    char_type* epptr() const;
    void       pbump(int n);
    void       setp(char_type* pbeg, char_type* pend);

    // [:en] [#streambuf.virtuals] virtual functions:
    // [:en] [#streambuf.virt.locales] Locales:
    virtual void imbue(const locale& loc);

    // [:en] [#streambuf.virt.buffer] Buffer management and positioning:
    virtual basic_streambuf<char_type,traits>*
         setbuf(char_type* s, streamsize n);
    virtual pos_type seekoff(off_type off, ios_base::seekdir way,
        ios_base::openmode which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type sp,
        ios_base::openmode which = ios_base::in | ios_base::out);
    virtual int      sync();

    // [:en] [#streambuf.virt.get] Get area:
    virtual streamsize showmanyc();
    virtual streamsize xsgetn(char_type* s, streamsize n);
    virtual int_type   underflow();
    virtual int_type   uflow();

    // [:en] [#streambuf.virt.pback] Putback:
    virtual int_type   pbackfail(int_type c = traits::eof());

    // [:en] [#streambuf.virt.put] Put area:
    virtual streamsize xsputn(const char_type* s, streamsize n);
    virtual int_type   overflow (int_type c = traits::eof());
  };
}
[codeblock:end]

[para]
[:en] The class template [`basic_streambuf<charT,traits>] serves as an abstract
base class for deriving various [+stream buffers] whose objects each control two
[+character sequences]:

[list]
[item]
[:en] a character [+input sequence];
[item]
[:en] a character [+output sequence].
[list:end]

[/     3[streambuf.cons]{[`basic_streambuf] constructors]/]
[section#streambuf.cons
    [:en] [`basic_streambuf] constructors
]

[%@library basic_streambuf[!basic_streambuf]]
[codeblock:declaration]
basic_streambuf();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_streambuf<charT,traits>] and
initializes:

[footnote]
[:en] The default constructor is protected for class [`basic_streambuf] to
assure that only objects for classes derived from this class may be constructed.
[footnote:end]

[list]
[item]
[:en] all its pointer member objects to null pointers,
[item]
[:en] the [`getloc()] member to a copy the global locale, [`locale()], at the
time of construction.
[list:end]

[para:notes]
[:en] Once the [`getloc()] member is initialized, results of calling locale
member functions, and of members of facets so obtained, can safely be cached
until the next time the member [`imbue] is called.
[exit:description]

[%@library basic_streambuf[![:en]constructor]]
[codeblock:declaration]
basic_streambuf(const basic_streambuf& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a copy of [`rhs].

[para:postconditions]

[list]
[item] [`eback() == rhs.eback()]
[item] [`gptr() == rhs.gptr()]
[item] [`egptr() == rhs.egptr()]
[item] [`pbase() == rhs.pbase()]
[item] [`pptr() == rhs.pptr()]
[item] [`epptr() == rhs.epptr()]
[item] [`getloc() == rhs.getloc()]
[list:end]
[exit:description]

[%@library basic_streambuf[![:en]destructor]]
[codeblock:declaration]
~basic_streambuf();
[codeblock:end]

[enter:description]
[para:effects]
[:en] None.
[exit:description]

[/     3[streambuf.members]{[`basic_streambuf] public member functions]/]
[section#streambuf.members
    [:en] [`basic_streambuf] public member functions
]

[/     4[streambuf.locales]{Locales]/]
[section#streambuf.locales
    [:en] Locales
]

[%@library pubimbue[!basic_streambuf]]
[codeblock:declaration]
locale pubimbue(const locale& loc);
[codeblock:end]

[enter:description]
[para:postcondition]
[:en] [`loc == getloc()].

[para:effects]
[:en] Calls [`imbue(loc)].

[para:returns]
[:en] Previous value of [`getloc()].
[exit:description]

[%@library getloc[!basic_streambuf]]
[codeblock:declaration]
locale getloc() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] If [`pubimbue()] has ever been called, then the last value of [`loc]
supplied, otherwise the current global locale, [`locale()], in effect at the
time of construction.

[:en] If called after [`pubimbue()] has been called but before [`pubimbue] has
returned (i.e., from within the call of [`imbue()]) then it returns the previous
value.
[exit:description]

[/     4[streambuf.buffer]{Buffer management and positioning]/]
[section#streambuf.buffer
    [:en] Buffer management and positioning
]

[%@library pubsetbuf[!basic_streambuf]]
[codeblock:declaration]
basic_streambuf<char_type,traits>* pubsetbuf(char_type* s, streamsize n);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`setbuf(s, n)].
[exit:description]

[%@library pubseekoff[!basic_streambuf]]
[codeblock:declaration]
pos_type pubseekoff(off_type off, ios_base::seekdir way,
               ios_base::openmode which = ios_base::in | ios_base::out);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`seekoff(off, way, which)].
[exit:description]

[%@library pubseekpos[!basic_streambuf]]
[codeblock:declaration]
pos_type pubseekpos(pos_type sp,
               ios_base::openmode which = ios_base::in | ios_base::out);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`seekpos(sp, which)].
[exit:description]

[%@library pubsync[!basic_streambuf]]
[codeblock:declaration]
int pubsync();
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`sync()].
[exit:description]

[/     4[streambuf.pub.get]{Get area]/]
[section#streambuf.pub.get
    [:en] Get area
]

[%@library in_avail[!basic_streambuf]]
[codeblock:declaration]
streamsize in_avail();
[codeblock:end]

[enter:description]
[para:returns]
[:en] If a read position is available, returns [`egptr() - gptr()].

[:en] Otherwise returns [`showmanyc()] ([#streambuf.virt.get]).
[exit:description]

[%@library snextc[!basic_streambuf]]
[codeblock:declaration]
int_type snextc();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`sbumpc()].

[para:returns]
[:en] If that function returns [`traits::eof()], returns [`traits::eof()].

[:en] Otherwise, returns [`sgetc()].
[exit:description]

[%@library sbumpc[!basic_streambuf]]
[codeblock:declaration]
int_type sbumpc();
[codeblock:end]

[enter:description]
[para:returns]
[:en] If the input sequence read position is not available, returns [`uflow()].

[:en] Otherwise, returns [`traits::to_int_type(*gptr())] and increments the next
pointer for the input sequence.
[exit:description]

[%@library sgetc[!basic_streambuf]]
[codeblock:declaration]
int_type sgetc();
[codeblock:end]

[enter:description]
[para:returns]
[:en] If the input sequence read position is not available, returns
[`underflow()].

[:en] Otherwise, returns [`traits::to_int_type(*gptr())].
[exit:description]

[%@library sgetn[!basic_streambuf]]
[codeblock:declaration]
streamsize sgetn(char_type* s, streamsize n);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`xsgetn(s, n)].
[exit:description]

[/     4[streambuf.pub.pback]{Putback]/]
[section#streambuf.pub.pback
    [:en] Putback
]

[%@library sputbackc[!basic_streambuf]]
[codeblock:declaration]
int_type sputbackc(char_type c);
[codeblock:end]

[enter:description]
[para:returns]
[:en] If the input sequence putback position is not available, or if
[`traits::eq(c,gptr()[-1`])] is false, returns
[`pbackfail(traits::to_int_type(c))].

[:en] Otherwise, decrements the next pointer for the input sequence and returns
[`traits::to_int_type(*gptr())].
[exit:description]

[%@library sungetc[!basic_streambuf]]
[codeblock:declaration]
int_type sungetc();
[codeblock:end]

[enter:description]
[para:returns]
[:en] If the input sequence putback position is not available, returns
[`pbackfail()].

[:en] Otherwise, decrements the next pointer for the input sequence and returns
[`traits::to_int_type(*gptr())].
[exit:description]

[/     4[streambuf.pub.put]{Put area]/]
[section#streambuf.pub.put
    [:en] Put area
]

[%@library sputc[!basic_streambuf]]
[codeblock:declaration]
int_type sputc(char_type c);
[codeblock:end]

[enter:description]
[para:returns]
[:en] If the output sequence write position is not available, returns
[`overflow(traits::to_int_type(c))].

[:en] Otherwise, stores [`c] at the next pointer for the output sequence,
increments the pointer, and returns [`traits::to_int_type(c)].
[exit:description]

[%@library sputn[!basic_streambuf]]
[codeblock:declaration]
streamsize sputn(const char_type* s, streamsize n);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`xsputn(s,n)].
[exit:description]

[/     3[streambuf.protected]{[`basic_streambuf] protected member functions]/]
[section#streambuf.protected
    [:en] [`basic_streambuf] protected member functions
]

[/     4[streambuf.assign]{Assignment]/]
[section#streambuf.assign
    [:en] Assignment
]

[%@library operator=[!basic_streambuf]]
[%@library basic_streambuf[!operator=]]
[codeblock:declaration]
basic_streambuf& operator=(const basic_streambuf& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Assigns the data members of [`rhs] to [`*this].

[para:postconditions]

[list]
[item] [`eback() == rhs.eback()]
[item] [`gptr() == rhs.gptr()]
[item] [`egptr() == rhs.egptr()]
[item] [`pbase() == rhs.pbase()]
[item] [`pptr() == rhs.pptr()]
[item] [`epptr() == rhs.epptr()]
[item] [`getloc() == rhs.getloc()]
[list:end]

[para:returns]
[:en] [`*this].
[exit:description]

[%@library swap[!basic_streambuf]]
[%@library basic_streambuf[!swap]]
[codeblock:declaration]
void swap(basic_streambuf& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Swaps the data members of [`rhs] and [`*this].
[exit:description]

[/     4[streambuf.get.area]{Get area access]/]
[section#streambuf.get.area
    [:en] Get area access
]

[%@library eback[!basic_streambuf]]
[codeblock:declaration]
char_type* eback() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] The beginning pointer for the input sequence.
[exit:description]

[%@library gptr[!basic_streambuf]]
[codeblock:declaration]
char_type* gptr() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] The next pointer for the input sequence.
[exit:description]

[%@library egptr[!basic_streambuf]]
[codeblock:declaration]
char_type* egptr() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] The end pointer for the input sequence.
[exit:description]

[%@library gbump[!basic_streambuf]]
[codeblock:declaration]
void gbump(int n);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Adds [`n] to the next pointer for the input sequence.
[exit:description]

[%@library setg[!basic_streambuf]]
[codeblock:declaration]
void setg(char_type* gbeg, char_type* gnext, char_type* gend);
[codeblock:end]

[enter:description]
[para:postconditions]
[:en] [`gbeg == eback()], [`gnext == gptr()], and [`gend == egptr()].
[exit:description]

[/     4[streambuf.put.area]{Put area access]/]
[section#streambuf.put.area
    [:en] Put area access
]

[%@library pbase[!basic_streambuf]]
[codeblock:declaration]
char_type* pbase() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] The beginning pointer for the output sequence.
[exit:description]

[%@library pptr[!basic_streambuf]]
[codeblock:declaration]
char_type* pptr() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] The next pointer for the output sequence.
[exit:description]

[%@library epptr[!basic_streambuf]]
[codeblock:declaration]
char_type* epptr() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] The end pointer for the output sequence.
[exit:description]

[%@library pbump[!basic_streambuf]]
[codeblock:declaration]
void pbump(int n);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Adds [`n] to the next pointer for the output sequence.
[exit:description]

[%@library setp[!basic_streambuf]]
[codeblock:declaration]
void setp(char_type* pbeg, char_type* pend);
[codeblock:end]

[enter:description]
[para:postconditions]
[:en] [`pbeg == pbase()], [`pbeg == pptr()], and [`pend == epptr()].
[exit:description]

[/     3[streambuf.virtuals]{[`basic_streambuf] virtual functions]/]
[section#streambuf.virtuals
    [:en] [`basic_streambuf] virtual functions
]

[/     4[streambuf.virt.locales]{Locales]/]
[section#streambuf.virt.locales
    [:en] Locales
]

[%@library imbue[!basic_streambuf]]
[codeblock:declaration]
void imbue(const locale&);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Change any translations based on locale.

[para:notes]
[:en] Allows the derived class to be informed of changes in locale at the time
they occur.

[:en] Between invocations of this function a class derived from streambuf can
safely cache results of calls to locale functions and to members of facets so
obtained.

[para:default]
[:en] Does nothing.
[exit:description]

[/     4[streambuf.virt.buffer]{Buffer management and positioning]/]
[section#streambuf.virt.buffer
    [:en] Buffer management and positioning
]

[%@library setbuf[!basic_streambuf]]
[codeblock:declaration]
basic_streambuf* setbuf(char_type* s, streamsize n);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Influences stream buffering in a way that is defined separately for each
class derived from [`basic_streambuf] in this Clause ([#stringbuf.virtuals],
[#filebuf.virtuals]).

[para:default]
[:en] Does nothing.

[:en] Returns [`this].
[exit:description]

[%@library seekoff[!basic_streambuf]]
[codeblock:declaration]
pos_type seekoff(off_type off, ios_base::seekdir way,
                 ios_base::openmode which
                  = ios_base::in | ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Alters the stream positions within one or more of the controlled sequences
in a way that is defined separately for each class derived from
[`basic_streambuf] in this Clause ([#stringbuf.virtuals], [#filebuf.virtuals]).

[para:default]
[:en] Returns [`pos_type(off_type(-1))].
[exit:description]

[%@library seekpos[!basic_streambuf]]
[codeblock:declaration]
pos_type seekpos(pos_type sp,
                 ios_base::openmode which
                  = ios_base::in | ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Alters the stream positions within one or more of the controlled sequences
in a way that is defined separately for each class derived from
[`basic_streambuf] in this Clause ([#stringbuf], [#filebuf]).

[para:default]
[:en] Returns [`pos_type(off_type(-1))].
[exit:description]

[%@library sync[!basic_streambuf]]
[codeblock:declaration]
int sync();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Synchronizes the controlled sequences with the arrays.

[:en] That is, if [`pbase()] is non-null the characters between [`pbase()] and
[`pptr()] are written to the controlled sequence.

[:en] The pointers may then be reset as appropriate.

[para:returns]
[:en] -1 on failure.

[:en] What constitutes failure is determined by each derived class
([#filebuf.virtuals]).

[para:default]
[:en] Returns zero.
[exit:description]

[/     4[streambuf.virt.get]{Get area]/]
[section#streambuf.virt.get
    [:en] Get area
]

[%@library showmanyc[!basic_streambuf]]
[codeblock:declaration]
streamsize showmanyc();
[codeblock:end]

[footnote]
[:en] The morphemes of [`showmanyc] are ["es-how-many-see], not ["show-manic].
[footnote:end]

[enter:description]
[para:returns]
[:en] An estimate of the number of characters available in the sequence, or -1.

[:en] If it returns a positive value, then successive calls to [`underflow()]
will not return [`traits::eof()] until at least that number of characters have
been extracted from the stream.

[:en] If [`showmanyc()] returns -1, then calls to [`underflow()] or [`uflow()]
will fail.

[footnote]
[:en] [`underflow] or [`uflow] might fail by throwing an exception prematurely.

[:en] The intention is not only that the calls will not return [`eof()] but that
they will return ["immediately.]
[footnote:end]

[para:default]
[:en] Returns zero.

[para:notes]
[:en] Uses [`traits::eof()].
[exit:description]

[%@library xsgetn[!basic_streambuf]]
[codeblock:declaration]
streamsize xsgetn(char_type* s, streamsize n);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Assigns up to [`n] characters to successive elements of the array whose
first element is designated by [`s].

[:en] The characters assigned are read from the input sequence as if by repeated
calls to [`sbumpc()].

[:en] Assigning stops when either [`n] characters have been assigned or a call
to [`sbumpc()] would return [`traits::eof()].

[para:returns]
[:en] The number of characters assigned.

[footnote]
[:en] Classes derived from [`basic_streambuf] can provide more efficient ways to
implement [`xsgetn()] and [`xsputn()] by overriding these definitions from the
base class.
[footnote:end]

[para:notes]
[:en] Uses [`traits::eof()].
[exit:description]

[%@library underflow[!basic_streambuf]]
[codeblock:declaration]
int_type underflow();
[codeblock:end]

[enter:description]
[para:notes]
[:en] The public members of [`basic_streambuf] call this virtual function only
if [`gptr()] is null or [`gptr() >= egptr()]

[para:returns]
[:en] [`traits::to_int_type(c)], where [`c] is the first [+character] of the
[+pending sequence], without moving the input sequence position past it.

[:en] If the pending sequence is null then the function returns [`traits::eof()]
to indicate failure.

[para]
[:en] The [+pending sequence] of characters is defined as the concatenation of:

[list:ol@arparen]
[item]
[:en] If [`gptr()] is non-null, then the [`egptr() - gptr()] characters starting
at [`gptr()], otherwise the empty sequence.
[item]
[:en] Some sequence (possibly empty) of characters read from the input sequence.
[list:end]

[para]
[:en] The [+result character] is

[list:ol@arparen]
[item]
[:en] If the pending sequence is non-empty, the first character of the sequence.
[item]
[:en] If the pending sequence is empty then the next character that would be
read from the input sequence.
[list:end]

[para]
[:en] The [+backup sequence] is defined as the concatenation of:

[list:ol@arparen]
[item]
[:en] If [`eback()] is null then empty,
[item]
[:en] Otherwise the [`gptr() - eback()] characters beginning at [`eback()].
[list:end]

[para:effects]
[:en] The function sets up the [`gptr()] and [`egptr()] satisfying one of:

[list:ol@arparen]
[item]
[:en] If the pending sequence is non-empty, [`egptr()] is non-null and
[`egptr() - gptr()] characters starting at [`gptr()] are the characters in the
pending sequence
[item]
[:en] If the pending sequence is empty, either [`gptr()] is null or [`gptr()]
and [`egptr()] are set to the same non-null pointer value.
[list:end]

[para]
[:en] If [`eback()] and [`gptr()] are non-null then the function is not
constrained as to their contents, but the ["usual backup condition] is that
either:

[list:ol@arparen]
[item]
[:en] If the backup sequence contains at least [`gptr() - eback()] characters,
then the [`gptr() - eback()] characters starting at [`eback()] agree with the
last [`gptr() - eback()] characters of the backup sequence.
[item]
[:en] Or the [`n] characters starting at [`gptr() - n] agree with the backup
sequence (where [`n] is the length of the backup sequence)
[list:end]

[para:default]
[:en] Returns [`traits::eof()].
[exit:description]

[%@library uflow[!basic_streambuf]]
[codeblock:declaration]
int_type uflow();
[codeblock:end]

[enter:description]
[para:requires]
[:en] The constraints are the same as for [`underflow()], except that the result
character shall be transferred from the pending sequence to the backup sequence,
and the pending sequence shall not be empty before the transfer.

[para:default]
[:en] Calls [`underflow()].

[:en] If [`underflow()] returns [`traits::eof()], returns [`traits::eof()].

[:en] Otherwise, returns the value of [`traits::to_int_type(*gptr())] and
increment the value of the next pointer for the input sequence.

[para:returns]
[:en] [`traits::eof()] to indicate failure.
[exit:description]

[/     4[streambuf.virt.pback]{Putback]/]
[section#streambuf.virt.pback
    [:en] Putback
]

[%@library pbackfail[!basic_streambuf]]
[codeblock:declaration]
int_type pbackfail(int_type c = traits::eof());
[codeblock:end]

[enter:description]
[para:notes]
[:en] The public functions of [`basic_streambuf] call this virtual function only
when [`gptr()] is null, [`gptr() == eback()], or
[`traits::eq(traits::to_char_type(c),gptr()[-1`])] returns [`false].

[:en] Other calls shall also satisfy that constraint.

[:en] The [+pending sequence] is defined as for [`underflow()], with the
modifications that

[list]
[item]
[:en] If [`traits::eq_int_type(c,traits::eof())] returns [`true], then the input
sequence is backed up one character before the pending sequence is determined.

[item]
[:en] If [`traits::eq_int_type(c,traits::eof())] returns [`false], then [`c] is
prepended.

[:en] Whether the input sequence is backed up or modified in any other way is
unspecified.
[list:end]

[para:postcondition]
[:en] On return, the constraints of [`gptr()], [`eback()], and [`pptr()] are the
same as for [`underflow()].

[para:returns]
[:en] [`traits::eof()] to indicate failure.

[:en] Failure may occur because the input sequence could not be backed up, or if
for some other reason the pointers could not be set consistent with the
constraints.

[:en] [`pbackfail()] is called only when put back has really failed.

[para]
[:en] Returns some value other than [`traits::eof()] to indicate success.

[para:default]
[:en] Returns [`traits::eof()].
[exit:description]

[/     4[streambuf.virt.put]{Put area]/]
[section#streambuf.virt.put
    [:en] Put area
]

[%@library xsputn[!basic_streambuf]]
[codeblock:declaration]
streamsize xsputn(const char_type* s, streamsize n);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Writes up to [`n] characters to the output sequence as if by repeated
calls to [`sputc(c)].

[:en] The characters written are obtained from successive elements of the array
whose first element is designated by [`s].

[:en] Writing stops when either [`n] characters have been written or a call to
[`sputc(c)] would return [`traits::eof()].

[:en] Is is unspecified whether the function calls [`overflow()] when [`pptr()
== epptr()] becomes true or whether it achieves the same effects by other means.

[para:returns]
[:en] The number of characters written.
[exit:description]

[%@library overflow[!basic_streambuf]]
[codeblock:declaration]
int_type overflow(int_type c = traits::eof());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Consumes some initial subsequence of the characters of the [+pending
sequence].

[:en] The pending sequence is defined as the concatenation of

[list:ol@arparen]
[item]
[:en] if [`pbase()] is null then the empty sequence otherwise,
[`pptr() - pbase()] characters beginning at [`pbase()].

[item]
[:en] if [`traits::eq_int_type(c,traits::eof())] returns [`true], then the empty
sequence otherwise, the sequence consisting of [`c].
[list:end]

[para:notes]
[:en] The member functions [`sputc()] and [`sputn()] call this function in case
that no room can be found in the put buffer enough to accommodate the argument
character sequence.

[para:requires]
[:en] Every overriding definition of this virtual function shall obey the
following constraints:

[list:ol@nrparen]
[item]
[:en] The effect of consuming a character on the associated output sequence is
specified

[footnote]
[:en] That is, for each class derived from an instance of [`basic_streambuf] in
this Clause ([#stringbuf], [#filebuf]), a specification of how consuming a
character effects the associated output sequence is given.

[:en] There is no requirement on a program-defined class.
[footnote:end]

[item]
[:en] Let [`r] be the number of characters in the pending sequence not consumed.

[:en] If [`r] is non-zero then [`pbase()] and [`pptr()] shall be set so that:
[`pptr() - pbase() == r] and the [`r] characters starting at [`pbase()] are the
associated output stream.

[:en] In case [`r] is zero (all characters of the pending sequence have been
consumed) then either [`pbase()] is set to [`nullptr], or [`pbase()] and
[`pptr()] are both set to the same non-null value.

[item]
[:en] The function may fail if either appending some character to the associated
output stream fails or if it is unable to establish [`pbase()] and [`pptr()]
according to the above rules.
[list:end]

[para:returns]
[:en] [`traits::eof()] or throws an exception if the function fails.

[:en] Otherwise, returns some value other than [`traits::eof()] to indicate
success.

[footnote]
[:en] Typically, [`overflow] returns [`c] to indicate success, except when
[`traits::eq_int_type(c,traits::eof())] returns [`true], in which case it
returns [`traits::not_eof(c)].
[footnote:end]

[para:default]
[:en] Returns [`traits::eof()].
[exit:description]

[/     1[iostream.format]{Formatting and manipulators}/]
[section#iostream.format
    [:en] Formatting and manipulators
]

[/     2[iostream.format.overview]{Overview}/]
[section#iostream.format.overview
    [:en] Overview
]

[%@library <istream> [sortas istream]]
[para:synopsis]
[:en] Header [`<istream>] synopsis

[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT> >
    class basic_istream;
  typedef basic_istream<char>     istream;
  typedef basic_istream<wchar_t> wistream;

  template <class charT, class traits = char_traits<charT> >
    class basic_iostream;
  typedef basic_iostream<char>    iostream;
  typedef basic_iostream<wchar_t> wiostream;

  template <class charT, class traits>
    basic_istream<charT,traits>& ws(basic_istream<charT,traits>& is);

  template <class charT, class traits, class T>
    basic_istream<charT, traits>&
    operator>>(basic_istream<charT, traits>&& is, T& x);
}
[codeblock:end]

[%@library istream]
[%@library basic_istream<char>]
[%@library wistream]
[%@library basic_istream<wchar_t>]

[para:synopsis]
[:en] Header [`<ostream>] synopsis

[%@library <ostream> [sortas ostream]]

[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT> >
    class basic_ostream;
  typedef basic_ostream<char>     ostream;
  typedef basic_ostream<wchar_t> wostream;

  template <class charT, class traits>
    basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);
  template <class charT, class traits>
    basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);
  template <class charT, class traits>
    basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);

  template <class charT, class traits, class T>
    basic_ostream<charT, traits>&
    operator<<(basic_ostream<charT, traits>&& os, const T& x);
}
[codeblock:end]

[%@library ostream]
[%@library basic_ostream<char>]
[%@library wostream]
[%@library basic_ostream<wchar_t>]

[para:synopsis]
[:en] Header [`<iomanip>] synopsis

[%@library <iomanip> [sortas iomanip]]

[codeblock:synopsis [special T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 T13] ]
namespace std {
  // [:en] types [`T1], [`T2], ... are unspecified implementation types
  T1 resetiosflags(ios_base::fmtflags mask);
  T2 setiosflags  (ios_base::fmtflags mask);
  T3 setbase(int base);
  template<charT> T4 setfill(charT c);
  T5 setprecision(int n);
  T6 setw(int n);
  template <class moneyT> T7 get_money(moneyT& mon, bool intl = false);
  template <class moneyT> T8 put_money(const moneyT& mon, bool intl = false);
  template <class charT> T9 get_time(struct tm* tmb, const charT* fmt);
  template <class charT> T10 put_time(const struct tm* tmb, const charT* fmt);

  template <class charT>
    T11 quoted(const charT* s, charT delim=charT('"'), charT escape=charT('\\'));

  template <class charT, class traits, class Allocator>
    T12 quoted(const basic_string<charT, traits, Allocator>& s,
               charT delim=charT('"'), charT escape=charT('\\'));

  template <class charT, class traits, class Allocator>
    T13 quoted(basic_string<charT, traits, Allocator>& s,
               charT delim=charT('"'), charT escape=charT('\\'));
}
[codeblock:end]

[/     2[input.streams]{Input streams]/]
[section#input.streams
    [:en] Input streams
]

[para]
[:en] The header [`<istream>] defines two types and a function signature that
control input from a stream buffer along with a function template that extracts
from stream rvalues.

[/     3[istream]{Class template [`basic_istream]]/]
[section#istream
    [:en] Class template [`basic_istream]
]

[%@library basic_istream]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT> >
  class basic_istream : virtual public basic_ios<charT,traits> {
  public:
    // [:en] types (inherited from [`basic_ios] ([#ios])):
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;

    // [:en] [#istream.cons] Constructor/destructor:
    explicit basic_istream(basic_streambuf<charT,traits>* sb);
    virtual ~basic_istream();

    // [:en] [#istream::sentry] Prefix/suffix:
    class sentry;

    // [:en] [#istream.formatted] Formatted input:
    basic_istream<charT,traits>& operator>>(
      basic_istream<charT,traits>& (*pf)(basic_istream<charT,traits>&));
    basic_istream<charT,traits>& operator>>(
			basic_ios<charT,traits>& (*pf)(basic_ios<charT,traits>&));
    basic_istream<charT,traits>& operator>>(
      ios_base& (*pf)(ios_base&));

    basic_istream<charT,traits>& operator>>(bool& n);
    basic_istream<charT,traits>& operator>>(short& n);
    basic_istream<charT,traits>& operator>>(unsigned short& n);
    basic_istream<charT,traits>& operator>>(int& n);
    basic_istream<charT,traits>& operator>>(unsigned int& n);
    basic_istream<charT,traits>& operator>>(long& n);
    basic_istream<charT,traits>& operator>>(unsigned long& n);
    basic_istream<charT,traits>& operator>>(long long& n);
    basic_istream<charT,traits>& operator>>(unsigned long long& n);
    basic_istream<charT,traits>& operator>>(float& f);
    basic_istream<charT,traits>& operator>>(double& f);
    basic_istream<charT,traits>& operator>>(long double& f);

    basic_istream<charT,traits>& operator>>(void*& p);
    basic_istream<charT,traits>& operator>>(
      basic_streambuf<char_type,traits>* sb);

    // [:en] [#istream.unformatted] Unformatted input:
    streamsize gcount() const;
    int_type get();
    basic_istream<charT,traits>& get(char_type& c);
    basic_istream<charT,traits>& get(char_type* s, streamsize n);
    basic_istream<charT,traits>& get(char_type* s, streamsize n,
                                     char_type delim);
    basic_istream<charT,traits>& get(basic_streambuf<char_type,traits>& sb);
    basic_istream<charT,traits>& get(basic_streambuf<char_type,traits>& sb,
                                    char_type delim);

    basic_istream<charT,traits>& getline(char_type* s, streamsize n);
    basic_istream<charT,traits>& getline(char_type* s, streamsize n,
                                         char_type delim);

    basic_istream<charT,traits>& ignore(
      streamsize n = 1, int_type delim = traits::eof());
    int_type                     peek();
    basic_istream<charT,traits>& read    (char_type* s, streamsize n);
    streamsize                   readsome(char_type* s, streamsize n);

    basic_istream<charT,traits>& putback(char_type c);
    basic_istream<charT,traits>& unget();
    int sync();

    pos_type tellg();
    basic_istream<charT,traits>& seekg(pos_type);
    basic_istream<charT,traits>& seekg(off_type, ios_base::seekdir);

  protected:
    basic_istream(const basic_istream& rhs) = delete;
    basic_istream(basic_istream&& rhs);

    // [:en] [#istream.assign] Assign/swap:
    basic_istream& operator=(const basic_istream& rhs) = delete;
    basic_istream& operator=(basic_istream&& rhs);
    void swap(basic_istream& rhs);
  };

  // [:en] [#istream::extractors] character extraction templates:
  template<class charT, class traits>
    basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&,
                                            charT&);
  template<class traits>
    basic_istream<char,traits>& operator>>(basic_istream<char,traits>&,
                                           unsigned char&);
  template<class traits>
    basic_istream<char,traits>& operator>>(basic_istream<char,traits>&,
                                           signed char&);

  template<class charT, class traits>
    basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>&,
                                            charT*);
  template<class traits>
    basic_istream<char,traits>& operator>>(basic_istream<char,traits>&,
                                           unsigned char*);
  template<class traits>
    basic_istream<char,traits>& operator>>(basic_istream<char,traits>&,
                                           signed char*);
}
[codeblock:end]

[para]
[:en] The class [`basic_istream] defines a number of member function signatures
that assist in reading and interpreting input from sequences controlled by a
stream buffer.

[para]
[:en] Two groups of member function signatures share common properties: the
[+formatted input functions] (or [+extractors]) and the [+unformatted input
functions.]

[:en] Both groups of input functions are described as if they obtain (or
[+extract]) input [+characters] by calling [`rdbuf()->sbumpc()] or
[`rdbuf()->sgetc()].

[:en] They may use other public members of [`istream].

[para]
[:en] If [`rdbuf()->sbumpc()] or [`rdbuf()->sgetc()] returns [`traits::eof()],
then the input function, except as explicitly noted otherwise, completes its
actions and does [`setstate(eofbit)], which may throw [`ios_base::failure]
([#iostate.flags]), before returning.

[para]
[:en] If one of these called functions throws an exception, then unless
explicitly noted otherwise, the input function sets [`badbit] in error state.

[:en] If [`badbit] is on in [`exceptions()], the input function rethrows the
exception without completing its actions, otherwise it does not throw anything
and proceeds as if the called function had returned a failure indication.

[/     4[istream.cons]{[`basic_istream] constructors]/]
[section#istream.cons
    [:en] [`basic_istream] constructors
]

[%@library basic_istream[!basic_istream]]
[codeblock:declaration]
explicit basic_istream(basic_streambuf<charT,traits>* sb);
[codeblock:end]

[%@library init[!basic_ios]]
[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_istream], assigning initial values
to the base class by calling [`basic_ios::init(sb)] ([#basic.ios.cons]).

[para:postcondition]
[:en] [`gcount() == 0]
[exit:description]

[%@library basic_istream[![:en]constructor]]
[codeblock:declaration]
basic_istream(basic_istream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move constructs from the rvalue [`rhs].

[:en] This is accomplished by default constructing the base class, copying the
[`gcount()] from [`rhs], calling [`basic_ios<charT, traits>::move(rhs)] to
initialize the base class, and setting the [`gcount()] for [`rhs] to 0.
[exit:description]

[%@library basic_istream[![:en]destructor]]
[codeblock:declaration]
virtual ~basic_istream();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Destroys an object of class [`basic_istream].

[para:notes]
[:en] Does not perform any operations of [`rdbuf()].
[exit:description]

[/     4[istream.assign]{Class [`basic_istream] assign and swap]/]
[section#istream.assign
    [:en] Class [`basic_istream] assign and swap
]

[%@library operator=[!basic_istream]]
[%@library basic_istream[!operator=]]
[codeblock:declaration]
basic_istream& operator=(basic_istream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`swap(rhs);].

[para:returns]
[:en] [`*this].
[exit:description]

[%@library swap[!basic_istream]]
[%@library basic_istream[!swap]]
[codeblock:declaration]
void swap(basic_istream& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`basic_ios<charT, traits>::swap(rhs)].

[:en] Exchanges the values returned by [`gcount()] and [`rhs.gcount()].
[exit:description]

[/     4[istream::sentry]{Class [`basic_istream::sentry]]/]
[section#istream::sentry
    [:en] Class [`basic_istream::sentry]
]

[%@library sentry[!basic_istream]]
[codeblock:synopsis]
namespace std {
  template <class charT,class traits = char_traits<charT> >
  class basic_istream<charT,traits>::sentry {
    typedef traits traits_type;
    bool ok_; // [=Expos]
  public:
    explicit sentry(basic_istream<charT,traits>& is, bool noskipws = false);
    ~sentry();
    explicit operator bool() const { return ok_; }
    sentry(const sentry&) = delete;
    sentry& operator=(const sentry&) = delete;
  };
}
[codeblock:end]

[enter:description]
[para]
[:en] The class [`sentry] defines a class that is responsible for doing
exception safe prefix and suffix operations.
[exit:description]

[%@library sentry[![:en]constructor]]
[codeblock:declaration]
explicit sentry(basic_istream<charT,traits>& is, bool noskipws = false);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`is.good()] is [`false], calls [`is.setstate(failbit)].

[:en] Otherwise, prepares for formatted or unformatted input.

[:en] First, if [`is.tie()] is not a null pointer, the function calls
[%@library flush] [`is.tie()->flush()] to synchronize the output sequence with
any associated external C stream.

[:en] Except that this call can be suppressed if the put area of [`is.tie()]
is empty.

[:en] Further an implementation is allowed to defer the call to [`flush] until a
call of [`is.rdbuf()->underflow()] occurs.

[:en] If no such call occurs before the [`sentry] object is destroyed, the call
to [`flush] may be eliminated entirely.

[footnote]
[:en] This will be possible only in functions that are part of the library.

[:en] The semantics of the constructor used in user code is as specified.
[footnote:end]

[:en] If [`noskipws] is zero and [`is.flags() & ios_base::skipws] is nonzero,
the function extracts and discards each character as long as the next available
input character [`c] is a whitespace character.

[:en] If [`is.rdbuf()->sbumpc()] or [`is.rdbuf()->sgetc()] returns
[`traits::eof()], the function calls [`setstate(failbit | eofbit)] (which may
throw [`ios_base::failure]).

[para:notes]
[:en] The constructor
[`explicit sentry(basic_istream<charT,traits>& is, bool noskipws = false)]
uses the currently imbued locale in [`is], to determine whether the next input
character is whitespace or not.

[para]
[:en] To decide if the character [`c] is a whitespace character, the constructor
performs as if it executes the following code fragment:

[codeblock:notation]
const ctype<charT>& ctype = use_facet<ctype<charT> >(is.getloc());
if (ctype.is(ctype.space,c)!=0)
  // [:en] [`c] is a whitespace character.
[codeblock:end]

[para]
[:en] If, after any preparation is completed, [`is.good()] is [`true],
[`ok_ != false] otherwise, [`ok_ == false].

[:en] During preparation, the constructor may call [`setstate(failbit)] (which
may throw [`ios_base::failure] ([#iostate.flags]))

[footnote]
[:en] The sentry constructor and destructor can also perform additional
[%implementation-dependent] implementation-dependent operations.
[footnote:end]
[exit:description]

[%@library basic_istream[![:en]destructor]]
[codeblock:declaration]
~sentry();
[codeblock:end]

[enter:description]
[para:effects]
[:en] None.
[exit:description]

[%@library operator bool[!basic_istream]]
[codeblock:declaration]
explicit operator bool() const;
[codeblock:end]

[enter:description]
[para:effects]
[:en] Returns [`ok_].
[exit:description]

[/     3[istream.formatted]{Formatted input functions]/]
[section#istream.formatted
    [:en] Formatted input functions
]

[/     4[istream.formatted.reqmts]{Common requirements]/]
[section#istream.formatted.reqmts
    [:en] Common requirements
]

[para]
[:en] Each formatted input function begins execution by constructing an object
of class [`sentry] with the [`noskipws] (second) argument [`false].

[:en] If the [`sentry] object returns [`true], when converted to a value of type
[`bool], the function endeavors to obtain the requested input.

[:en] If an exception is thrown during input then [`ios::badbit] is turned on

[footnote]
[:en] This is done without causing an [`ios::failure] to be thrown.
[footnote:end]

[:en@~] in [`*this][=']s error state.

[:en] If [`(exceptions()&badbit) != 0] then the exception is rethrown.

[:en] In any case, the formatted input function destroys the [`sentry] object.

[:en] If no exception has been thrown, it returns [`*this].

[/     4[istream.formatted.arithmetic]{Arithmetic extractors]/]
[section#istream.formatted.arithmetic
    [:en] Arithmetic extractors
]

[%@library operator>>[!istream]]
[codeblock:declaration]
operator>>(unsigned short& val);
operator>>(unsigned int& val);
operator>>(long& val);
operator>>(unsigned long& val);
operator>>(long long& val);
operator>>(unsigned long long& val);
operator>>(float& val);
operator>>(double& val);
operator>>(long double& val);
operator>>(bool& val);
operator>>(void*& val);
[codeblock:end]

[enter:description]
[para]
[:en] As in the case of the inserters, these extractors depend on the
locale[=']s [`num_get<>] ([#locale.num.get]) object to perform parsing the input
stream data.

[:en] These extractors behave as formatted input functions (as described in
[#istream.formatted.reqmts]).

[:en] After a sentry object is constructed, the conversion occurs as if
performed by the following code fragment:

[codeblock:notation]
typedef num_get< charT,istreambuf_iterator<charT,traits> > numget;
iostate err = iostate::goodbit;
use_facet< numget >(loc).get(*this, 0, *this, err, val);
setstate(err);
[codeblock:end]

[:en] In the above fragment, [`loc] stands for the private member of the
[`basic_ios] class.

[enter:note]
[:en] The first argument provides an object of the [`istreambuf_iterator] class
which is an iterator pointed to an input stream.

[:en] It bypasses istreams and uses streambufs directly.
[exit:note]

[:en] Class [`locale] relies on this type as its interface to [`istream], so
that it does not need to depend directly on [`istream].
[exit:description]

[%@library operator>>[!istream]]
[codeblock:declaration]
operator>>(short& val);
[codeblock:end]

[enter:description]
[para]
[:en] The conversion occurs as if performed by the following code fragment
(using the same notation as for the preceding code fragment):

[codeblock:notation]
typedef num_get<charT,istreambuf_iterator<charT,traits> > numget;
iostate err = ios_base::goodbit;
long lval;
use_facet<numget>(loc).get(*this, 0, *this, err, lval);
if (lval < numeric_limits<short>::min()) {
  err |= ios_base::failbit;
  val = numeric_limits<short>::min();
} else if (numeric_limits<short>::max() < lval) {
  err |= ios_base::failbit;
  val = numeric_limits<short>::max();
}  else
  val = static_cast<short>(lval);
setstate(err);
[codeblock:end]
[exit:description]

[%@library operator>>[!istream]]
[codeblock:declaration]
operator>>(int& val);
[codeblock:end]

[enter:description]
[para]
[:en] The conversion occurs as if performed by the following code fragment
(using the same notation as for the preceding code fragment):

[codeblock:notation]
typedef num_get<charT,istreambuf_iterator<charT,traits> > numget;
iostate err = ios_base::goodbit;
long lval;
use_facet<numget>(loc).get(*this, 0, *this, err, lval);
if (lval < numeric_limits<int>::min()) {
  err |= ios_base::failbit;
  val = numeric_limits<int>::min();
} else if (numeric_limits<int>::max() < lval) {
  err |= ios_base::failbit;
  val = numeric_limits<int>::max();
}  else
  val = static_cast<int>(lval);
setstate(err);
[codeblock:end]
[exit:description]

[/     4[istream::extractors]{[`basic_istream::operator>>]]/]
[section#istream::extractors
    [:en] [`basic_istream::operator>>]
]

[%@library operator>>[!basic_istream]]
[codeblock:declaration]
basic_istream<charT,traits>& operator>>
    (basic_istream<charT,traits>& (*pf)(basic_istream<charT,traits>&));
[codeblock:end]

[enter:description]
[para:effects]
[:en] None.

[:en] This extractor does not behave as a formatted input function (as described
in [#istream.formatted.reqmts].)

[para:returns]
[`pf(*this)].

[footnote]
[:en] See, for example, the function signature [%@library ws]
[`ws(basic_istream&)] ([#istream.manip]).
[footnote:end]
[exit:description]

[%@library operator>>[!istream]]
[codeblock:declaration]
basic_istream<charT,traits>& operator>>
    (basic_ios<charT,traits>& (*pf)(basic_ios<charT,traits>&));
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`pf(*this)].

[:en] This extractor does not behave as a formatted input function (as described
in [#istream.formatted.reqmts]).

[para:returns]
[:en] [`*this].
[exit:description]

[%@library operator>>[!istream]]
[codeblock:declaration]
basic_istream<charT,traits>& operator>>
    (ios_base& (*pf)(ios_base&));
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`pf(*this)].

[footnote]
[:en] See, for example, the function signature [`dec(ios_base&)]
([#basefield.manip]).
[footnote:end]

[:en] This extractor does not behave as a formatted input function (as described
in [#istream.formatted.reqmts]).

[para:returns]
[:en] [`*this].
[exit:description]

[%@library operator>>[!istream]]
[codeblock:declaration]
template<class charT, class traits>
  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>& in,
                                          charT* s);
template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>& in,
                                         unsigned char* s);
template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>& in,
                                         signed char* s);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves like a formatted input member (as described in
[#istream.formatted.reqmts]) of [`in].

[:en] After a [`sentry] object is constructed, [`operator>>] extracts characters
and stores them into successive locations of an array whose first element is
designated by [`s].

[:en] If [`width()] is greater than zero, [`n] is [`width()].

[:en] Otherwise [`n] is the number of elements of the largest array of
[`char_type] that can store a terminating [`charT()].

[:en] [`n] is the maximum number of characters stored.

[para]
[:en] Characters are extracted and stored until any of the following occurs:
[list]
[item]
[:en] [`n-1] characters are stored;
[item]
[:en] end of file occurs on the input sequence;
[item]
[:en] [`ct.is(ct.space,c)] is [`true] for the next available input character
[`c], where [`ct] is [`use_facet<ctype<charT> >(in.getloc())].
[list:end]

[para]
[:en] [`operator>>] then stores a null byte ([`charT()]) in the next position,
which may be the first position if no characters were extracted.

[:en] [`operator>>] then calls [`width(0)].

[para]
[:en] If the function extracted no characters, it calls [`setstate(failbit)],
which may throw [`ios_base::failure] ([#iostate.flags]).

[para:returns]
[:en] [`in].
[exit:description]

[%@library operator>>[!istream]]
[codeblock:declaration]
template<class charT, class traits>
  basic_istream<charT,traits>& operator>>(basic_istream<charT,traits>& in,
                                          charT& c);
template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>& in,
                                         unsigned char& c);
template<class traits>
  basic_istream<char,traits>& operator>>(basic_istream<char,traits>& in,
                                         signed char& c);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves like a formatted input member (as described in
[#istream.formatted.reqmts]) of [`in].

[:en] After a [`sentry] object is constructed a character is extracted from
[`in], if one is available, and stored in [`c].

[:en] Otherwise, the function calls [`in.setstate(failbit)].

[para:returns]
[:en] [`in].
[exit:description]

[%@library operator>>[!istream]]
[codeblock:declaration]
basic_istream<charT,traits>& operator>>
  (basic_streambuf<charT,traits>* sb);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1).

[:en] If [`sb] is null, calls [`setstate(failbit)], which may throw
[`ios_base::failure] ([#iostate.flags]).

[:en] After a sentry object is constructed, extracts characters from [`*this]
and inserts them in the output sequence controlled by [`sb].

[:en] Characters are extracted and inserted until any of the following occurs:

[list]
[item]
[:en] end-of-file occurs on the input sequence;
[item]
[:en] inserting in the output sequence fails (in which case the character to be
inserted is not extracted);
[item]
[:en] an exception occurs (in which case the exception is caught).
[list:end]

[para]
[:en] If the function inserts no characters, it calls [`setstate(failbit)],
which may throw [`ios_base::failure] ([#iostate.flags]).

[:en] If it inserted no characters because it caught an exception thrown while
extracting characters from [`*this] and [`failbit] is on in [`exceptions()]
([#iostate.flags]), then the caught exception is rethrown.

[para:returns]
[:en] [`*this].
[exit:description]

[/     3[istream.unformatted]{Unformatted input functions]/]
[section#istream.unformatted
    [:en] Unformatted input functions
]

[para]
[:en] Each unformatted input function begins execution by constructing an object
of class [`sentry] with the default argument [`noskipws] (second) argument
[`true].

[:en] If the [`sentry] object returns [`true], when converted to a value of type
[`bool], the function endeavors to obtain the requested input.

[:en] Otherwise, if the sentry constructor exits by throwing an exception or if
the sentry object returns false, when converted to a value of type [`bool], the
function returns without attempting to obtain any input.

[:en] In either case the number of extracted characters is set to 0; unformatted
input functions taking a character array of non-zero size as an argument shall
also store a null character (using [`charT()]) in the first location of the
array.

[:en] If an exception is thrown during input then [`ios::badbit] is turned on

[footnote]
[:en] This is done without causing an [`ios::failure] to be thrown.
[footnote:end]

[:en@~] in [`*this][=']s error state.

[:en] (Exceptions thrown from [`basic_ios<>::clear()] are not caught or
rethrown.)

[:en] If [`(exceptions()&badbit) != 0] then the exception is rethrown.

[:en] It also counts the number of characters extracted.

[:en] If no exception has been thrown it ends by storing the count in a member
object and returning the value specified.

[:en] In any event the [`sentry] object is destroyed before leaving the
unformatted input function.

[%@library gcount[!basic_istream]]
[codeblock:declaration]
streamsize gcount() const;
[codeblock:end]

[enter:description]
[para:effects]
[:en] None.

[:en] This member function does not behave as an unformatted input function (as
described in [#istream.unformatted], paragraph 1).

[para:returns]
[:en] The number of characters extracted by the last unformatted input member
function called for the object.
[exit:description]

[%@library get[!basic_istream]]
[codeblock:declaration]
int_type get();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1).

[:en] After constructing a sentry object, extracts a character [`c], if one is
available.

[:en] Otherwise, the function calls [`setstate(failbit)], which may throw
[`ios_base::failure] ([#iostate.flags]),

[para:returns]
[:en] [`c] if available, otherwise [`traits::eof()].
[exit:description]

[%@library get[!basic_istream]]
[%@library basic_istream[!get]]
[codeblock:declaration]
basic_istream<charT,traits>& get(char_type& c);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1).

[:en] After constructing a sentry object, extracts a character, if one is
available, and assigns it to [`c].

[footnote]
[:en] Note that this function is not overloaded on types [`signed char] and
[`unsigned char].
[footnote:end]

[:en] Otherwise, the function calls [`setstate(failbit)] (which may throw
[`ios_base::failure] ([#iostate.flags])).

[para:returns]
[:en] [`*this].
[exit:description]

[%@library get[!basic_istream]]
[%@library basic_istream[!get]]
[codeblock:declaration]
basic_istream<charT,traits>& get(char_type* s, streamsize n,
                  char_type delim );
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1).

[:en] After constructing a sentry object, extracts characters and stores them
into successive locations of an array whose first element is designated by [`s].

[footnote]
[:en] Note that this function is not overloaded on types [`signed char] and
[`unsigned char].
[footnote:end]

[:en] Characters are extracted and stored until any of the following occurs:

[list]
[item]
[:en] [`n] is less than one or [`n - 1] characters are stored;
[item]
[:en] end-of-file occurs on the input sequence (in which case the function calls
[`setstate(eofbit)]);
[item]
[:en] [`traits::eq(c, delim)] for the next available input character [`c] (in
which case [`c] is not extracted).
[list:end]

[para]
[:en] If the function stores no characters, it calls [`setstate(failbit)] (which
may throw [`ios_base::failure] ([#iostate.flags])).

[:en] In any case, if [`n] is greater than zero it then stores a null character
into the next successive location of the array.

[para:returns]
[:en] [`*this].
[exit:description]

[%@library get[!basic_istream]]
[%@library basic_istream[!get]]
[codeblock:declaration]
basic_istream<charT,traits>& get(char_type* s, streamsize n);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`get(s,n,widen('\n'))]

[para:returns]
[:en] Value returned by the call.
[exit:description]

[%@library get[!basic_istream]]
[%@library basic_istream[!get]]
[codeblock:declaration]
basic_istream<charT,traits>& get(basic_streambuf<char_type,traits>& sb,
                  char_type delim );
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1).

[:en] After constructing a sentry object, extracts characters and inserts them
in the output sequence controlled by [`sb].

[:en] Characters are extracted and inserted until any of the following occurs:

[list]
[item]
[:en] end-of-file occurs on the input sequence;
[item]
[:en] inserting in the output sequence fails (in which case the character to be
inserted is not extracted);
[item]
[:en] [`traits::eq(c, delim)] for the next available input character [`c] (in
which case [`c] is not extracted);
[item]
[:en] an exception occurs (in which case, the exception is caught but not
rethrown).
[list:end]

[para]
[:en] If the function inserts no characters, it calls [`setstate(failbit)],
which may throw [`ios_base::failure] ([#iostate.flags]).

[para:returns]
[:en] [`*this].
[exit:description]

[%@library get[!basic_istream]]
[%@library basic_istream[!get]]
[codeblock:declaration]
basic_istream<charT,traits>& get(basic_streambuf<char_type,traits>& sb);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`get(sb, widen('\n'))]

[para:returns]
[:en] Value returned by the call.
[exit:description]

[%@library getline[!basic_istream]]
[codeblock:declaration]
basic_istream<charT,traits>& getline(char_type* s, streamsize n,
                      char_type delim);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1).

[:en] After constructing a sentry object, extracts characters and stores them
into successive locations of an array whose first element is designated by [`s].

[footnote]
[:en] Note that this function is not overloaded on types [`signed char] and
[`unsigned char].
[footnote:end]

[:en] Characters are extracted and stored until one of the following occurs:

[list:ol@ndot]
[item]
[:en] end-of-file occurs on the input sequence (in which case the function calls
[`setstate(eofbit)]);
[item]
[:en] [`traits::eq(c, delim)] for the next available input character [`c] (in
which case the input character is extracted but not stored);

[footnote]
[:en] Since the final input character is ["extracted,] it is counted in the
[`gcount()], even though it is not stored.
[footnote:end]

[item]
[:en] [`n] is less than one or [`n - 1] characters are stored (in which case the
function calls [`setstate(failbit)]).
[list:end]

[para]
[:en] These conditions are tested in the order shown.

[footnote]
[:en] This allows an input line which exactly fills the buffer, without setting
[`failbit].

[:en] This is different behavior than the historical AT&T implementation.
[footnote:end]

[para]
[:en] If the function extracts no characters, it calls [`setstate(failbit)]
(which may throw [`ios_base::failure] ([#iostate.flags])).

[footnote]
[:en] This implies an empty input line will not cause [`failbit] to be set.
[footnote:end]

[para]
[:en] In any case, if [`n] is greater than zero, it then stores a null character
(using [`charT()]) into the next successive location of the array.

[para:returns]
[:en] [`*this].

[para]
[enter:example]
[codeblock]
#include <iostream>

int main() {
  using namespace std;
  const int line_buffer_size = 100;

  char buffer[line_buffer_size];
  int line_number = 0;
  while (cin.getline(buffer, line_buffer_size, '\n') || cin.gcount()) {
    int count = cin.gcount();
    if (cin.eof())
      cout << "Partial final line";   // [:en] [`cin.fail()] is false
    else if (cin.fail()) {
      cout << "Partial long line";
      cin.clear(cin.rdstate() & ~ios_base::failbit);
    } else {
      count--;                        // [:en] Don[=']t include newline in [`count]
      cout << "Line " << ++line_number;
    }
    cout << " (" << count << " chars): " << buffer << endl;
  }
}
[codeblock:end]
[exit:example]
[exit:description]

[%@library getline[!basic_istream]]
[codeblock:declaration]
basic_istream<charT,traits>& getline(char_type* s, streamsize n);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`getline(s,n,widen('\n'))]
[exit:description]

[%@library ignore[!basic_istream]]
[codeblock:declaration]
basic_istream<charT,traits>&
    ignore(streamsize n = 1, int_type delim = traits::eof());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1).

[:en] After constructing a sentry object, extracts characters and discards them.

[:en] Characters are extracted until any of the following occurs:

[list]
[item]
[:en] [`n != numeric_limits<streamsize>::max()] ([#limits]) and [`n] characters
have been extracted so far

[item]
[:en] end-of-file occurs on the input sequence (in which case the function calls
[`setstate(eofbit)], which may throw [`ios_base::failure] ([#iostate.flags]));

[item]
[:en] [`traits::eq_int_type(traits::to_int_type(c), delim)] for the next
available input character [`c] (in which case [`c] is extracted).
[list:end]

[para:notes]
[:en] The last condition will never occur if
[`traits::eq_int_type(delim, traits::eof())].

[para:returns]
[:en] [`*this].
[exit:description]

[%@library peek[!basic_istream]]
[codeblock:declaration]
int_type peek();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1).

[:en] After constructing a sentry object, reads but does not extract the current
input character.

[para:returns]
[:en] [`traits::eof()] if [`good()] is [`false].

[:en] Otherwise, returns [`rdbuf()->sgetc()].
[exit:description]

[%@library read[!basic_istream]]
[codeblock:declaration]
basic_istream<charT,traits>& read(char_type* s, streamsize n);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1).

[:en] After constructing a sentry object, if [`!good()] calls
[`setstate(failbit)] which may throw an exception, and return.

[:en] Otherwise extracts characters and stores them into successive locations of
an array whose first element is designated by [`s].

[footnote]
[:en] Note that this function is not overloaded on types [`signed char] and
[`unsigned char].
[footnote:end]

[:en] Characters are extracted and stored until either of the following occurs:

[list]
[item]
[:en] [`n] characters are stored;
[item]
[:en] end-of-file occurs on the input sequence (in which case the function calls
[`setstate(failbit | eofbit)], which may throw [`ios_base::failure]
([#iostate.flags])).
[list:end]

[para:returns]
[:en] [`*this].
[exit:description]

[%@library readsome[!basic_istream]]
[codeblock:declaration]
streamsize readsome(char_type* s, streamsize n);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1).

[:en] After constructing a sentry object, if [`!good()] calls
[`setstate(failbit)] which may throw an exception, and return.

[:en] Otherwise extracts characters and stores them into successive locations of
an array whose first element is designated by [`s].

[:en] If [`rdbuf()->in_avail() == -1], calls [`setstate(eofbit)] (which may
throw [`ios_base::failure] ([#iostate.flags])), and extracts no characters;

[list]
[item]
[:en] If [`rdbuf()->in_avail() == 0], extracts no characters
[item]
[:en] If [`rdbuf()->in_avail() > 0], extracts [`min(rdbuf()->in_avail(),n))].
[list:end]

[para:returns]
[:en] The number of characters extracted.
[exit:description]

[%@library putback[!basic_istream]]
[codeblock:declaration]
basic_istream<charT,traits>& putback(char_type c);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1), except that the function first clears
[`eofbit].

[:en] After constructing a sentry object, if [`!good()] calls
[`setstate(failbit)] which may throw an exception, and return.

[:en] If [`rdbuf()] is not null, calls [`rdbuf->sputbackc()].

[:en] If [`rdbuf()] is null, or if [`sputbackc()] returns [`traits::eof()],
calls [`setstate(badbit)] (which may throw [`ios_base::failure]
([#iostate.flags])).

[enter:note]
[:en] This function extracts no characters, so the value returned by the next
call to [`gcount()] is 0.
[exit:note]

[para:returns]
[:en] [`*this].
[exit:description]

[%@library unget[!basic_istream]]
[codeblock:declaration]
basic_istream<charT,traits>& unget();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1), except that the function first clears
[`eofbit].

[:en] After constructing a sentry object, if [`!good()] calls
[`setstate(failbit)] which may throw an exception, and return.

[:en] If [`rdbuf()] is not null, calls [`rdbuf()->sungetc()].

[:en] If [`rdbuf()] is null, or if [`sungetc()] returns [`traits::eof()], calls
[`setstate(badbit)] (which may throw [`ios_base::failure] ([#iostate.flags])).

[enter:note]
[:en] This function extracts no characters, so the value returned by the next
call to [`gcount()] is 0.
[exit:note]

[para:returns]
[:en] [`*this].
[exit:description]

[%@library sync[!basic_istream]]
[codeblock:declaration]
int sync();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1), except that it does not count the number
of characters extracted and does not affect the value returned by subsequent
calls to [`gcount()].

[:en] After constructing a sentry object, if [`rdbuf()] is a null pointer,
returns -1.

[:en] Otherwise, calls [`rdbuf()->pubsync()] and, if that function returns -1
calls [`setstate(badbit)] (which may throw [`ios_base::failure]
([#iostate.flags]), and returns [`-1].

[:en] Otherwise, returns zero.
[exit:description]

[%@library tellg[!basic_istream]]
[%@library basic_istream[!tellg]]
[codeblock:declaration]
pos_type tellg();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1), except that it does not count the number
of characters extracted and does not affect the value returned by subsequent
calls to [`gcount()].

[para:returns]
[:en] After constructing a sentry object, if [`fail() != false], returns
[`pos_type(-1)] to indicate failure.

[:en] Otherwise, returns [`rdbuf()->pubseekoff(0, cur, in)].
[exit:description]

[%@library seekg[!basic_istream]]
[%@library basic_istream[!seekg]]
[codeblock:declaration]
basic_istream<charT,traits>& seekg(pos_type pos);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1), except that the function first clears
[`eofbit], it does not count the number of characters extracted, and it does not
affect the value returned by subsequent calls to [`gcount()].

[:en] After constructing a sentry object, if [`fail() != true], executes
[`rdbuf()->pubseekpos(pos, ios_base::in)].

[:en] In case of failure, the function calls [`setstate(failbit)] (which may
throw [`ios_base::failure]).

[para:returns]
[:en] [`*this].
[exit:description]

[%@library get[!basic_istream]]
[%@library basic_istream[!get]]
[codeblock:declaration]
basic_istream<charT,traits>& seekg(off_type off, ios_base::seekdir dir);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1), except that it does not count the number
of characters extracted and does not affect the value returned by subsequent
calls to [`gcount()].

[:en] After constructing a sentry object, if [`fail() != true], executes
[`rdbuf()->pubseekoff(off, dir, ios_base::in)].

[:en] In case of failure, the function calls [`setstate(failbit)] (which may
throw [`ios_base::failure]).

[para:returns]
[:en] [`*this].
[exit:description]

[/     3[istream.manip]{Standard [`basic_istream] manipulators]/]
[section#istream.manip
    [:en] Standard [`basic_istream] manipulators
]

[%@library ws]
[codeblock:declaration]
template <class charT, class traits>
  basic_istream<charT,traits>& ws(basic_istream<charT,traits>& is);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted input function (as described in
[#istream.unformatted], paragraph 1), except that it does not count the number
of characters extracted and does not affect the value returned by subsequent
calls to is.gcount().

[:en] After constructing a sentry object extracts characters as long as the next
available character [`c] is whitespace or until there are no more characters in
the sequence.

[:en] Whitespace characters are distinguished with the same criterion as used by
[`sentry::sentry] ([#istream::sentry]).

[:en] If [`ws] stops extracting characters because there are no more available
it sets [`eofbit], but not [`failbit].

[para:returns]
[:en] [`is].
[exit:description]

[/     3[iostreamclass]{Class template [`basic_iostream]]/]
[section#iostreamclass
    [:en] Class template [`basic_iostream]
]

[%@library basic_iostream]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT> >
  class basic_iostream :
    public basic_istream<charT,traits>,
    public basic_ostream<charT,traits> {
  public:
    // [:en] types:
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;

    // [:en] constructor/destructor
    explicit basic_iostream(basic_streambuf<charT,traits>* sb);
    virtual ~basic_iostream();

  protected:
    basic_iostream(const basic_iostream& rhs) = delete;
    basic_iostream(basic_iostream&& rhs);

    // [:en] assign/swap
    basic_iostream& operator=(const basic_iostream& rhs) = delete;
    basic_iostream& operator=(basic_iostream&& rhs);
    void swap(basic_iostream& rhs);
  };
}
[codeblock:end]

[para]
[:en] The class [`basic_iostream] inherits a number of functions that allow
reading input and writing output to sequences controlled by a stream buffer.

[/     4[iostream.cons]{[`basic_iostream] constructors]/]
[section#iostream.cons
    [:en] [`basic_iostream] constructors
]
[%@library basic_iostream[!basic_iostream]]
[%@library basic_iostream[![:en]constructor]]
[codeblock:declaration]
explicit basic_iostream(basic_streambuf<charT,traits>* sb);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_iostream], assigning initial values
to the base classes by calling [`basic_istream<charT,traits>(sb)] ([#istream])
and [`basic_ostream<charT,traits>(sb)] ([#ostream])

[para:postcondition]
[:en] [`rdbuf()==sb] and [`gcount()==0].
[exit:description]

[%@library basic_iostream[![:en]constructor]]
[codeblock:declaration]
basic_iostream(basic_iostream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move constructs from the rvalue [`rhs] by constructing the
[`basic_istream] base class with [`move(rhs)].
[exit:description]

[/     4[iostream.dest]{[`basic_iostream] destructor]/]
[section#iostream.dest
    [:en] [`basic_iostream] destructor
]

[%@library basic_iostream[![:en]destructor]]
[codeblock:declaration]
virtual ~basic_iostream();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Destroys an object of class
[`basic_iostream].

[para:notes]
[:en] Does not perform any operations on [`rdbuf()].
[exit:description]

[/     4[iostream.assign]{[`basic_iostream] assign and swap]/]
[section#iostream.assign
    [:en] [`basic_iostream] assign and swap
]

[%@library operator=[!basic_iostream]]
[%@library basic_iostream[!operator=]]
[codeblock:declaration]
basic_iostream& operator=(basic_iostream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`swap(rhs)].
[exit:description]

[%@library swap[!basic_iostream]]
[%@library basic_iostream[!swap]]
[codeblock:declaration]
void swap(basic_iostream& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`basic_istream<charT, traits>::swap(rhs)].
[exit:description]

[/     3[istream.rvalue]{Rvalue stream extraction]/]
[section#istream.rvalue
    [:en] Rvalue stream extraction
]

[%@library operator<<[!basic_istream]]
[%@library basic_istream[!operator<<]]
[codeblock:declaration]
template <class charT, class traits, class T>
  basic_istream<charT, traits>&
  operator>>(basic_istream<charT, traits>&& is, T& x);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`is >> x]

[para:returns]
[:en] [`is]
[exit:description]


[/     2[output.streams]{Output streams]/]
[section#output.streams
    [:en] Output streams
]

[para]
[:en] The header [`<ostream>] defines a type and several function signatures
that control output to a stream buffer along with a function template that
inserts into stream rvalues.

[/     3[ostream]{Class template [`basic_ostream]]/]
[section#ostream
    [:en] Class template [`basic_ostream]
]

[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT> >
  class basic_ostream : virtual public basic_ios<charT,traits> {
  public:
    // [:en] types (inherited from [`basic_ios] ([#ios])):
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;

    // [:en] [#ostream.cons] Constructor/destructor:
    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);
    virtual ~basic_ostream();

    // [:en] [#ostream::sentry] Prefix/suffix:
    class sentry;

    // [:en] [#ostream.formatted] Formatted output:
    basic_ostream<charT,traits>& operator<<(
      basic_ostream<charT,traits>& (*pf)(basic_ostream<charT,traits>&));
    basic_ostream<charT,traits>& operator<<(
      basic_ios<charT,traits>& (*pf)(basic_ios<charT,traits>&));
    basic_ostream<charT,traits>& operator<<(
      ios_base& (*pf)(ios_base&));

    basic_ostream<charT,traits>& operator<<(bool n);
    basic_ostream<charT,traits>& operator<<(short n);
    basic_ostream<charT,traits>& operator<<(unsigned short n);
    basic_ostream<charT,traits>& operator<<(int n);
    basic_ostream<charT,traits>& operator<<(unsigned int n);
    basic_ostream<charT,traits>& operator<<(long n);
    basic_ostream<charT,traits>& operator<<(unsigned long n);
    basic_ostream<charT,traits>& operator<<(long long n);
    basic_ostream<charT,traits>& operator<<(unsigned long long n);
    basic_ostream<charT,traits>& operator<<(float f);
    basic_ostream<charT,traits>& operator<<(double f);
    basic_ostream<charT,traits>& operator<<(long double f);

    basic_ostream<charT,traits>& operator<<(const void* p);
    basic_ostream<charT,traits>& operator<<(
      basic_streambuf<char_type,traits>* sb);

    // [:en] [#ostream.unformatted] Unformatted output:
    basic_ostream<charT,traits>& put(char_type c);
    basic_ostream<charT,traits>& write(const char_type* s, streamsize n);

    basic_ostream<charT,traits>& flush();

    // [:en] [#ostream.seeks] seeks:
    pos_type tellp();
    basic_ostream<charT,traits>& seekp(pos_type);
    basic_ostream<charT,traits>& seekp(off_type, ios_base::seekdir);
  protected:
    basic_ostream(const basic_ostream& rhs) = delete;
    basic_ostream(basic_ostream&& rhs);

    // [:en] [#ostream.assign] Assign/swap
    basic_ostream& operator=(const basic_ostream& rhs) = delete;
    basic_ostream& operator=(basic_ostream&& rhs);
    void swap(basic_ostream& rhs);
  };

  // [:en] [#ostream.inserters.character] character inserters
  template<class charT, class traits>
    basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&,
                                            charT);
  template<class charT, class traits>
    basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&,
                                            char);
  template<class traits>
    basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,
                                           char);

  // [:en] signed and unsigned
  template<class traits>
    basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,
                                           signed char);
  template<class traits>
    basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,
                                           unsigned char);

  template<class charT, class traits>
    basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&,
                                            const charT*);
  template<class charT, class traits>
    basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&,
                                            const char*);
  template<class traits>
    basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,
                                           const char*);

  // [:en] signed and unsigned
  template<class traits>
    basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,
                                           const signed char*);
  template<class traits>
    basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&,
                                           const unsigned char*);
}
[codeblock:end]

[para]
[:en] The class [`basic_ostream] defines a number of member function signatures
that assist in formatting and writing output to output sequences controlled by
a stream buffer.

[para]
[:en] Two groups of member function signatures share common properties: the
[+formatted output functions] (or [+inserters]) and the [+unformatted output
functions.]

[:en] Both groups of output functions generate (or [+insert]) output
[+characters] by actions equivalent to calling [`rdbuf()->sputc(int_type)].

[:en] They may use other public members of [`basic_ostream] except that they
shall not invoke any virtual members of [`rdbuf()] except [`overflow()],
[`xsputn()], and [`sync()].

[para]
[:en] If one of these called functions throws an exception, then unless
explicitly noted otherwise the output function sets [`badbit] in error state.

[:en] If [`badbit] is on in [`exceptions()], the output function rethrows the
exception without completing its actions, otherwise it does not throw anything
and treat as an error.

[/     3[ostream.cons]{[`basic_ostream] constructors]/]
[section#ostream.cons
    [:en] [`basic_ostream] constructors
]

[%@library basic_ostream[!basic_ostream]]
[codeblock:declaration]
explicit basic_ostream(basic_streambuf<charT,traits>* sb);
[codeblock:end]

[%@library init[!basic_ios]]
[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_ostream], assigning initial values
to the base class by calling [`basic_ios<charT,traits>::init(sb)]
([#basic.ios.cons]).

[para:postcondition]
[:en] [`rdbuf() == sb].

[%@library basic_ostream[![:en]destructor]]
[codeblock:declaration]
virtual ~basic_ostream();
[codeblock:end]

[para:effects]
[:en] Destroys an object of class [`basic_ostream].

[para:notes]
[:en] Does not perform any operations on [`rdbuf()].
[exit:description]

[%@library basic_ostream[![:en]constructor]]
[codeblock:declaration]
basic_ostream(basic_ostream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move constructs from the rvalue [`rhs].

[:en] This is accomplished by default constructing the base class and calling
[`basic_ios<charT, traits>::move(rhs)] to initialize the base class.
[exit:description]

[/     3[ostream.assign]{Class [`basic_ostream] assign and swap]/]
[section#ostream.assign
    [:en] Class [`basic_ostream] assign and swap
]

[%@library operator=[!basic_ostream]]
[%@library basic_ostream[!operator=]]
[codeblock:declaration]
basic_ostream& operator=(basic_ostream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`swap(rhs)].

[para:returns]
[:en] [`*this].
[exit:description]

[%@library swap[!basic_ostream]]
[%@library basic_ostream[!swap]]
[codeblock:declaration]
void swap(basic_ostream& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`basic_ios<charT, traits>::swap(rhs)].
[exit:description]

[/     3[ostream::sentry]{Class [`basic_ostream::sentry]]/]
[section#ostream::sentry
    [:en] Class [`basic_ostream::sentry]
]

[%@library sentry[!basic_ostream]]
[codeblock:synopsis]
namespace std {
  template <class charT,class traits = char_traits<charT> >
  class basic_ostream<charT,traits>::sentry {
    bool ok_; // [=Expos]
  public:
    explicit sentry(basic_ostream<charT,traits>& os);
    ~sentry();
    explicit operator bool() const { return ok_; }

    sentry(const sentry&) = delete;
    sentry& operator=(const sentry&) = delete;
  };
}
[codeblock:end]

[para]
[:en] The class [`sentry] defines a class that is responsible for doing
exception safe prefix and suffix operations.

[%@library sentry[![:en]constructor]]
[codeblock:declaration]
explicit sentry(basic_ostream<charT,traits>& os);
[codeblock:end]

[enter:description]
[para]
[:en] If [`os.good()] is nonzero, prepares for formatted or unformatted output.

[:en] If [`os.tie()] is not a null pointer, calls [%@library flush]
[`os.tie()->flush()].

[footnote]
[:en] The call [`os.tie()->flush()] does not necessarily occur if the function
can determine that no synchronization is necessary.
[footnote:end]

[para]
[:en] If, after any preparation is completed, [`os.good()] is [`true],
[`ok_ == true] otherwise, [`ok_ == false].

[:en] During preparation, the constructor may call [`setstate(failbit)] (which
may throw [`ios_base::failure] ([#iostate.flags]))

[footnote]
[:en] The [`sentry] constructor and destructor can also perform additional
implementation-dependent operations.
[footnote:end]
[exit:description]

[%@library basic_ostream[![:en]destructor]]
[codeblock:declaration]
~sentry();
[codeblock:end]

[enter:description]
[para]
[:en] If
[`((os.flags() & ios_base::unitbuf) && !uncaught_exception() && os.good())]
is [`true], calls [`os.rdbuf()->pubsync()].

[:en] If that function returns -1, sets [`badbit] in [`os.rdstate()] without
propagating an exception.
[exit:description]

[%@library flush]
[%@library operator bool[!basic_ostream]]
[codeblock:declaration]
explicit operator bool() const;
[codeblock:end]

[enter:description]
[para:effects]
[:en] Returns [`ok_].
[exit:description]

[/     3[ostream.seeks]{[`basic_ostream] seek members]/]
[section#ostream.seeks
    [:en] [`basic_ostream] seek members
]

[para]
[:en] Each seek member function begins execution by constructing an object of
class [`sentry].

[:en] It returns by destroying the [`sentry] object.

[%@library tellp[!basic_ostream]]
[%@library seekp[!basic_ostream]]
[codeblock:declaration]
pos_type tellp();
[codeblock:end]

[enter:description]
[para:returns]
[:en] If [`fail() != false], returns [`pos_type(-1)] to indicate failure.

[:en] Otherwise, returns [`rdbuf()->pubseekoff(0, cur, out)].

[codeblock:declaration]
basic_ostream<charT,traits>& seekp(pos_type pos);
[codeblock:end]

[para:effects]
[:en] If [`fail() != true], executes [`rdbuf()->pubseekpos(pos, ios_base::out)].

[:en] In case of failure, the function calls [`setstate(failbit)] (which may
throw [`ios_base::failure]).

[para:returns]
[:en] [`*this].
[exit:description]

[%@library seekp[!basic_ostream]]
[%@library basic_ostream[!seekp]]
[codeblock:declaration]
basic_ostream<charT,traits>& seekp(off_type off, ios_base::seekdir dir);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`fail() != true], executes
[`rdbuf()->pubseekoff(off, dir, ios_base::out)].

[:en] In case of failure, the function calls [`setstate(failbit)] (which may
throw [`ios_base::failure]).

[para:returns]
[:en] [`*this].
[exit:description]

[/     3[ostream.formatted]{Formatted output functions]/]
[section#ostream.formatted
    [:en] Formatted output functions
]

[/     4[ostream.formatted.reqmts]{Common requirements]/]
[section#ostream.formatted.reqmts
    [:en] Common requirements
]

[para]
[:en] Each formatted output function begins execution by constructing an object
of class [`sentry].

[:en] If this object returns [`true] when converted to a value of type [`bool],
the function endeavors to generate the requested output.

[:en] If the generation fails, then the formatted output function does
[`setstate(ios_base::failbit)], which might throw an exception.

[:en] If an exception is thrown during output, then [`ios::badbit] is turned on

[footnote]
[:en] without causing an [`ios::failure] to be thrown.
[footnote:end]

[:en@~] in [`*this][=']s error state.

[:en] If [`(exceptions()&badbit) != 0] then the exception is rethrown.

[:en] Whether or not an exception is thrown, the [`sentry] object is destroyed
before leaving the formatted output function.

[:en] If no exception is thrown, the result of the formatted output function is
[`*this].

[para]
[:en] The descriptions of the individual formatted output functions describe how
they perform output and do not mention the [`sentry] object.

[para]
[:en] If a formatted output function of a stream [`os] determines padding, it
does so as follows.

[:en] Given a [`charT] character sequence [`seq] where [`charT] is the character
type of the stream, if the length of [`seq] is less than [`os.width()], then
enough copies of [`os.fill()] are added to this sequence as necessary to pad to
a width of [`os.width()] characters.

[:en] If [`(os.flags() & ios_base::adjustfield) == ios_base::left] is [`true],
the fill characters are placed after the character sequence; otherwise, they are
placed before the character sequence.

[/     4[ostream.inserters.arithmetic]{Arithmetic inserters]/]
[section#ostream.inserters.arithmetic
    [:en] Arithmetic inserters
]

[%@library operator<<[!basic_ostream]]
[codeblock:declaration]
operator<<(bool val);
operator<<(short val);
operator<<(unsigned short val);
operator<<(int val);
operator<<(unsigned int val);
operator<<(long val);
operator<<(unsigned long val);
operator<<(long long val);
operator<<(unsigned long long val);
operator<<(float val);
operator<<(double val);
operator<<(long double val);
operator<<(const void* val);
[codeblock:end]

[enter:description]
[para:effects]
[:en] The classes [`num_get<>] and [`num_put<>] handle locale-dependent numeric
formatting and parsing.

[:en] These inserter functions use the imbued [`locale] value to perform numeric
formatting.

[:en] When [`val] is of type [`bool], [`long], [`unsigned long], [`long long],
[`unsigned long long], [`double], [`long double], or [`const void*], the
formatting conversion occurs as if it performed the following code fragment:

[codeblock:notation]
bool failed = use_facet<
  num_put<charT,ostreambuf_iterator<charT,traits> >
    >(getloc()).put(*this, *this, fill(), val).failed();
[codeblock:end]

[:en] When [`val] is of type [`short] the formatting conversion occurs as if it
performed the following code fragment:

[codeblock:notation]
ios_base::fmtflags baseflags = ios_base::flags() & ios_base::basefield;
bool failed = use_facet<
  num_put<charT,ostreambuf_iterator<charT,traits> >
    >(getloc()).put(*this, *this, fill(),
    baseflags == ios_base::oct || baseflags == ios_base::hex
      ? static_cast<long>(static_cast<unsigned short>(val))
      : static_cast<long>(val)).failed();
[codeblock:end]

[:en] When [`val] is of type [`int] the formatting conversion occurs as if it
performed the following code fragment:

[codeblock:notation]
ios_base::fmtflags baseflags = ios_base::flags() & ios_base::basefield;
bool failed = use_facet<
  num_put<charT,ostreambuf_iterator<charT,traits> >
    >(getloc()).put(*this, *this, fill(),
    baseflags == ios_base::oct || baseflags == ios_base::hex
      ? static_cast<long>(static_cast<unsigned int>(val))
      : static_cast<long>(val)).failed();
[codeblock:end]

[:en] When [`val] is of type [`unsigned short] or [`unsigned int] the formatting
conversion occurs as if it performed the following code fragment:

[codeblock:notation]
bool failed = use_facet<
  num_put<charT,ostreambuf_iterator<charT,traits> >
    >(getloc()).put(*this, *this, fill(),
      static_cast<unsigned long>(val)).failed();
[codeblock:end]

[:en] When [`val] is of type [`float] the formatting conversion occurs as if it
performed the following code fragment:

[codeblock:synopsis]
bool failed = use_facet<
  num_put<charT,ostreambuf_iterator<charT,traits> >
    >(getloc()).put(*this, *this, fill(),
      static_cast<double>(val)).failed();
[codeblock:end]

[para]
[:en] The first argument provides an object of the [`ostreambuf_iterator<>]
class which is an iterator for class [`basic_ostream<>].

[:en] It bypasses [`ostream]s and uses [`streambuf]s directly.

[:en] Class [`locale] relies on these types as its interface to iostreams, since
for flexibility it has been abstracted away from direct dependence on
[`ostream].

[:en] The second parameter is a reference to the base subobject of type
[`ios_base].

[:en] It provides formatting specifications such as field width, and a locale
from which to obtain other facets.

[:en] If [`failed] is [`true] then does [`setstate(badbit)], which may throw an
exception, and returns.

[para:returns]
[:en] [`*this].
[exit:description]

[/     4[ostream.inserters]{[`basic_ostream::operator<<]]/]
[section#ostream.inserters
    [:en] [`basic_ostream::operator<<]
]

[%@library operator<<[!basic_ostream]]
[codeblock:declaration]
basic_ostream<charT,traits>& operator<<
    (basic_ostream<charT,traits>& (*pf)(basic_ostream<charT,traits>&));
[codeblock:end]

[enter:description]
[para:effects]
[:en] None.

[:en] Does not behave as a formatted output function (as described in
[#ostream.formatted.reqmts]).

[para:returns]
[:en] [`pf(*this)].

[footnote]
[:en] See, for example, the function signature [%@library endl]
[`endl(basic_ostream&)] ([#ostream.manip]).
[footnote:end]
[exit:description]

[%@library operator<<[!basic_ostream]]
[%@library basic_ostream[!operator<<]]
[codeblock:declaration]
basic_ostream<charT,traits>& operator<<
    (basic_ios<charT,traits>& (*pf)(basic_ios<charT,traits>&));
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`pf(*this)].

[:en] This inserter does not behave as a formatted output function (as described
in [#ostream.formatted.reqmts]).

[para:returns]
[:en] [`*this].

[footnote]
[:en] See, for example, the function signature [%@library dec] [`dec(ios_base&)]
([#basefield.manip]).
[footnote:end]
[exit:description]

[%@library operator<<[!basic_ostream]]
[%@library basic_ostream[!operator<<]]
[codeblock:declaration]
basic_ostream<charT,traits>& operator<<
    (ios_base& (*pf)(ios_base&));
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`pf(*this)].

[:en] This inserter does not behave as a formatted output function (as described
in [#ostream.formatted.reqmts]).

[para:returns]
[:en] [`*this].
[exit:description]

[%@library operator<<[!basic_ostream]]
[%@library basic_ostream[!operator<<]]
[codeblock:declaration]
basic_ostream<charT,traits>& operator<<
    (basic_streambuf<charT,traits>* sb);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted output function (as described in
[#ostream.unformatted], paragraph 1).

[:en] After the sentry object is constructed, if [`sb] is null calls
[`setstate(badbit)] (which may throw [`ios_base::failure]).

[para]
[:en] Gets characters from [`sb] and inserts them in [`*this].

[:en] Characters are read from [`sb] and inserted until any of the following
occurs:

[list]
[item]
[:en] end-of-file occurs on the input sequence;
[item]
[:en] inserting in the output sequence fails (in which case the character to be
inserted is not extracted);
[item]
[:en] an exception occurs while getting a character from [`sb].
[list:end]

[para]
[:en] If the function inserts no characters, it calls [`setstate(failbit)]
(which may throw [`ios_base::failure] ([#iostate.flags])).

[:en] If an exception was thrown while extracting a character, the function sets
[`failbit] in error state, and if [`failbit] is on in [`exceptions()] the caught
exception is rethrown.

[para:returns]
[:en] [`*this].
[exit:description]

[/     4[ostream.inserters.character]{Character inserter function templates]/]
[section#ostream.inserters.character
    [:en] Character inserter function templates
]

[%@library operator<<[!basic_ostream]]
[%@library basic_ostream[!operator<<]]
[codeblock:declaration]
template<class charT, class traits>
  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>& out,
                                          charT c);
template<class charT, class traits>
  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>& out,
                                          char c);
  // [:en] specialization
template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>& out,
                                         char c);
  // [:en] signed and unsigned
template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>& out,
                                         signed char c);
template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>& out,
                                         unsigned char c);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as a formatted output function ([#ostream.formatted.reqmts]) of
[`out].

[:en] Constructs a character sequence [`seq].

[:en] If [`c] has type [`char] and the character type of the stream is not
[`char], then [`seq] consists of [`out.widen(c)]; otherwise [`seq] consists of
[`c].

[:en] Determines padding for [`seq] as described in [#ostream.formatted.reqmts].

[:en] Inserts [`seq] into [`out].

[:en] Calls [`os.width(0)].

[para:returns]
[:en] [`out].
[exit:description]

[%@library operator<<[!basic_ostream]]
[%@library basic_ostream[!operator<<]]
[codeblock:declaration]
template<class charT, class traits>
  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>& out,
                                          const charT* s);
template<class charT, class traits>
  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>& out,
                                          const char* s);
template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>& out,
                                         const char* s);
template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>& out,
                                         const signed char* s);
template<class traits>
  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>& out,
                                         const unsigned char* s);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`s] shall not be a null pointer.

[para:effects]
[:en] Behaves like a formatted inserter (as described in
[#ostream.formatted.reqmts]) of [`out].

[:en] Creates a character sequence [`seq] of [`n] characters starting at [`s],
each widened using [`out.widen()] ([#basic.ios.members]), where [`n] is the
number that would be computed as if by:

[list]
[item]
[:en] [`traits::length(s)] for the overload where the first argument is of type
[`basic_ostream<charT, traits>&] and the second is of type [`const charT*], and
also for the overload where the first argument is of type
[`basic_ostream<char, traits>&] and the second is of type [`const char*],
[item]
[:en] [`std::char_traits<char>::length(s)] for the overload where the first
argument is of type [`basic_ostream<charT, traits>&] and the second is of type
[`const char*],
[item]
[:en] [`traits::length(reinterpret_cast<const char*>(s))] for the other two
overloads.
[list:end]

[:en] Determines padding for [`seq] as described in [#ostream.formatted.reqmts].

[:en] Inserts [`seq] into [`out].

[:en] Calls [`width(0)].

[para:returns]
[:en] [`out].
[exit:description]

[/     3[ostream.unformatted]{Unformatted output functions]/]
[section#ostream.unformatted
    [:en] Unformatted output functions
]

[para]
[:en] Each unformatted output function begins execution by constructing an
object of class [`sentry].

[:en] If this object returns [`true], while converting to a value of type
[`bool], the function endeavors to generate the requested output.

[:en] If an exception is thrown during output, then [`ios::badbit] is turned on

[footnote]
[:en] without causing an [`ios::failure] to be thrown.
[footnote:end]

[:en@~] in [`*this][=']s error state.

[:en] If [`(exceptions() & badbit) != 0] then the exception is rethrown.

[:en] In any case, the unformatted output function ends by destroying the sentry
object, then, if no exception was thrown, returning the value specified for the
unformatted output function.

[%@library put[!basic_ostream]]
[codeblock:declaration]
basic_ostream<charT,traits>& put(char_type c);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted output function (as described in
[#ostream.unformatted], paragraph 1).

[:en] After constructing a sentry object, inserts the character [`c], if
possible.

[footnote]
[:en] Note that this function is not overloaded on types [`signed char] and
[`unsigned char].
[footnote:end]

[para]
[:en] Otherwise, calls [`setstate(badbit)] (which may throw [`ios_base::failure]
([#iostate.flags])).

[para:returns]
[:en] [`*this].
[exit:description]

[%@library write[!basic_ostream]]
[codeblock:declaration]
basic_ostream& write(const char_type* s, streamsize n);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted output function (as described in
[#ostream.unformatted], paragraph 1).

[:en] After constructing a sentry object, obtains characters to insert from
successive locations of an array whose first element is designated by [`s].

[footnote]
[:en] Note that this function is not overloaded on types [`signed char] and
[`unsigned char].
[footnote:end]

[:en] Characters are inserted until either of the following occurs:

[list]
[item]
[:en] [`n] characters are inserted;
[item]
[:en] inserting in the output sequence fails (in which case the function calls
[`setstate(badbit)], which may throw [`ios_base::failure] ([#iostate.flags])).
[list:end]

[para:returns]
[:en] [`*this].
[exit:description]

[%@library flush[!basic_ostream]]
[codeblock:declaration]
basic_ostream& flush();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves as an unformatted output function (as described in
[#ostream.unformatted], paragraph 1).

[:en] If [`rdbuf()] is not a null pointer, constructs a sentry object.

[:en] If this object returns [`true] when converted to a value of type [`bool]
the function calls [`rdbuf()->pubsync()].

[:en] If that function returns -1 calls [`setstate(badbit)] (which may throw
[`ios_base::failure] ([#iostate.flags])).

[:en] Otherwise, if the sentry object returns [`false], does nothing.

[para:returns]
[:en] [`*this].
[exit:description]

[/     3[ostream.manip]{Standard [`basic_ostream] manipulators]/]
[section#ostream.manip
    [:en] Standard [`basic_ostream] manipulators
]

[%@library endl]
[codeblock:declaration]
template <class charT, class traits>
  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`os.put(os.widen('\n'))], then [`os.flush()].

[para:returns]
[:en] [`os].
[exit:description]

[%@library ends]
[codeblock:declaration]
template <class charT, class traits>
  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Inserts a null character into the output sequence: calls
[`os.put(charT())].

[para:returns]
[:en] [`os].
[exit:description]

[%@library flush]
[codeblock:declaration]
template <class charT, class traits>
  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`os.flush()].

[para:returns]
[:en] [`os].
[exit:description]

[/     3[ostream.rvalue]{Rvalue stream insertion]/]
[section#ostream.rvalue
    [:en] Rvalue stream insertion
]

[%@library operator<<[!basic_ostream]]
[%@library basic_ostream[!operator<<]]
[codeblock:declaration]
template <class charT, class traits, class T>
  basic_ostream<charT, traits>&
  operator<<(basic_ostream<charT, traits>&& os, const T& x);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`os << x]

[para:returns]
[:en] [`os]
[exit:description]


[/     2[std.manip]{Standard manipulators]/]
[section#std.manip
    [:en] Standard manipulators
]

[para]
[:en] The header [`<iomanip>] defines several functions that support extractors
and inserters that alter information maintained by class [`ios_base] and its
derived classes.

[%@library resetiosflags]
[codeblock:declaration [special unspecified] ]
unspecified resetiosflags(ios_base::fmtflags mask);
[codeblock:end]

[enter:description]
[para:returns]
[:en] An object of unspecified type such that if [`out] is an object of type
[`basic_ostream<charT, traits>] then the expression
[`out << resetiosflags(mask)] behaves as if it called [`f(out, mask)], or if
[`in] is an object of type [`basic_istream<charT, traits>] then the expression
[`in >> resetiosflags(mask)] behaves as if it called [`f(in, mask)], where the
function [`f] is defined as:

[footnote]
[:en] The expression [`cin >> resetiosflags(ios_base::skipws)] clears
[`ios_base::skipws] in the format flags stored in the
[`basic_istream<charT,traits>] object [`cin] (the same as [`cin >> noskipws]),
and the expression [`cout << resetiosflags(ios_base::showbase)] clears
[`ios_base::showbase] in the format flags stored in the
[`basic_ostream<charT,traits>] object [`cout] (the same as
[`cout << noshowbase]).
[footnote:end]

[codeblock:notation]
void f(ios_base& str, ios_base::fmtflags mask) {
  // [:en] reset specified flags
  str.setf(ios_base::fmtflags(0), mask);
}
[codeblock:end]

[:en] The expression [`out << resetiosflags(mask)] shall have type
[`basic_ostream<charT,traits>&] and value [`out].

[:en] The expression [`in >> resetiosflags(mask)] shall have type
[`basic_istream<charT, traits>&] and value [`in].
[exit:description]

[%@library setiosflags]
[codeblock:declaration [special unspecified] ]
unspecified setiosflags(ios_base::fmtflags mask);
[codeblock:end]

[enter:description]
[para:returns]
[:en] An object of unspecified type such that if [`out] is an object of type
[`basic_ostream<charT, traits>] then the expression [`out << setiosflags(mask)]
behaves as if it called [`f(out, mask)], or if [`in] is an object of type
[`basic_istream<charT, traits>] then the expression [`in >> setiosflags(mask)]
behaves as if it called [`f(in, mask)], where the function [`f] is defined as:

[%@library fmtflags[!ios]]

[codeblock:notation]
void f(ios_base& str, ios_base::fmtflags mask) {
  // [:en] set specified flags
  str.setf(mask);
}
[codeblock:end]

[:en] The expression [`out << setiosflags(mask)] shall have type
[`basic_ostream<charT, traits>&] and value [`out].

[:en] The expression [`in >> setiosflags(mask)] shall have type
[`basic_istream<charT, traits>&] and value [`in].
[exit:description]

[%@library setbase]
[codeblock:declaration [special unspecified] ]
unspecified setbase(int base);
[codeblock:end]

[enter:description]
[para:returns]
[:en] An object of unspecified type such that if [`out] is an object of type
[`basic_ostream<charT, traits>] then the expression [`out << setbase(base)]
behaves as if it called [`f(out, base)], or if [`in] is an object of type
[`basic_istream<charT, traits>] then the expression [`in >> setbase(base)]
behaves as if it called [`f(in, base)], where the function [`f] is defined as:

[codeblock:notation]
void f(ios_base& str, int base) {
  // [:en] set [`basefield]
  str.setf(base ==  8 ? ios_base::oct :
      base == 10 ? ios_base::dec :
      base == 16 ? ios_base::hex :
      ios_base::fmtflags(0), ios_base::basefield);
}
[codeblock:end]

[:en] The expression [`out << setbase(base)] shall have type
[`basic_ostream<charT, traits>&] and value [`out].

[:en] The expression [`in >> setbase(base)] shall have type
[`basic_istream<charT, traits>&] and value [`in].
[exit:description]

[%@library setfill]
[codeblock:declaration [special unspecified] ]
unspecified setfill(char_type c);
[codeblock:end]

[enter:description]
[para:returns]
[:en] An object of unspecified type such that if [`out] is an object of type
[`basic_ostream<charT, traits>] and [`c] has type [`charT] then the expression
[`out << setfill(c)] behaves as if it called [`f(out, c)], where the function
[`f] is defined as:

[codeblock:synopsis]
template<class charT, class traits>
void f(basic_ios<charT,traits>& str, charT c) {
  // [:en] set fill character
  str.fill(c);
}
[codeblock:end]

[:en] The expression [`out << setfill(c)] shall have type
[`basic_ostream<charT, traits>&] and value [`out].
[exit:description]

[%@library setprecision]
[codeblock:declaration [special unspecified] ]
unspecified setprecision(int n);
[codeblock:end]

[enter:description]
[para:returns]
[:en] An object of unspecified type such that if [`out] is an object of type
[`basic_ostream<charT, traits>] then the expression [`out << setprecision(n)]
behaves as if it called [`f(out, n)], or if [`in] is an object of type
[`basic_istream<charT, traits>] then the expression [`in >> setprecision(n)]
behaves as if it called [`f(in, n)], where the function [`f] is defined as:

[codeblock:notation]
void f(ios_base& str, int n) {
  // [:en] set precision
  str.precision(n);
}
[codeblock:end]

[:en] The expression [`out << setprecision(n)] shall have type
[`basic_ostream<charT, traits>&] and value [`out].

[:en] The expression [`in >> setprecision(n)] shall have type
[`basic_istream<charT, traits>&] and value [`in].
[exit:description]

[%@library setw]
[codeblock:declaration [special unspecified] ]
unspecified setw(int n);
[codeblock:end]

[enter:description]
[para:returns]
[:en] An object of unspecified type such that if [`out] is an instance of
[`basic_ostream<charT, traits>] then the expression [`out << setw(n)] behaves as
if it called [`f(out, n)], or if [`in] is an object of type
[`basic_istream<charT, traits>] then the expression [`in >> setw(n)] behaves as
if it called [`f(in, n)], where the function [`f] is defined as:

[codeblock:notation]
void f(ios_base& str, int n) {
  // [:en] set width
  str.width(n);
}
[codeblock:end]

[:en] The expression [`out << setw(n)] shall have type
[`basic_ostream<charT, traits>&] and value [`out].

[:en] The expression [`in >> setw(n)] shall have type
[`basic_istream<charT, traits>&] and value [`in].
[exit:description]

[/     2[ext.manip]{Extended manipulators]/]
[section#ext.manip
    [:en] Extended manipulators
]

[para]
[:en] The header [`<iomanip>] defines several functions that support extractors
and inserters that allow for the parsing and formatting of sequences and values
for money and time.

[%@library get_money]
[codeblock:declaration [special unspecified] ]
template <class moneyT> unspecified get_money(moneyT& mon, bool intl = false);
[codeblock:end]

[enter:description]
[para:requires]
[:en] The type [`moneyT] shall be either [`long double] or a specialization of
the [`basic_string] template (Clause [#strings]).

[para:effects]
[:en] The expression [`in >> get_money(mon, intl)] described below behaves as a
formatted input function ([#istream.formatted.reqmts]).

[para:returns]
[:en] An object of unspecified type such that if [`in] is an object of type
[`basic_istream<charT, traits>] then the expression
[`in >> get_money(mon, intl)] behaves as if it called [`f(in, mon, intl)], where
the function [`f] is defined as:

[codeblock:notation]
template <class charT, class traits, class moneyT>
void f(basic_ios<charT, traits>& str, moneyT& mon, bool intl) {
  typedef istreambuf_iterator<charT, traits> Iter;
  typedef money_get<charT, Iter> MoneyGet;

  ios_base::iostate err = ios_base::goodbit;
  const MoneyGet &mg = use_facet<MoneyGet>(str.getloc());

  mg.get(Iter(str.rdbuf()), Iter(), intl, str, err, mon);

  if (ios_base::goodbit != err)
    str.setstate(err);
}
[codeblock:end]

[:en] The expression [`in >> get_money(mon, intl)] shall have type
[`basic_istream<charT, traits>&] and value [`in].
[exit:description]

[%@library put_money]
[codeblock:declaration [special unspecified] ]
template <class moneyT> unspecified put_money(const moneyT& mon, bool intl = false);
[codeblock:end]

[enter:description]
[para:requires]
[:en] The type [`moneyT] shall be either [`long double] or a specialization of
the [`basic_string] template (Clause [#strings]).

[para:returns]
[:en] An object of unspecified type such that if [`out] is an object of type
[`basic_ostream<charT, traits>] then the expression
[`out << put_money(mon, intl)] behaves as a formatted input function that calls
[`f(out, mon, intl)], where the function [`f] is defined as:

[codeblock:notation]
template <class charT, class traits, class moneyT>
void f(basic_ios<charT, traits>& str, const moneyT& mon, bool intl) {
  typedef ostreambuf_iterator<charT, traits> Iter;
  typedef money_put<charT, Iter> MoneyPut;

  const MoneyPut& mp = use_facet<MoneyPut>(str.getloc());
  const Iter end = mp.put(Iter(str.rdbuf()), intl, str, str.fill(), mon);

  if (end.failed())
    str.setstate(ios::badbit);
}
[codeblock:end]

[:en] The expression [`out << put_money(mon, intl)] shall have type
[`basic_ostream<charT, traits>&] and value [`out].

[exit:description]

[%@library get_time]
[codeblock:declaration [special unspecified] ]
template <class charT> unspecified get_time(struct tm* tmb, const charT* fmt);
[codeblock:end]

[enter:description]
[para:requires]
[:en] The argument [`tmb] shall be a valid pointer to an object of type
[`struct tm], and the argument [`fmt] shall be a valid pointer to an array of
objects of type [`charT] with [`char_traits<charT>::length(fmt)] elements.

[para:returns]
[:en] An object of unspecified type such that if [`in] is an object of type
[`basic_istream<charT, traits>] then the expression [`in >> get_time(tmb, fmt)]
behaves as if it called [`f(in, tmb, fmt)], where the function [`f] is defined
as:

[codeblock:notation]
template <class charT, class traits>
void f(basic_ios<charT, traits>& str, struct tm* tmb, const charT* fmt) {
  typedef istreambuf_iterator<charT, traits> Iter;
  typedef time_get<charT, Iter> TimeGet;

  ios_base::iostate err = ios_base::goodbit;
  const TimeGet& tg = use_facet<TimeGet>(str.getloc());

  tg.get(Iter(str.rdbuf()), Iter(), str, err, tmb,
    fmt, fmt + traits::length(fmt));

  if (err != ios_base::goodbit)
    str.setstate(err):
}
[codeblock:end]

[:en] The expression [`in >> get_time(tmb, fmt)] shall have type
[`basic_istream<charT, traits>&] and value [`in].
[exit:description]

[%@library put_time]
[codeblock:declaration [special unspecified] ]
template <class charT> unspecified put_time(const struct tm* tmb, const charT* fmt);
[codeblock:end]

[enter:description]
[para:requires]
[:en] The argument [`tmb] shall be a valid pointer to an object of type
[`struct tm], and the argument [`fmt] shall be a valid pointer to an array of
objects of type [`charT] with [`char_traits<charT>::length(fmt)] elements.

[para:returns]
[:en] An object of unspecified type such that if [`out] is an object of type
[`basic_ostream<charT, traits>] then the expression [`out << put_time(tmb, fmt)]
behaves as if it called [`f(out, tmb, fmt)], where the function [`f] is defined
as:

[codeblock:notation]
template <class charT, class traits>
void f(basic_ios<charT, traits>& str, const struct tm* tmb, const charT* fmt) {
  typedef ostreambuf_iterator<charT, traits> Iter;
  typedef time_put<charT, Iter> TimePut;

  const TimePut& tp = use_facet<TimePut>(str.getloc());
  const Iter end = tp.put(Iter(str.rdbuf()), str, str.fill(), tmb,
    fmt, fmt + traits::length(fmt));

  if (end.failed())
    str.setstate(ios_base::badbit);
}
[codeblock:end]

[:en] The expression [`out << put_time(tmb, fmt)] shall have type
[`basic_ostream<charT, traits>&] and value [`out].
[exit:description]

[/     2[quoted.manip]{Quoted manipulators]/]
[section#quoted.manip
    [:en] Quoted manipulators
]

[para]
[enter:note]
[:en] Quoted manipulators provide string insertion and extraction of quoted
strings (for example, XML and CSV formats).

[:en] Quoted manipulators are useful in ensuring that the content of a string
with embedded spaces remains unchanged if inserted and then extracted via stream
I/O.
[exit:note]

[%@library quoted]
[codeblock:declaration [special unspecified] ]
template <class charT>
  unspecified quoted(const charT* s, charT delim=charT('"'), charT escape=charT('\\'));
template <class charT, class traits, class Allocator>
  unspecified quoted(const basic_string<charT, traits, Allocator>& s,
                      charT delim=charT('"'), charT escape=charT('\\'));
[codeblock:end]

[enter:description]
[para:returns]
[:en] An object of unspecified type such that if [`out] is an instance of
[`basic_ostream] with member type [`char_type] the same as [`charT] and with
member type [`traits_type], which in the second form is the same as [`traits],
then the expression [`out << quoted(s, delim, escape)] behaves as a formatted
output function ([#ostream.formatted.reqmts]) of [`out].

[:en] This forms a character sequence [`seq], initially consisting of the
following elements:

[list]
[item]
[:en] [`delim].
[item]
[:en] Each character in [`s]. If the character to be output is equal to
[`escape] or [`delim], as determined by [`traits_type::eq], first output
[`escape].
[item]
[:en] [`delim].
[list:end]

[:en] Let [`x] be the number of elements initially in [`seq].

[:en] Then padding is determined for [`seq] as described in
[#ostream.formatted.reqmts], [`seq] is inserted as if by calling
[`out.rdbuf()->sputn(seq, n)], where [`n] is the larger of [`out.width()] and
[`x], and [`out.width(0)] is called.

[:en] The expression [`out << quoted(s, delim, escape)] shall have type
[`basic_ostream<charT, traits>&] and value [`out].
[exit:description]

[%@library quoted]
[codeblock:declaration [special unspecified] ]
template <class charT, class traits, class Allocator>
  unspecified quoted(basic_string<charT, traits, Allocator>& s,
                      charT delim=charT('"'), charT escape=charT('\\'));
[codeblock:end]

[enter:description]
[para:returns]
[:en] An object of unspecified type such that:

[list]
[item]
[:en] If [`in] is an instance of [`basic_istream] with member types [`char_type]
and [`traits_type] the same as [`charT] and [`traits], respectively, then the
expression [`in >> quoted(s, delim, escape)] behaves as if it extracts the
following characters from [`in] using [`basic_istream::operator>>]
([#istream::extractors]) which may throw [`ios_base::failure] ([#ios::failure]):

[list]
[item]
[:en] If the first character extracted is equal to [`delim], as determined by
[`traits_type::eq], then:

[list]
[item]
[:en] Turn off the [`skipws] flag.
[item]
[:en] [`s.clear()]
[item]
[:en] Until an unescaped [`delim] character is reached or [`!in], extract
characters from [`in] and append them to [`s], except that if an [`escape] is
reached, ignore it and append the next character to [`s].
[item]
[:en] Discard the final [`delim] character.
[item]
[:en] Restore the [`skipws] flag to its original value.
[list:end]

[item]
[:en] Otherwise, [`in >> s].
[list:end]

[item]
[:en] If [`out] is an instance of [`basic_ostream] with member types
[`char_type] and [`traits_type] the same as [`charT] and [`traits],
respectively, then the expression [`out << quoted(s, delim, escape)] behaves as
specified for the [`const basic_string<charT, traits, Allocator>&] overload of
the [`quoted] function.
[list:end]

[:en] The expression [`in >> quoted(s, delim, escape)] shall have type
[`basic_istream<charT, traits>&] and value [`in]. The expression
[`out << quoted(s, delim, escape)] shall have type
[`basic_ostream<charT, traits>&] and value [`out].
[exit:description]

[/     1[string.streams]{String-based streams]/]
[section#string.streams
    [:en] String-based streams
]

[/     2[string.streams.overview]{Overview]/]
[section#string.streams.overview
    [:en] Overview
]

[para]
[:en] The header [`<sstream>] defines four class templates and eight types that
associate stream buffers with objects of class [`basic_string],
[%@library basic_string] as described in [#string.classes].

[para:synopsis]
[:en] Header [`<sstream>] synopsis

[%@library <sstream> [sortas sstream]]

[%@library stringbuf]
[%@library basic_stringbuf<char>]
[%@library wstringbuf]
[%@library basic_stringbuf<wchar_t>]
[%@library istringstream]
[%@library basic_istringstream<char>]
[%@library wistringstream]
[%@library basic_istringstream<wchar_t>]
[%@library ostringstream]
[%@library basic_ostringstream<char>]
[%@library wostringstream]
[%@library basic_ostringstream<wchar_t>]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT>,
        class Allocator = allocator<charT> >
    class basic_stringbuf;

  typedef basic_stringbuf<char>     stringbuf;
  typedef basic_stringbuf<wchar_t> wstringbuf;

  template <class charT, class traits = char_traits<charT>,
        class Allocator = allocator<charT> >
    class basic_istringstream;

  typedef basic_istringstream<char>     istringstream;
  typedef basic_istringstream<wchar_t> wistringstream;

  template <class charT, class traits = char_traits<charT>,
        class Allocator = allocator<charT> >
    class basic_ostringstream;
  typedef basic_ostringstream<char>     ostringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;

  template <class charT, class traits = char_traits<charT>,
        class Allocator = allocator<charT> >
    class basic_stringstream;
  typedef basic_stringstream<char>     stringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
}
[codeblock:end]

[/     2[stringbuf]{Class template [`basic_stringbuf]]/]
[section#stringbuf
    [:en] Class template [`basic_stringbuf]
]

[%@library basic_stringbuf]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT>,
      class Allocator = allocator<charT> >
  class basic_stringbuf : public basic_streambuf<charT,traits> {
  public:
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;
    typedef Allocator                 allocator_type;

    // [:en] [#stringbuf.cons] Constructors:
    explicit basic_stringbuf(ios_base::openmode which
                               = ios_base::in | ios_base::out);
    explicit basic_stringbuf
    (const basic_string<charT,traits,Allocator>& str,
     ios_base::openmode which = ios_base::in | ios_base::out);
    basic_stringbuf(const basic_stringbuf& rhs) = delete;
    basic_stringbuf(basic_stringbuf&& rhs);

    // [:en] [#stringbuf.assign] Assign and swap:
    basic_stringbuf& operator=(const basic_stringbuf& rhs) = delete;
    basic_stringbuf& operator=(basic_stringbuf&& rhs);
    void swap(basic_stringbuf& rhs);

    // [:en] [#stringbuf.members] Get and set:
    basic_string<charT,traits,Allocator> str() const;
    void str(const basic_string<charT,traits,Allocator>& s);

  protected:
    // [:en] [#stringbuf.virtuals] Overridden virtual functions:
    virtual int_type   underflow();
    virtual int_type   pbackfail(int_type c = traits::eof());
    virtual int_type   overflow (int_type c = traits::eof());
    virtual  basic_streambuf<charT,traits>* setbuf(charT*, streamsize);


    virtual pos_type seekoff(off_type off, ios_base::seekdir way,
                             ios_base::openmode which
                               = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type sp,
                             ios_base::openmode which
                               = ios_base::in | ios_base::out);

  private:
    ios_base::openmode mode;  // [=Expos]
  };

  template <class charT, class traits, class Allocator>
  void swap(basic_stringbuf<charT, traits, Allocator>& x,
            basic_stringbuf<charT, traits, Allocator>& y);
}
[codeblock:end]

[para]
[:en] The class [`basic_stringbuf] is derived from [`basic_streambuf] to
associate possibly the input sequence and possibly the output sequence with a
sequence of arbitrary [+characters].

[:en] The sequence can be initialized from, or made available as, an object of
class [`basic_string].

[para]
[:en] For the sake of exposition, the maintained data is presented here as:

[list]
[item]
[:en] [`ios_base::openmode mode], has [`in] set if the input sequence can be
read, and [`out] set if the output sequence can be written.
[list:end]

[/     3[stringbuf.cons]{[`basic_stringbuf]  constructors]/]
[section#stringbuf.cons
    [:en] [`basic_stringbuf] constructors
]

[%@library basic_stringbuf[!basic_stringbuf]]
[codeblock:declaration]
explicit basic_stringbuf(ios_base::openmode which =
                         ios_base::in | ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_stringbuf], initializing the base
class with [`basic_streambuf()] ([#streambuf.cons]), and initializing [`mode]
with [`which].

[para:postcondition]
[:en] [`str() == ""].
[exit:description]

[%@library basic_stringbuf[![:en]constructor]]
[codeblock:declaration]
explicit basic_stringbuf(const basic_string<charT,traits,Allocator>& s,
                         ios_base::openmode which = ios_base::in | ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_stringbuf], initializing the base
class with [`basic_streambuf()] ([#streambuf.cons]), and initializing [`mode]
with [`which].

[:en] Then calls [`str(s)].
[exit:description]

[%@library basic_stringbuf[![:en]constructor]]
[codeblock:declaration]
basic_stringbuf(basic_stringbuf&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move constructs from the rvalue [`rhs].

[:en] It is [%@impldef whether sequence pointers are copied by
[`basic_stringbuf] move constructor] implementation-defined whether the sequence
pointers in [`*this] ([`eback()], [`gptr()], [`egptr()], [`pbase()], [`pptr()],
[`epptr()]) obtain the values which [`rhs] had.

[:en] Whether they do or not, [`*this] and [`rhs] reference separate buffers (if
any at all) after the construction.

[:en] The openmode, locale and any other state of [`rhs] is also copied.

[para:postconditions]
[:en] Let [`rhs_p] refer to the state of [`rhs] just prior to this construction
and let [`rhs_a] refer to the state of [`rhs] just after this construction.

[list]
[item] [`str() == rhs_p.str()]
[item] [`gptr() - eback() == rhs_p.gptr() - rhs_p.eback()]
[item] [`egptr() - eback() == rhs_p.egptr() - rhs_p.eback()]
[item] [`pptr() - pbase() == rhs_p.pptr() - rhs_p.pbase()]
[item] [`epptr() - pbase() == rhs_p.epptr() - rhs_p.pbase()]
[item] [`if (eback()) eback() != rhs_a.eback()]
[item] [`if (gptr()) gptr() != rhs_a.gptr()]
[item] [`if (egptr()) egptr() != rhs_a.egptr()]
[item] [`if (pbase()) pbase() != rhs_a.pbase()]
[item] [`if (pptr()) pptr() != rhs_a.pptr()]
[item] [`if (epptr()) epptr() != rhs_a.epptr()]
[list:end]
[exit:description]

[/     3[stringbuf.assign]{Assign and swap]/]
[section#stringbuf.assign
    [:en] Assign and swap
]

[%@library operator=[!basic_stringbuf]]
[%@library basic_stringbuf[!operator=]]
[codeblock:declaration]
basic_stringbuf& operator=(basic_stringbuf&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] After the move assignment [`*this] has the observable state it would
have had if it had been move constructed from [`rhs] (see [#stringbuf.cons]).

[para:returns]
[:en] [`*this].
[exit:description]

[%@library swap[!basic_stringbuf]]
[%@library basic_stringbuf[!swap]]
[codeblock:declaration]
void swap(basic_stringbuf& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Exchanges the state of [`*this] and [`rhs].
[exit:description]

[%@library swap[!basic_stringbuf]]
[%@library basic_stringbuf[!swap]]
[codeblock:declaration]
template <class charT, class traits, class Allocator>
void swap(basic_stringbuf<charT, traits, Allocator>& x,
          basic_stringbuf<charT, traits, Allocator>& y);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`x.swap(y)].
[exit:description]

[/     3[stringbuf.members]{Member functions]/]
[section#stringbuf.members
    [:en] Member functions
]

[%@library str[!basic_stringbuf]]
[codeblock:declaration]
basic_string<charT,traits,Allocator> str() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] A [`basic_string] object whose content is equal to the [`basic_stringbuf]
underlying character sequence.

[:en] If the [`basic_stringbuf] was created only in input mode, the resultant
[`basic_string] contains the character sequence in the range
[=range[eback(),egptr())].

[:en] If the [`basic_stringbuf] was created with [`which & ios_base::out] being
true then the resultant [`basic_string] contains the character sequence in the
range [=range[pbase(),high_mark)], where [`high_mark] represents the position
one past the highest initialized character in the buffer.

[:en] Characters can be initialized by writing to the stream, by constructing
the [`basic_stringbuf] with a [`basic_string], or by calling the
[`str(basic_string)] member function.

[:en] In the case of calling the [`str(basic_string)] member function, all
characters initialized prior to the call are now considered uninitialized
(except for those characters re-initialized by the new [`basic_string]).

[:en] Otherwise the [`basic_stringbuf] has been created in neither input nor
output mode and a zero length [`basic_string] is returned.
[exit:description]

[%@library str[!basic_stringbuf]]
[%@library basic_stringbuf[!str]]
[codeblock:declaration]
void str(const basic_string<charT,traits,Allocator>& s);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Copies the content of [`s] into the [`basic_stringbuf] underlying
character sequence and initializes the input and output sequences according to
[`mode].

[para:postconditions]
[:en] If [`mode & ios_base::out] is true, [`pbase()] points to the first
underlying character and [`epptr() >= pbase() + s.size()] holds; in addition, if
[`mode & ios_base::ate] is true, [`pptr() == pbase() + s.size()] holds,
otherwise [`pptr() == pbase()] is true.

[:en] If [`mode & ios_base::in] is true, [`eback()] points to the first
underlying character, and both [`gptr() == eback()] and
[`egptr() == eback() + s.size()] hold.
[exit:description]

[/     3[stringbuf.virtuals]{Overridden virtual functions]/]
[section#stringbuf.virtuals
    [:en] Overriden virtual functions
]

[%@library underflow[!basic_stringbuf]]
[codeblock:declaration]
int_type underflow();
[codeblock:end]

[enter:description]
[para:returns]
[:en] If the input sequence has a read position available, returns
[`traits::to_int_type(*gptr())].

[:en] Otherwise, returns [`traits::eof()].

[:en] Any character in the underlying buffer which has been initialized is
considered to be part of the input sequence.
[exit:description]

[%@library pbackfail[!basic_stringbuf]]
[codeblock:declaration]
int_type pbackfail(int_type c = traits::eof());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Puts back the character designated by [`c] to the input sequence, if
possible, in one of three ways:

[list]
[item]
[:en] If [`traits::eq_int_type(c,traits::eof())] returns [`false] and if the
input sequence has a putback position available, and if
[`traits::eq(to_char_type(c),gptr()[-1`])] returns [`true], assigns
[`gptr() - 1] to [`gptr()].

[para:~]
[:en] Returns: [`c].

[item]
[:en] If [`traits::eq_int_type(c,traits::eof())] returns [`false] and if the
input sequence has a putback position available, and if [`mode & ios_base::out]
is nonzero, assigns [`c] to [`*--gptr()].

[para:~]
[:en] Returns: [`c].

[item]
[:en] If [`traits::eq_int_type(c,traits::eof())] returns [`true] and if the
input sequence has a putback position available, assigns [`gptr() - 1] to
[`gptr()].

[para:~]
[:en] Returns: [`traits::not_eof(c)].
[list:end]

[para:returns]
[:en] [`traits::eof()] to indicate failure.

[para:notes]
[:en] If the function can succeed in more than one of these ways, it is
[%unspecified] unspecified which way is chosen.
[exit:description]

[%@library overflow[!basic_stringbuf]]
[codeblock:declaration]
int_type overflow(int_type c = traits::eof());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Appends the character designated by [`c] to the output sequence, if
possible, in one of two ways:

[list]
[item]
[:en] If [`traits::eq_int_type(c,traits::eof())] returns [`false] and if either
the output sequence has a write position available or the function makes a write
position available (as described below), the function calls [`sputc(c)].

[para:~]
[:en] Signals success by returning [`c].

[item]
[:en] If [`traits::eq_int_type(c,traits::eof())] returns [`true], there is no
character to append.

[para:~]
[:en] Signals success by returning a value other than [`traits::eof()].
[list:end]

[para:notes]
[:en] The function can alter the number of write positions available as a result
of any call.

[para:returns]
[:en] [`traits::eof()] to indicate failure.

[para]
[:en] The function can make a write position available only if
[`(mode & ios_base::out) != 0].

[:en] To make a write position available, the function reallocates (or initially
allocates) an array object with a sufficient number of elements to hold the
current array object (if any), plus at least one additional write position.

[:en] If [`(mode & ios_base::in) != 0], the function alters the read end pointer
[`egptr()] to point just past the new write position.
[exit:description]

[%@library seekoff[!basic_stringbuf]]
[codeblock:declaration]
pos_type seekoff(off_type off, ios_base::seekdir way,
                 ios_base::openmode which
                   = ios_base::in | ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Alters the stream position within one of the controlled sequences, if
possible, as indicated in Table [#tab:iostreams.seekoff.positioning].

[table:listing#tab:iostreams.seekoff.positioning
    [:en] [`seekoff] positioning
    [columns
        [column#headercenter
            [:en] Conditions
        ]
        [column#headercenter
            [:en] Result
        ]
    ]
    [border:row@both
]

[|] [`(which & ios_base::in) == ios_base::in]
[|] [:en] positions the input sequence

[|] [`(which & ios_base::out) == ios_base::out]
[|] [:en] positions the output sequence

[|]
[`(which & (ios_base::in | ios_base::out)) == (ios_base::in) | ios_base::out))]
    [br]
    [:en] and [`way ==] either [`ios_base::beg] or [`ios_base::end]
[|] [:en] positions both the input and the output sequences

[|] [:en] Otherwise
[|] [:en] the positioning operation fails.

[table:end]

[para]
[:en] For a sequence to be positioned, if its next pointer (either [`gptr()] or
[`pptr()]) is a null pointer and the new offset [`newoff] is nonzero, the
positioning operation fails.

[:en] Otherwise, the function determines [`newoff] as indicated in Table
[#tab:iostreams.newoff.values].

[table:listing#tab:iostreams.newoff.values
    [:en] [`newoff] values
    [columns
        [column#headercenter@code
            [:en] Condition
        ]
        [column#headercenter
            [:en] [`newoff] Value
        ]
    ]
    [border:row@both
]

[|] way == ios_base::beg
[|] 0

[|] way == ios_base::cur
[|] [:en] the next pointer minus the beginning pointer ([`xnext - xbeg]).

[|] way == ios_base::end
[|] [:en] the high mark pointer minus the beginning pointer
    ([`high_mark - xbeg]).

[table:end]

[para]
[:en] If [`(newoff + off) < 0], or if [`newoff + off] refers to an uninitialized
character (as defined in [#stringbuf.members] paragraph 1), the positioning
operation fails.

[:en] Otherwise, the function assigns [`xbeg + newoff + off] to the next pointer
[`xnext].

[para:returns]
[:en] [`pos_type(newoff)], constructed from the resultant offset [`newoff] (of
type [`off_type]), that stores the resultant stream position, if possible.

[:en] If the positioning operation fails, or if the constructed object cannot
represent the resultant stream position, the return value is
[`pos_type(off_type(-1))].
[exit:description]

[%@library seekpos[!basic_stringbuf]]
[codeblock:declaration]
pos_type seekpos(pos_type sp, ios_base::openmode which
                   = ios_base::in | ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Equivalent to [`seekoff(off_type(sp), ios_base::beg, which)].

[para:returns]
[:en] [`sp] to indicate success, or [`pos_type(off_type(-1))] to indicate
failure.
[exit:description]

[%@library setbuf[!basic_streambuf]]
[%@library basic_streambuf[!setbuf]]
[codeblock:declaration]
basic_streambuf<charT,traits>* setbuf(charT* s, streamsize n);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [%implementation-defined] [%@impldef effect of calling
[`basic_streambuf::setbuf] with non-zero arguments] implementation-defined,
except that [`setbuf(0,0)] has no effect.

[para:returns]
[:en] [`this].
[exit:description]

[/     2[istringstream]{Class template [`basic_istringstream]]/]
[section#istringstream
    [:en] Class template [`basic_istringstream]
]

[%@library basic_istringstream]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT>,
        class Allocator = allocator<charT> >
  class basic_istringstream : public basic_istream<charT,traits> {
  public:
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;
    typedef Allocator                 allocator_type;

    // [:en] [#istringstream.cons] Constructors:
    explicit basic_istringstream(ios_base::openmode which = ios_base::in);
    explicit basic_istringstream(
               const basic_string<charT,traits,Allocator>& str,
               ios_base::openmode which = ios_base::in);
    basic_istringstream(const basic_istringstream& rhs) = delete;
    basic_istringstream(basic_istringstream&& rhs);

    // [:en] [#istringstream.assign] Assign and swap:
    basic_istringstream& operator=(const basic_istringstream& rhs) = delete;
    basic_istringstream& operator=(basic_istringstream&& rhs);
    void swap(basic_istringstream& rhs);

    // [:en] [#istringstream.members] Members:
    basic_stringbuf<charT,traits,Allocator>* rdbuf() const;

    basic_string<charT,traits,Allocator> str() const;
    void str(const basic_string<charT,traits,Allocator>& s);
  private:
    basic_stringbuf<charT,traits,Allocator> sb; // [=Expos]
  };

  template <class charT, class traits, class Allocator>
  void swap(basic_istringstream<charT, traits, Allocator>& x,
            basic_istringstream<charT, traits, Allocator>& y);
}
[codeblock:end]

[para]
[:en] The class [`basic_istringstream<charT, traits, Allocator>] supports
reading objects of class [`basic_string<charT, traits, Allocator>].

[:en] It uses a [`basic_stringbuf<charT, traits, Allocator>] object to control
the associated storage.

[:en] For the sake of exposition, the maintained data is presented here as:

[list]
[item]
[:en] [`sb], the [`stringbuf] object.
[list:end]

[/     3[istringstream.cons]{[`basic_istringstream] constructors]/]
[section#istringstream.cons
    [:en] [`basic_istringstream] constructors
]

[%@library basic_istringstream[!basic_istringstream]]
[codeblock:declaration]
explicit basic_istringstream(ios_base::openmode which = ios_base::in);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_istringstream<charT, traits>],
initializing the base class with [`basic_istream(&sb)] and initializing [`sb]
with [`basic_stringbuf<charT, traits, Allocator>(which | ios_base::in))]
([#stringbuf.cons]).
[exit:description]

[%@library basic_istringstream[![:en]constructor]]
[codeblock:declaration]
explicit basic_istringstream(
                const basic_string<charT, traits, Allocator>& str,
                ios_base::openmode which = ios_base::in);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_istringstream<charT, traits>],
initializing the base class with [`basic_istream(&sb)] and initializing [`sb]
with [`basic_stringbuf<charT, traits, Allocator>(str, which | ios_base::in))]
([#stringbuf.cons]).
[exit:description]

[%@library basic_istringstream[![:en]constructor]]
[codeblock:declaration]
basic_istringstream(basic_istringstream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move constructs from the rvalue [`rhs].

[:en] This is accomplished by move constructing the base class, and the
contained [`basic_stringbuf].

[:en] Next [`basic_istream<charT,traits>::set_rdbuf(&sb)] is called to install
the contained [`basic_stringbuf].
[exit:description]

[/     3[istringstream.assign]{Assign and swap]/]
[section#istringstream.assign
    [:en] Assign and swap
]

[%@library operator=[!basic_istringstream]]
[%@library basic_istringstream[!operator=]]
[codeblock:declaration]
basic_istringstream& operator=(basic_istringstream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move assigns the base and members of [`*this] from the base and
corresponding members of [`rhs].

[para:returns]
[:en] [`*this].
[exit:description]

[%@library swap[!basic_istringstream]]
[%@library basic_istringstream[!swap]]
[codeblock:declaration]
void swap(basic_istringstream& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Exchanges the state of [`*this] and [`rhs] by calling
[`basic_istream<charT,traits>::swap(rhs)] and [`sb.swap(rhs.sb)].
[exit:description]


[%@library swap[!basic_istringstream]]
[%@library basic_istringstream[!swap]]
[codeblock:declaration]
template <class charT, class traits, class Allocator>
void swap(basic_istringstream<charT, traits, Allocator>& x,
          basic_istringstream<charT, traits, Allocator>& y);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`x.swap(y)].
[exit:description]

[/     3[istringstream.members]{Member functions]/]
[section#istringstream.members
    [:en] Member functions
]

[%@library rdbuf[!basic_istringstream]]
[codeblock:declaration]
basic_stringbuf<charT,traits,Allocator>* rdbuf() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`const_cast<basic_stringbuf<charT,traits,Allocator>*>(&sb)].
[exit:description]

[%@library str[!basic_istringstream]]
[codeblock:declaration]
basic_string<charT,traits,Allocator> str() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`rdbuf()->str()].
[exit:description]

[%@library str[!basic_istringstream]]
[%@library basic_istringstream[!str]]
[codeblock:declaration]
void str(const basic_string<charT,traits,Allocator>& s);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`rdbuf()->str(s)].
[exit:description]

[/     2[ostringstream]{Class template [`basic_ostringstream]]/]
[section#ostringstream
    [:en] Class template [`basic_ostringstream]
]

[%@library basic_ostringstream]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT>,
        class Allocator = allocator<charT> >
  class basic_ostringstream : public basic_ostream<charT,traits> {
  public:

    // [:en] types:
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;
    typedef Allocator                 allocator_type;

    // [:en] [#ostringstream.cons] Constructors/destructor:
    explicit basic_ostringstream(ios_base::openmode which = ios_base::out);
    explicit basic_ostringstream(
             const basic_string<charT,traits,Allocator>& str,
             ios_base::openmode which = ios_base::out);
    basic_ostringstream(const basic_ostringstream& rhs) = delete;
    basic_ostringstream(basic_ostringstream&& rhs);

    // [:en] [#ostringstream.assign] Assign/swap:
    basic_ostringstream& operator=(const basic_ostringstream& rhs) = delete;
    basic_ostringstream& operator=(basic_ostringstream&& rhs);
    void swap(basic_ostringstream& rhs);

    // [:en] [#ostringstream.members] Members:
    basic_stringbuf<charT,traits,Allocator>* rdbuf() const;

    basic_string<charT,traits,Allocator> str() const;
    void    str(const basic_string<charT,traits,Allocator>& s);
   private:
    basic_stringbuf<charT,traits,Allocator> sb; // [=Expos]
  };

  template <class charT, class traits, class Allocator>
  void swap(basic_ostringstream<charT, traits, Allocator>& x,
            basic_ostringstream<charT, traits, Allocator>& y);
}
[codeblock:end]

[para]
[:en] The class [`basic_ostringstream<charT, traits, Allocator>] supports
writing objects of class [`basic_string<charT, traits, Allocator>].

[:en] It uses a [`basic_stringbuf] object to control the associated storage.

[:en] For the sake of exposition, the maintained data is presented here as:

[list]
[item]
[:en] [`sb], the [`stringbuf] object.
[list:end]

[/     3[ostringstream.cons]{[`basic_ostringstream] constructors]/]
[section#ostringstream.cons
    [:en] [`basic_ostringstream] constructors
]

[%@library basic_ostringstream[!basic_ostringstream]]
[codeblock:declaration]
explicit basic_ostringstream(ios_base::openmode which = ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_ostringstream], initializing the
base class with [`basic_ostream(&sb)] and initializing [`sb] with
[`basic_stringbuf<charT, traits, Allocator>(which | ios_base::out))]
([#stringbuf.cons]).
[exit:description]

[%@library basic_ostringstream[![:en]constructor]]
[codeblock:declaration]
explicit basic_ostringstream(
  const basic_string<charT,traits,Allocator>& str,
  ios_base::openmode which = ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_ostringstream<charT, traits>],
initializing the base class with [`basic_ostream(&sb)] and initializing [`sb]
with [`basic_stringbuf<charT, traits, Allocator>(str, which | ios_base::out))]
([#stringbuf.cons]).
[exit:description]

[%@library basic_ostringstream[![:en]constructor]]
[codeblock:declaration]
basic_ostringstream(basic_ostringstream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move constructs from the rvalue [`rhs].

[:en] This is accomplished by move constructing the base class, and the
contained [`basic_stringbuf].

[:en] Next [`basic_ostream<charT,traits>::set_rdbuf(&sb)] is called to install
the contained [`basic_stringbuf].
[exit:description]

[/     3[ostringstream.assign]{Assign and swap]/]
[section#ostringstream.assign
    [:en] Assign and swap
]

[%@library operator=[!basic_ostringstream]]
[%@library basic_ostringstream[!operator=]]
[codeblock:declaration]
basic_ostringstream& operator=(basic_ostringstream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move assigns the base and members of [`*this] from the base and
corresponding members of [`rhs].

[para:returns]
[:en] [`*this].
[exit:description]

[%@library swap[!basic_ostringstream]]
[%@library basic_ostringstream[!swap]]
[codeblock:declaration]
void swap(basic_ostringstream& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Exchanges the state of [`*this] and [`rhs] by calling
[`basic_ostream<charT,traits>::swap(rhs)] and [`sb.swap(rhs.sb)].
[exit:description]


[%@library swap[!basic_ostringstream]]
[%@library basic_ostringstream[!swap]]
[codeblock:declaration]
template <class charT, class traits, class Allocator>
void swap(basic_ostringstream<charT, traits, Allocator>& x,
          basic_ostringstream<charT, traits, Allocator>& y);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`x.swap(y)].
[exit:description]

[/     3[ostringstream.members]{Member functions]/]
[section#ostringstream.members
    [:en] Member functions
]

[%@library rdbuf[!basic_ostringstream]]
[codeblock:declaration]
basic_stringbuf<charT,traits,Allocator>* rdbuf() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`const_cast<basic_stringbuf<charT,traits,Allocator>*>(&sb)].
[exit:description]

[%@library str[!basic_ostringstream]]
[codeblock:declaration]
basic_string<charT,traits,Allocator> str() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`rdbuf()->str()].
[exit:description]

[%@library str[!basic_ostringstream]]
[%@library basic_ostringstream[!str]]
[codeblock:declaration]
void str(const basic_string<charT,traits,Allocator>& s);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`rdbuf()->str(s)].
[exit:description]

[/     2[stringstream]{Class template [`basic_stringstream]]/]
[section#stringstream
    [:en] Class template [`basic_stringstream]
]

[%@library basic_stringstream]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT>,
        class Allocator = allocator<charT> >
  class basic_stringstream
    : public basic_iostream<charT,traits> {
  public:

    // [:en] types:
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;
    typedef Allocator                 allocator_type;

    // [:en] constructors/destructor
    explicit basic_stringstream(
    ios_base::openmode which = ios_base::out|ios_base::in);
    explicit basic_stringstream(
    const basic_string<charT,traits,Allocator>& str,
    ios_base::openmode which = ios_base::out|ios_base::in);
    basic_stringstream(const basic_stringstream& rhs) = delete;
    basic_stringstream(basic_stringstream&& rhs);

    // [:en] [#stringstream.assign] Assign/swap:
    basic_stringstream& operator=(const basic_stringstream& rhs) = delete;
    basic_stringstream& operator=(basic_stringstream&& rhs);
    void swap(basic_stringstream& rhs);

    // [:en] Members:
    basic_stringbuf<charT,traits,Allocator>* rdbuf() const;
    basic_string<charT,traits,Allocator> str() const;
    void str(const basic_string<charT,traits,Allocator>& str);

  private:
    basic_stringbuf<charT, traits> sb;  // [=Expos]
  };

  template <class charT, class traits, class Allocator>
  void swap(basic_stringstream<charT, traits, Allocator>& x,
            basic_stringstream<charT, traits, Allocator>& y);
}
[codeblock:end]

[para]
[:en] The class template [`basic_stringstream<charT, traits>] supports reading
and writing from objects of class [`basic_string<charT, traits, Allocator>].

[:en] It uses a [`basic_stringbuf<charT, traits, Allocator>] object to control
the associated sequence.

[:en] For the sake of exposition, the maintained data is presented here as

[list]
[item]
[:en] [`sb], the [`stringbuf] object.
[list:end]

[/     3[stringstream.cons]{basic_stringstream constructors]/]
[section#stringstream.cons
    [:en] [`basic_stringstream] constructors
]

[%@library basic_stringstream[!basic_stringstream]]
[codeblock:declaration]
explicit basic_stringstream(
    ios_base::openmode which = ios_base::out|ios_base::in);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_stringstream<charT,traits>],
initializing the base class with [`basic_iostream(&sb)] and initializing [`sb]
with [`basic_stringbuf<charT,traits,Allocator>(which)].
[exit:description]

[%@library basic_stringstream[![:en]constructor]]
[codeblock:declaration]
explicit basic_stringstream(
    const basic_string<charT,traits,Allocator>& str,
    ios_base::openmode which = ios_base::out|ios_base::in);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_stringstream<charT, traits>],
initializing the base class with [`basic_iostream(&sb)] and initializing [`sb]
with [`basic_stringbuf<charT, traits, Allocator>(str, which)].
[exit:description]

[%@library basic_stringstream[![:en]constructor]]
[codeblock:declaration]
basic_stringstream(basic_stringstream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move constructs from the rvalue [`rhs].

[:en] This is accomplished by move constructing the base class, and the
contained [`basic_stringbuf].

[:en] Next [`basic_istream<charT,traits>::set_rdbuf(&sb)] is called to install
the contained [`basic_stringbuf].
[exit:description]

[/     3[stringstream.assign]{Assign and swap]/]
[section#stringstream.assign
    [:en] Assign and swap
]

[%@library operator=[!basic_stringstream]]
[%@library basic_stringstream[!operator=]]
[codeblock:declaration]
basic_stringstream& operator=(basic_stringstream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move assigns the base and members of [`*this] from the base and
corresponding members of [`rhs].

[para:returns]
[:en] [`*this].
[exit:description]

[%@library swap[!basic_stringstream]]
[%@library basic_stringstream[!swap]]
[codeblock:declaration]
void swap(basic_stringstream& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Exchanges the state of [`*this] and [`rhs] by calling
[`basic_iostream<charT,traits>::swap(rhs)] and [`sb.swap(rhs.sb)].
[exit:description]

[%@library swap[!basic_stringstream]]
[%@library basic_stringstream[!swap]]
[codeblock:declaration]
template <class charT, class traits, class Allocator>
void swap(basic_stringstream<charT, traits, Allocator>& x,
          basic_stringstream<charT, traits, Allocator>& y);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`x.swap(y)].
[exit:description]

[/     3[stringstream.members]{Member functions]/]
[section#stringstream.members
    [:en] Member functions
]

[%@library rdbuf[!basic_stringstream]]
[codeblock:declaration]
basic_stringbuf<charT,traits,Allocator>* rdbuf() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`const_cast<basic_stringbuf<charT,traits,Allocator>*>(&sb)]
[exit:description]

[%@library str[!basic_stringstream]]
[codeblock:declaration]
basic_string<charT,traits,Allocator> str() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`rdbuf()->str()].
[exit:description]

[%@library str[!basic_stringstream]]
[%@library basic_stringstream[!str]]
[codeblock:declaration]
void str(const basic_string<charT,traits,Allocator>& str);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`rdbuf()->str(str)].
[exit:description]

[/     1[file.streams]{File-based streams]/]
[section#file.streams
    [:en] File-based streams
]

[/     2[fstreams]{File streams]/]
[section#fstreams
    [:en] File streams
]

[para]
[:en] The header [`<fstream>] defines four class templates and eight types that
associate stream buffers with files and assist reading and writing files.

[para:synopsis]
[:en] Header [`<fstream>] synopsis

[%@library <fstream> [sortasfstream]]
[%@library filebuf]
[%@library basic_filebuf<char>]
[%@library wfilebuf]
[%@library basic_filebuf<wchar_t>]
[%@library ifstream]
[%@library basic_ifstream<char>]
[%@library wifstream]
[%@library basic_ifstream<wchar_t>]
[%@library ofstream]
[%@library basic_ofstream<char>]
[%@library wofstream]
[%@library basic_ofstream<wchar_t>]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT> >
    class basic_filebuf;
  typedef basic_filebuf<char>    filebuf;
  typedef basic_filebuf<wchar_t> wfilebuf;

  template <class charT, class traits = char_traits<charT> >
    class basic_ifstream;
  typedef basic_ifstream<char>    ifstream;
  typedef basic_ifstream<wchar_t> wifstream;

  template <class charT, class traits = char_traits<charT> >
    class basic_ofstream;
  typedef basic_ofstream<char>    ofstream;
  typedef basic_ofstream<wchar_t> wofstream;

  template <class charT, class traits = char_traits<charT> >
    class basic_fstream;
  typedef basic_fstream<char>     fstream;
  typedef basic_fstream<wchar_t> wfstream;
}
[codeblock:end]

[para]
[:en] In this subclause, the type name [`FILE] refers to the type [`FILE]
declared in [%@library <cstdio> [sortas cstdio]] [`<cstdio>] ([#c.files]).

[para]
[enter:note]
[:en] The class template [`basic_filebuf] treats a file as a source or sink of
bytes.

[:en] In an environment that uses a large character set, the file typically
holds multibyte character sequences and the [`basic_filebuf] object converts
those multibyte sequences into wide character sequences.
[exit:note]

[/     3[filebuf]{Class template [`basic_filebuf]]/]
[section#filebuf
    [:en] Class template [`basic_filebuf]
]

[%@library basic_filebuf]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT> >
  class basic_filebuf : public basic_streambuf<charT,traits> {
  public:
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;

    // [:en] [#filebuf.cons] Constructors/destructor:
    basic_filebuf();
    basic_filebuf(const basic_filebuf& rhs) = delete;
    basic_filebuf(basic_filebuf&& rhs);
    virtual ~basic_filebuf();

    // [:en] [#filebuf.assign] Assign/swap:
    basic_filebuf& operator=(const basic_filebuf& rhs) = delete;
    basic_filebuf& operator=(basic_filebuf&& rhs);
    void swap(basic_filebuf& rhs);

     // [:en] [#filebuf.members] Members:
    bool is_open() const;
    basic_filebuf<charT,traits>* open(const char* s,
        ios_base::openmode mode);
    basic_filebuf<charT,traits>* open(const string& s,
        ios_base::openmode mode);
    basic_filebuf<charT,traits>* close();

  protected:
    // [:en] [#filebuf.virtuals] Overridden virtual functions:
    virtual streamsize showmanyc();
    virtual int_type underflow();
    virtual int_type uflow();
    virtual int_type pbackfail(int_type c = traits::eof());
    virtual int_type overflow (int_type c = traits::eof());

    virtual basic_streambuf<charT,traits>*
        setbuf(char_type* s, streamsize n);
    virtual pos_type seekoff(off_type off, ios_base::seekdir way,
        ios_base::openmode which = ios_base::in | ios_base::out);
    virtual pos_type seekpos(pos_type sp,
        ios_base::openmode which = ios_base::in | ios_base::out);
    virtual int      sync();
    virtual void     imbue(const locale& loc);
  };

  template <class charT, class traits>
  void swap(basic_filebuf<charT, traits>& x,
            basic_filebuf<charT, traits>& y);
}
[codeblock:end]

[para]
[:en] The class [`basic_filebuf<charT,traits>] associates both the input
sequence and the output sequence with a file.

[para]
[:en] The restrictions on reading and writing a sequence controlled by an object
of class [`basic_filebuf<charT, traits>] are the same as for reading and writing
with the Standard C library [`FILE]s.

[para]
[:en] In particular:

[list]
[item]
[:en] If the file is not open for reading the input sequence cannot be read.
[item]
[:en] If the file is not open for writing the output sequence cannot be written.
[item]
[:en] A joint file position is maintained for both the input sequence and the
output sequence.
[list:end]

[para]
[:en] An instance of [`basic_filebuf] behaves as described in [#filebuf]
provided [`traits::pos_type] is [`fpos<traits::state_type>].

[:en] Otherwise the behavior is undefined.

[para]
[:en] In order to support file I/O and multibyte/wide character conversion,
conversions are performed using members of a facet, referred to as [`a_codecvt]
in following sections, obtained as if by

[codeblock:notation]
const codecvt<charT,char,typename traits::state_type>& a_codecvt =
  use_facet<codecvt<charT,char,typename traits::state_type> >(getloc());
[codeblock:end]

[/     3[filebuf.cons]{[`basic_filebuf] constructors]/]
[section#filebuf.cons
    [:en] [`basic_filebuf] constructors
]

[%@library basic_filebuf[!basic_filebuf]]
[codeblock:declaration]
basic_filebuf();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_filebuf<charT,traits>], initializing
the base class with [`basic_streambuf<charT,traits>()] ([#streambuf.cons]).

[para:postcondition]
[:en] [`is_open() == false].
[exit:description]

[%@library basic_filebuf[![:en]constructor]]
[codeblock:declaration]
basic_filebuf(basic_filebuf&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move constructs from the rvalue [`rhs].

[:en] It is [%@impldef whether sequence pointers are copied by [`basic_filebuf]
move constructor] implementation-defined whether the sequence pointers in
[`*this] ([`eback()], [`gptr()], [`egptr()], [`pbase()], [`pptr()], [`epptr()])
obtain the values which [`rhs] had.

[:en] Whether they do or not, [`*this] and [`rhs] reference separate buffers (if
any at all) after the construction.

[:en] Additionally [`*this] references the file which [`rhs] did before the
construction, and [`rhs] references no file after the construction.

[:en] The openmode, locale and any other state of [`rhs] is also copied.

[para:postconditions]
[:en] Let [`rhs_p] refer to the state of [`rhs] just prior to this construction
and let [`rhs_a] refer to the state of [`rhs] just after this construction.

[list]
[item] [`is_open() == rhs_p.is_open()]
[item] [`rhs_a.is_open() == false]
[item] [`gptr() - eback() == rhs_p.gptr() - rhs_p.eback()]
[item] [`egptr() - eback() == rhs_p.egptr() - rhs_p.eback()]
[item] [`pptr() - pbase() == rhs_p.pptr() - rhs_p.pbase()]
[item] [`epptr() - pbase() == rhs_p.epptr() - rhs_p.pbase()]
[item] [`if (eback()) eback() != rhs_a.eback()]
[item] [`if (gptr()) gptr() != rhs_a.gptr()]
[item] [`if (egptr()) egptr() != rhs_a.egptr()]
[item] [`if (pbase()) pbase() != rhs_a.pbase()]
[item] [`if (pptr()) pptr() != rhs_a.pptr()]
[item] [`if (epptr()) epptr() != rhs_a.epptr()]
[list:end]
[exit:description]

[%@library basic_filebuf[![:en]destructor]]
[codeblock:declaration]
virtual ~basic_filebuf();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Destroys an object of class [`basic_filebuf<charT,traits>].

[:en] Calls [`close()].

[:en] If an exception occurs during the destruction of the object, including the
call to [`close()], the exception is caught but not rethrown (see
[#res.on.exception.handling]).
[exit:description]

[/     3[filebuf.assign]{Assign and swap]/]
[section#filebuf.assign
    [:en] Assign and swap
]

[%@library operator=[!basic_filebuf]]
[%@library basic_filebuf[!operator=]]
[codeblock:declaration]
basic_filebuf& operator=(basic_filebuf&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`this->close()] then move assigns from [`rhs].

[:en] After the move assignment [`*this] has the observable state it would have
had if it had been move constructed from [`rhs] (see [#filebuf.cons]).

[para:returns]
[:en] [`*this].
[exit:description]

[%@library swap[!basic_filebuf]]
[%@library basic_filebuf[!swap]]
[codeblock:declaration]
void swap(basic_filebuf& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Exchanges the state of [`*this] and [`rhs].
[exit:description]

[%@library swap[!basic_filebuf]]
[%@library basic_filebuf[!swap]]
[codeblock:declaration]
template <class charT, class traits>
void swap(basic_filebuf<charT, traits>& x,
          basic_filebuf<charT, traits>& y);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`x.swap(y)].
[exit:description]

[/     3[filebuf.members]{Member functions]/]
[section#filebuf.members
    [:en] Member functions
]

[%@library is_open[!basic_filebuf]]
[codeblock:declaration]
bool is_open() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`true] if a previous call to [`open] succeeded (returned a non-null
value) and there has been no intervening call to close.
[exit:description]

[%@library open[!basic_filebuf]]
[codeblock:declaration]
basic_filebuf<charT,traits>* open(const char* s,
    ios_base::openmode mode);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`is_open() != false], returns a null pointer.

[:en] Otherwise, initializes the [`filebuf] as required.

[:en] It then opens a file, if possible, whose name is the [%NTBS] [em@sc ntbs]
[`s] (as if by calling [%@library fopen] [`std::fopen(s,modstr)]).

[:en] The [em@sc ntbs] [`modstr] is determined from [`mode & ~ios_base::ate] as
indicated in Table [#tab:iostreams.file.open.modes].

[:en] If [`mode] is not some combination of flags shown in the table then the
open fails.

[table:listing#tab:iostreams.file.open.modes
    [columns
        [columngroup@headercenter
            [:en] [`ios_base] flag combination
            [column [`binary] ]
            [column [`in] ]
            [column [`out] ]
            [column [`trunc] ]
            [column [`app] ]
        ]
        [column@headercenter@code
            [:en] [`stdio] equivalent
        ]
    ]
    [border:row@both]
    [border:group@both@double]
]

[-]
[|]     [|]     [|] +   [|]     [|]     [|] "w"
[|]     [|]     [|] +   [|]     [|] +   [|] "a"
[|]     [|]     [|]     [|]     [|] +   [|] "a"
[|]     [|]     [|] +   [|] +   [|]     [|] "w"
[|]     [|] +   [|]     [|]     [|]     [|] "r"
[|]     [|] +   [|] +   [|]     [|]     [|] "r+"
[|]     [|] +   [|] +   [|] +   [|]     [|] "w+"
[|]     [|] +   [|] +   [|]     [|] +   [|] "a+"
[|]     [|] +   [|]     [|]     [|] +   [|] "a+"

[-]
[|] +   [|]     [|] +   [|]     [|]     [|] "wb"
[|] +   [|]     [|] +   [|]     [|] +   [|] "ab"
[|] +   [|]     [|]     [|]     [|] +   [|] "ab"
[|] +   [|]     [|] +   [|] +   [|]     [|] "wb"
[|] +   [|] +   [|]     [|]     [|]     [|] "rb"
[|] +   [|] +   [|] +   [|]     [|]     [|] "r+b"
[|] +   [|] +   [|] +   [|] +   [|]     [|] "w+b"
[|] +   [|] +   [|] +   [|]     [|] +   [|] "a+b"
[|] +   [|] +   [|]     [|]     [|] +   [|] "a+b"

[table:end]

[para]
[:en] If the open operation succeeds and [`(mode & ios_base::ate) != 0],
positions the file to the end (as if by calling [`std::fseek(file,0,SEEK_END)]).

[footnote]
[:en] The macro [`SEEK_END] is defined, and the function signatures
[%@library fopen] [`fopen(const char*, const char*)] and
[%@library fseek] [`fseek(FILE*, long, int)] are declared, in
[%@library <cstdio> [sortas cstdio]] [`<cstdio>] ([#c.files]).
[footnote:end]

[para]
[:en] If the repositioning operation fails, calls [`close()] and returns a null
pointer to indicate failure.

[para:returns]
[:en] [`this] if successful, a null pointer otherwise.
[exit:description]

[%@library open[!basic_filebuf]]
[codeblock:declaration]
basic_filebuf<charT,traits>* open(const string& s,
    ios_base::openmode mode);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`open(s.c_str(), mode);]
[exit:description]

[%@library close[!basic_filebuf]]
[codeblock:declaration]
basic_filebuf<charT,traits>* close();
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`is_open() == false], returns a null pointer.

[:en] If a put area exists, calls [`overflow(traits::eof())] to flush
characters.

[:en] If the last virtual member function called on [`*this] (between
[`underflow], [`overflow], [`seekoff], and [`seekpos]) was [`overflow] then
calls [`a_codecvt.unshift] (possibly several times) to determine a termination
sequence, inserts those characters and calls [`overflow(traits::eof())] again.

[:en] Finally, regardless of whether any of the preceding calls fails or throws
an exception, the function closes the file (as if by calling [%@library fclose]
[`std::fclose(file)]).

[footnote]
[:en] The function signature [%@library fclose] [`fclose(FILE*)] is declared in
[%@library <cstdio> [sortas cstdio]] [`<cstdio>] ([#c.files]).
[footnote:end]

[:en] If any of the calls made by the function, including [`std::fclose], fails,
[`close] fails by returning a null pointer.

[:en] If one of these calls throws an exception, the exception is caught and
rethrown after closing the file.

[para:returns]
[:en] [`this] on success, a null pointer otherwise.

[para:postcondition]
[:en] [`is_open() == false].
[exit:description]

[/     3[filebuf.virtuals]{Overridden virtual functions]/]
[section#filebuf.virtuals
    [:en] Overridden virtual functions
]

[%@library showmanyc[!basic_filebuf]]
[codeblock:declaration]
streamsize showmanyc();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves the same as [%@library showmanyc[!basic_streambuf]]
[`basic_streambuf::showmanyc()] ([#streambuf.virtuals]).

[para:notes]
[:en] An implementation might well provide an overriding definition for this
function signature if it can determine that more characters can be read from the
input sequence.
[exit:description]

[%@library underflow[!basic_filebuf]]
[codeblock:declaration]
int_type underflow();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves according to the description of
[`basic_streambuf<charT,traits>::underflow()],
with the specialization that a sequence of characters is read from the input
sequence as if by reading from the associated file into an internal buffer
([`extern_buf]) and then as if by doing

[codeblock:notation]
char   extern_buf[XSIZE];
char*  extern_end;
charT  intern_buf[ISIZE];
charT* intern_end;
codecvt_base::result r =
  a_codecvt.in(state, extern_buf, extern_buf+XSIZE, extern_end,
               intern_buf, intern_buf+ISIZE, intern_end);
[codeblock:end]

[:en] This shall be done in such a way that the class can recover the position
([`fpos_t]) corresponding to each character between [`intern_buf] and
[`intern_end].

[:en] If the value of [`r] indicates that [`a_codecvt.in()] ran out of space in
[`intern_buf], retry with a larger [`intern_buf].
[exit:description]

[%@library uflow[!basic_filebuf]]
[codeblock:declaration]
int_type uflow();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves according to the description of
[`basic_streambuf<charT,traits>::uflow()], with the specialization that a
sequence of characters is read from the input with the same method as used by
[`underflow].
[exit:description]

[%@library pbackfail[!basic_filebuf]]
[codeblock:declaration]
int_type pbackfail(int_type c = traits::eof());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Puts back the character designated by [`c] to the input sequence, if
possible, in one of three ways:

[list]
[item]
[:en] If [`traits::eq_int_type(c,traits::eof())] returns [`false] and if the
function makes a putback position available and if
[`traits::eq(to_char_type(c),gptr()[-1`])] returns [`true], decrements the next
pointer for the input sequence, [`gptr()].

[:en] Returns: [`c].

[item]
[:en] If [`traits::eq_int_type(c,traits::eof())] returns [`false] and if the
function makes a putback position available and if the function is permitted to
assign to the putback position, decrements the next pointer for the input
sequence, and stores [`c] there.

[:en] Returns: [`c].

[item]
[:en] If [`traits::eq_int_type(c,traits::eof())] returns [`true], and if either
the input sequence has a putback position available or the function makes a
putback position available, decrements the next pointer for the input sequence,
[`gptr()].

[:en] Returns: [`traits::not_eof(c)].
[list:end]

[para:returns]
[:en] [`traits::eof()] to indicate failure.

[para:notes]
[:en] If [`is_open() == false], the function always fails.

[para]
[:en] The function does not put back a character directly to the input sequence.

[para]
[:en] If the function can succeed in more than one of these ways, it is
unspecified which way is chosen.

[:en] The function can alter the number of putback positions available as a
result of any call.
[exit:description]

[%@library overflow[!basic_filebuf]]
[codeblock:declaration]
int_type overflow(int_type c = traits::eof());
[codeblock:end]

[enter:description]
[para:effects]
[:en] Behaves according to the description of
[`basic_streambuf<charT,traits>::overflow(c)], except that the behavior of
["consuming characters] is performed by first converting as if by:

[codeblock:notation]
charT* b = pbase();
charT* p = pptr();
charT* end;
char   xbuf[XSIZE];
char*  xbuf_end;
codecvt_base::result r =
  a_codecvt.out(state, b, p, end, xbuf, xbuf+XSIZE, xbuf_end);
[codeblock:end]

[:en@~] and then

[list]
[item]
[:en] If [`r == codecvt_base::error] then fail.

[item]
[:en] If [`r == codecvt_base::noconv] then output characters from [`b] up to
(and not including) [`p].

[item]
[:en] If [`r == codecvt_base::partial] then output to the file characters from
[`xbuf] up to [`xbuf_end], and repeat using characters from [`end] to [`p].

[:en] If output fails, fail (without repeating).

[item]
[:en] Otherwise output from [`xbuf] to [`xbuf_end], and fail if output fails.

[:en] At this point if [`b != p] and [`b == end] ([`xbuf] isn[=']t large enough)
then increase [`XSIZE] and repeat from the beginning.
[list:end]

[para:returns]
[:en] [`traits::not_eof(c)] to indicate success, and [`traits::eof()] to
indicate failure.

[:en] If [`is_open() == false], the function always fails.
[exit:description]

[%@library setbuf[!basic_filebuf]]
[codeblock:declaration]
basic_streambuf* setbuf(char_type* s, streamsize n);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`setbuf(0,0)] is called on a stream before any I/O has occurred on
that stream, the stream becomes unbuffered.

[:en] Otherwise the results are [%@impldef effect of calling
[`basic_filebuf::setbuf] with non-zero arguments] implementation-defined.

["Unbuffered] means that [`pbase()] and [`pptr()] always return null and output
to the file should appear as soon as possible.
[exit:description]

[%@library seekoff[!basic_filebuf]]
[codeblock:declaration]
pos_type seekoff(off_type off, ios_base::seekdir way,
    ios_base::openmode which = ios_base::in | ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Let [`width] denote [`a_codecvt.encoding()].

[:en] If [`is_open() == false], or [`off != 0 && width <= 0], then the
positioning operation fails.

[:en] Otherwise, if [`way != basic_ios::cur] or [`off != 0], and if the last
operation was output, then update the output sequence and write any unshift
sequence.

[:en] Next, seek to the new position: if [`width > 0], call [`std::fseek(file,
width * off, whence)], otherwise call [`std::fseek(file, 0, whence)].

[para:notes]
[:en] ["The last operation was output] means either the last virtual operation
was overflow or the put buffer is non-empty.

[:en] ["Write any unshift sequence] means, if [`width] if less than zero then
call [`a_codecvt.unshift(state, xbuf, xbuf+XSIZE, xbuf_end)] and output the
resulting unshift sequence.

[:en] The function determines one of three values for the argument [`whence], of
type [`int], as indicated in Table [#tab:iostreams.seekoff.effects].

[table:listing#tab:iostreams.seekoff.effects
    [:en] [`seekoff] effects
    [columns
        [column@headercenter@code
            [:en] [`way] Value
        ]
        [column@code
            [`stdio] Equivalent
        ]
    ]
    [border:cell@none]
]

[|] basic_ios::beg
[|] SEEK_SET

[|] basic_ios::cur
[|] SEEK_CUR

[|] basic_ios::end
[|] SEEK_END

[table:end]

[para:returns]
[:en] A newly constructed [`pos_type] object that stores the resultant stream
position, if possible.

[:en] If the positioning operation fails, or if the object cannot represent the
resultant stream position, returns [`pos_type(off_type(-1))].
[exit:description]

[%@library seekpos[!basic_filebuf]]
[codeblock:declaration]
pos_type seekpos(pos_type sp,
    ios_base::openmode which = ios_base::in | ios_base::out);
[codeblock:end]

[enter:description]
[para]
[:en] Alters the file position, if possible, to correspond to the position
stored in [`sp] (as described below).

[:en] Altering the file position performs as follows:

[list:ol@ndot]
[item]
[:en] if [`(om & ios_base::out) != 0], then update the output sequence and write
any unshift sequence;

[item]
[:en] set the file position to [`sp];

[item]
[:en] if [`(om & ios_base::in) != 0], then update the input sequence;
[list:end]

[:en@~] where [`om] is the open mode passed to the last call to [`open()].

[:en] The operation fails if [`is_open()] returns false.

[para]
[:en] If [`sp] is an invalid stream position, or if the function positions
neither sequence, the positioning operation fails.

[:en] If [`sp] has not been obtained by a previous successful call to one of the
positioning functions ([`seekoff] or [`seekpos]) on the same file the effects
are undefined.

[para:returns]
[:en] [`sp] on success.

[:en] Otherwise returns [`pos_type(off_type(-1))].
[exit:description]

[%@library sync[!basic_filebuf]]
[codeblock:declaration]
int sync();
[codeblock:end]

[enter:description]
[para:effects]
[:en] If a put area exists, calls [`filebuf::overflow] to write the characters
to the file.

[:en] If a get area exists, the effect is [%@impldef effect of calling
[`basic_filebuf::sync] when a get area exists] implementation-defined.
[exit:description]

[%@library imbue[!basic_filebuf]]
[codeblock:declaration]
void imbue(const locale& loc);
[codeblock:end]

[enter:description]
[para:precondition]
[:en] If the file is not positioned at its beginning and the encoding of the
current locale as determined by [`a_codecvt.encoding()] is state-dependent
([#locale.codecvt.virtuals]) then that facet is the same as the corresponding
facet of [`loc].

[para:effects]
[:en] Causes characters inserted or extracted after this call to be converted
according to [`loc] until another call of [`imbue].

[para:note]
[:en] This may require reconversion of previously converted characters.

[:en] This in turn may require the implementation to be able to reconstruct the
original contents of the file.
[exit:description]

[/     3[ifstream]{Class template [`basic_ifstream]]/]
[section#ifstream
    [:en] Class template [`basic_ifstream]
]

[%@library basic_ifstream]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT> >
  class basic_ifstream : public basic_istream<charT,traits> {
  public:
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;

    // [:en] [#ifstream.cons] Constructors:
    basic_ifstream();
    explicit basic_ifstream(const char* s,
        ios_base::openmode mode = ios_base::in);
    explicit basic_ifstream(const string& s,
        ios_base::openmode mode = ios_base::in);
    basic_ifstream(const basic_ifstream& rhs) = delete;
    basic_ifstream(basic_ifstream&& rhs);

    // [:en] [#ifstream.assign] Assign/swap:
    basic_ifstream& operator=(const basic_ifstream& rhs) = delete;
    basic_ifstream& operator=(basic_ifstream&& rhs);
    void swap(basic_ifstream& rhs);

    // [:en] [#ifstream.members] Members:
    basic_filebuf<charT,traits>* rdbuf() const;

    bool is_open() const;
    void open(const char* s, ios_base::openmode mode = ios_base::in);
    void open(const string& s, ios_base::openmode mode = ios_base::in);
    void close();
  private:
    basic_filebuf<charT,traits> sb; // [=Expos]
  };

  template <class charT, class traits>
  void swap(basic_ifstream<charT, traits>& x,
            basic_ifstream<charT, traits>& y);
}
[codeblock:end]

[para]
[:en] The class [`basic_ifstream<charT, traits>] supports reading from named
files.

[:en] It uses a [`basic_filebuf<charT, traits>] object to control the associated
sequence.

[:en] For the sake of exposition, the maintained data is presented here as:

[list]
[item]
[:en] [`sb], the [`filebuf] object.
[list:end]

[/     3[ifstream.cons]{[`basic_ifstream] constructors]/]
[section#ifstream.cons
    [:en] [`basic_ifstream] constructors
]

[%@library basic_ifstream[!basic_ifstream]]
[codeblock:declaration]
basic_ifstream();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_ifstream<charT,traits>],
initializing the base class with [`basic_istream(&sb)] and initializing [`sb]
with [`basic_filebuf<charT,traits>())] ([#istream.cons], [#filebuf.cons]).
[exit:description]

[%@library basic_ifstream[![:en]constructor]]
[codeblock:declaration]
explicit basic_ifstream(const char* s,
    ios_base::openmode mode = ios_base::in);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_ifstream], initializing the base
class with [`basic_istream(&sb)] and initializing [`sb] with
[`basic_filebuf<charT, traits>())] ([#istream.cons], [#filebuf.cons]), then
calls [`rdbuf()->open(s, mode | ios_base::in)].

[:en] If that function returns a null pointer, calls [`setstate(failbit)].
[exit:description]

[%@library basic_ifstream[![:en]constructor]]
[codeblock:declaration]
explicit basic_ifstream(const string& s,
    ios_base::openmode mode = ios_base::in);
[codeblock:end]

[enter:description]
[para:effects]
[:en] the same as [`basic_ifstream(s.c_str(), mode)].
[exit:description]

[%@library basic_ifstream[![:en]constructor]]
[codeblock:declaration]
basic_ifstream(basic_ifstream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move constructs from the rvalue [`rhs].

[:en] This is accomplished by move constructing the base class, and the
contained [`basic_filebuf].

[:en] Next [`basic_istream<charT,traits>::set_rdbuf(&sb)] is called to install
the contained [`basic_filebuf].
[exit:description]

[/     3[ifstream.assign]{Assign and swap]/]
[section#ifstream.assign
    [:en] Assign and swap
]

[%@library operator=[!basic_ifstream]]
[%@library basic_ifstream[!operator=]]
[codeblock:declaration]
basic_ifstream& operator=(basic_ifstream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move assigns the base and members of [`*this] from the base and
corresponding members of [`rhs].

[para:returns]
[:en] [`*this].
[exit:description]

[%@library swap[!basic_ifstream]]
[%@library basic_ifstream[!swap]]
[codeblock:declaration]
void swap(basic_ifstream& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Exchanges the state of [`*this] and [`rhs] by calling
[`basic_istream<charT,traits>::swap(rhs)] and [`sb.swap(rhs.sb)].
[exit:description]

[%@library swap[!basic_ifstream]]
[%@library basic_ifstream[!swap]]
[codeblock:declaration]
template <class charT, class traits>
void swap(basic_ifstream<charT, traits>& x,
          basic_ifstream<charT, traits>& y);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`x.swap(y)].
[exit:description]

[/     3[ifstream.members]{Member functions]/]
[section#ifstream.members
    [:en] Member functions
]

[%@library rdbuf[!basic_ifstream]]
[codeblock:declaration]
basic_filebuf<charT,traits>* rdbuf() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`const_cast<basic_filebuf<charT,traits>*>(&sb)].
[exit:description]

[%@library is_open[!basic_ifstream]]
[codeblock:declaration]
bool is_open() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`rdbuf()->is_open()].
[exit:description]

[%@library open[!basic_ifstream]]
[codeblock:declaration]
void open(const char* s, ios_base::openmode mode = ios_base::in);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`rdbuf()->open(s, mode | ios_base::in)].

[:en] If that function does not return a null pointer calls [`clear()],
otherwise calls [`setstate(failbit)] (which may throw [`ios_base::failure]
([#iostate.flags])).
[exit:description]

[%@library open[!basic_ifstream]]
[codeblock:declaration]
void open(const string& s, ios_base::openmode mode = ios_base::in);
[codeblock:end]

[enter:description]
[para:effects]
[:en] calls [`open(s.c_str(), mode)].
[exit:description]

[%@library close[!basic_ifstream]]
[codeblock:declaration]
void close();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`rdbuf()->close()] and, if that function returns a null pointer,
calls [`setstate(failbit)] (which may throw [`ios_base::failure]
([#iostate.flags])).
[exit:description]

[/     3[ofstream]{Class template [`basic_ofstream]]/]
[section#ofstream
    [:en] Class template [`basic_ofstream]
]

[%@library basic_ofstream]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT> >
  class basic_ofstream : public basic_ostream<charT,traits> {
  public:
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;

    // [:en] [#ofstream.cons] Constructors:
    basic_ofstream();
    explicit basic_ofstream(const char* s,
        ios_base::openmode mode = ios_base::out);
    explicit basic_ofstream(const string& s,
        ios_base::openmode mode = ios_base::out);
    basic_ofstream(const basic_ofstream& rhs) = delete;
    basic_ofstream(basic_ofstream&& rhs);

    // [:en] [#ofstream.assign] Assign/swap:
    basic_ofstream& operator=(const basic_ofstream& rhs) = delete;
    basic_ofstream& operator=(basic_ofstream&& rhs);
    void swap(basic_ofstream& rhs);

    // [:en] [#ofstream.members] Members:
    basic_filebuf<charT,traits>* rdbuf() const;

    bool is_open() const;
    void open(const char* s, ios_base::openmode mode = ios_base::out);
    void open(const string& s, ios_base::openmode mode = ios_base::out);
    void close();
  private:
    basic_filebuf<charT,traits> sb; // [=Expos]
  };

  template <class charT, class traits>
  void swap(basic_ofstream<charT, traits>& x,
            basic_ofstream<charT, traits>& y);
}
[codeblock:end]

[para]
[:en] The class [`basic_ofstream<charT, traits>] supports writing to named
files.

[:en] It uses a [`basic_filebuf<charT, traits>] object to control the associated
sequence.

[:en] For the sake of exposition, the maintained data is presented here as:

[list]
[item]
[:en] [`sb], the [`filebuf] object.
[list:end]

[/     3[ofstream.cons]{[`basic_ofstream] constructors]/]
[section#ofstream.cons
    [:en] [`basic_ofstream] constructors
]

[%@library basic_ofstream[!basic_ofstream]]
[codeblock:declaration]
basic_ofstream();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_ofstream<charT,traits>],
initializing the base class with [`basic_ostream(&sb)] and initializing [`sb]
with [`basic_filebuf<charT,traits>())] ([#ostream.cons], [#filebuf.cons]).
[exit:description]

[%@library basic_ofstream[![:en]constructor]]
[codeblock:declaration]
explicit basic_ofstream(const char* s,
    ios_base::openmode mode = ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_ofstream<charT,traits>],
initializing the base class with [`basic_ostream(&sb)] and initializing [`sb]
with [`basic_filebuf<charT,traits>())] ([#ostream.cons], [#filebuf.cons]), then
calls [`rdbuf()->open(s, mode|ios_base::out)].

[:en] If that function returns a null pointer, calls [`setstate(failbit)].
[exit:description]

[%@library basic_ofstream[![:en]constructor]]
[codeblock:declaration]
explicit basic_ofstream(const string& s,
    ios_base::openmode mode = ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] the same as [`basic_ofstream(s.c_str(), mode);]
[exit:description]

[%@library basic_ofstream[![:en]constructor]]
[codeblock:declaration]
basic_ofstream(basic_ofstream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move constructs from the rvalue [`rhs].

[:en] This is accomplished by move constructing the base class, and the
contained [`basic_filebuf].

[:en] Next [`basic_ostream<charT,traits>::set_rdbuf(&sb)] is called to install
the contained [`basic_filebuf].
[exit:description]

[/     3[ofstream.assign]{Assign and swap]/]
[section#ofstream.assign
    [:en] Assign and swap
]

[%@library operator=[!basic_ofstream]]
[%@library basic_ofstream[!operator=]]
[codeblock:declaration]
basic_ofstream& operator=(basic_ofstream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move assigns the base and members of [`*this] from the base and
corresponding members of [`rhs].

[para:returns]
[:en] [`*this].
[exit:description]

[%@library swap[!basic_ofstream]]
[%@library basic_ofstream[!swap]]
[codeblock:declaration]
void swap(basic_ofstream& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Exchanges the state of [`*this] and [`rhs] by calling
[`basic_ostream<charT,traits>::swap(rhs)] and [`sb.swap(rhs.sb)].
[exit:description]

[%@library swap[!basic_ofstream]]
[%@library basic_ofstream[!swap]]
[codeblock:declaration]
template <class charT, class traits>
void swap(basic_ofstream<charT, traits>& x,
          basic_ofstream<charT, traits>& y);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`x.swap(y)].
[exit:description]

[/     3[ofstream.members]{Member functions]/]
[section#ofstream.members
    [:en] Member functions
]

[%@library rdbuf[!basic_ofstream]]
[codeblock:declaration]
basic_filebuf<charT,traits>* rdbuf() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`const_cast<basic_filebuf<charT,traits>*>(&sb)].
[exit:description]

[%@library is_open[!basic_ofstream]]
[codeblock:declaration]
bool is_open() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`rdbuf()->is_open()].
[exit:description]

[%@library open[!basic_ofstream]]
[codeblock:declaration]
void open(const char* s, ios_base::openmode mode = ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`rdbuf()->open(s, mode | ios_base::out)].

[:en] If that function does not return a null pointer calls [`clear()],
otherwise calls [`setstate(failbit)] (which may throw [`ios_base::failure]
([#iostate.flags])).
[exit:description]

[%@library close[!basic_ofstream]]
[codeblock:declaration]
void close();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`rdbuf()->close()] and, if that function fails (returns a null
pointer), calls [`setstate(failbit)] (which may throw [`ios_base::failure]
([#iostate.flags])).
[exit:description]

[%@library open[!basic_ofstream]]
[codeblock:declaration]
void open(const string& s, ios_base::openmode mode = ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] calls [`open(s.c_str(), mode);]
[exit:description]

[/     3[fstream]{Class template [`basic_fstream]]/]
[section#fstream
    [:en] Class template [`basic_fstream]
]

[%@library basic_fstream]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits=char_traits<charT> >
  class basic_fstream
    : public basic_iostream<charT,traits> {

  public:
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    typedef traits                    traits_type;

    // [:en] constructors/destructor
    basic_fstream();
    explicit basic_fstream(const char* s,
        ios_base::openmode mode = ios_base::in|ios_base::out);
    explicit basic_fstream(const string& s,
        ios_base::openmode mode = ios_base::in|ios_base::out);
    basic_fstream(const basic_fstream& rhs) = delete;
    basic_fstream(basic_fstream&& rhs);

    // [:en] [#fstream.assign] Assign/swap:
    basic_fstream& operator=(const basic_fstream& rhs) = delete;
    basic_fstream& operator=(basic_fstream&& rhs);
    void swap(basic_fstream& rhs);

    // [:en] Members:
    basic_filebuf<charT,traits>* rdbuf() const;
    bool is_open() const;
    void open(const char* s,
        ios_base::openmode mode = ios_base::in|ios_base::out);
    void open(const string& s,
        ios_base::openmode mode = ios_base::in|ios_base::out);
    void close();

  private:
    basic_filebuf<charT,traits> sb; // [=Expos]
  };

  template <class charT, class traits>
  void swap(basic_fstream<charT, traits>& x,
            basic_fstream<charT, traits>& y);
}
[codeblock:end]

[para]
[:en] The class template [`basic_fstream<charT,traits>] supports reading and
writing from named files.

[:en] It uses a [`basic_filebuf<charT,traits>] object to control the associated
sequences.

[:en] For the sake of exposition, the maintained data is presented here as:

[list]
[item]
[:en] [`sb], the [`basic_filebuf] object.
[list:end]

[/     3[fstream.cons]{[`basic_fstream] constructors]/]
[section#fstream.cons
    [:en] [`basic_fstream] constructors
]

[%@library basic_fstream[!basic_fstream]]
[codeblock:declaration]
basic_fstream();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_fstream<charT,traits>], initializing
the base class with [`basic_iostream(&sb)] and initializing [`sb] with
[`basic_filebuf<charT,traits>()].
[exit:description]

[%@library basic_fstream[![:en]constructor]]
[codeblock:declaration]
explicit basic_fstream(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an object of class [`basic_fstream<charT, traits>],
initializing the base class with [`basic_iostream(&sb)] and initializing [`sb]
with [`basic_filebuf<charT, traits>()].

[:en] Then calls [`rdbuf()->open(s, mode)].

[:en] If that function returns a null pointer, calls [`setstate(failbit)].
[exit:description]

[%@library basic_fstream[![:en]constructor]]
[codeblock:declaration]
explicit basic_fstream(const string& s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] the same as [`basic_fstream(s.c_str(), mode);]
[exit:description]

[%@library basic_fstream[![:en]constructor]]
[codeblock:declaration]
basic_fstream(basic_fstream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move constructs from the rvalue [`rhs].

[:en] This is accomplished by move constructing the base class, and the
contained [`basic_filebuf].

[:en] Next [`basic_istream<charT,traits>::set_rdbuf(&sb)] is called to install
the contained [`basic_filebuf].
[exit:description]

[/     3[fstream.assign]{Assign and swap]/]
[section#fstream.assign
    [:en] Assign and swap
]

[%@library operator=[!basic_fstream]]
[%@library basic_fstream[!operator=]]
[codeblock:declaration]
basic_fstream& operator=(basic_fstream&& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Move assigns the base and members of [`*this] from the base and
corresponding members of [`rhs].

[para:returns]
[:en] [`*this].
[exit:description]

[%@library swap[!basic_fstream]]
[%@library basic_fstream[!swap]]
[codeblock:declaration]
void swap(basic_fstream& rhs);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Exchanges the state of [`*this] and [`rhs] by calling
[`basic_iostream<charT,traits>::swap(rhs)] and [`sb.swap(rhs.sb)].
[exit:description]

[%@library swap[!basic_fstream]]
[%@library basic_fstream[!swap]]
[codeblock:declaration]
template <class charT, class traits>
void swap(basic_fstream<charT, traits>& x,
          basic_fstream<charT, traits>& y);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`x.swap(y)].
[exit:description]

[/     3[fstream.members]{Member functions]/]
[section#fstream.members
    [:en] Member functions
]

[%@library rdbuf[!basic_filebuf]]
[codeblock:declaration]
basic_filebuf<charT,traits>* rdbuf() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`const_cast<basic_filebuf<charT,traits>*>(&sb)].
[exit:description]

[%@library is_open[!basic_filebuf]]
[codeblock:declaration]
bool is_open() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`rdbuf()->is_open()].
[exit:description]

[%@library open[!basic_filebuf]]
[codeblock:declaration]
void open(const char* s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`rdbuf()->open(s,mode)].

[:en] If that function does not return a null pointer calls [`clear()],
otherwise calls [`setstate(failbit)], (which may throw [`ios_base::failure])
([#iostate.flags]).
[exit:description]

[%@library open[!basic_filebuf]]
[codeblock:declaration]
void open(const string& s,
    ios_base::openmode mode = ios_base::in|ios_base::out);
[codeblock:end]

[enter:description]
[para:effects]
[:en] calls [`open(s.c_str(), mode);]
[exit:description]

[%@library close[!basic_filebuf]]
[codeblock:declaration]
void close();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Calls [`rdbuf()->close()] and, if that function returns returns a null
pointer, calls [`setstate(failbit)] ([#iostate.flags]) (which may throw
[`ios_base::failure]).
[exit:description]

[/     2[c.files]{C library files]/]
[section#c.files
    [:en] C library files
]

[para]
[:en] Table [#tab:iostreams.hdr.cstdio] describes header [`<cstdio>].

[enter:note]
[:en] [=Cpp] does not define the function [`gets].
[exit:note]

[table:listing#tab:iostreams.hdr.cstdio
    [:en] Header [`<cstdio>] synopsis
    [columns
        [column@headercenter@code
            [:en] Type
        ]
        [column@headercenter@code
            [:en] Name(s)
        ]
        [column@header~@code]
        [column@header~@code]
        [column@header~@code]
        [column@header~@code]
    ]
    [border:group@both]
]
[-]
[|@colspan=all] [=Macros]

[|] BUFSIZ
[|] EOF
[|] FILENAME_MAX
[|] FOPEN_MAX
[|] L_tmpnam
[|] NULL <cstdio>
[|] SEEK_CUR
[|] SEEK_END
[|] SEEK_SET
[|] TMP_MAX
[|] _IOFBF
[|] _IOLBF
[|] _IONBF
[|] stderr
[|] stdin
[|] stdout

[-]
[|] [=Types]

[|] FILE
[|] fpos_t
[|] size_t <cstdio>

[-]
[|@colspan=all] [=Functions]

[|] clearerr
[|] fclose
[|] feof
[|] ferror
[|] fflush
[|] fgetc
[|] fgetpos
[|] fgets

[|] fopen
[|] fprintf
[|] fputc
[|] fputs
[|] fread
[|] freopen
[|] fscanf
[|] fseek

[|] fsetpos
[|] ftell
[|] fwrite
[|] getc
[|] getchar
[|] perror
[|] printf
[|] putc

[|] putchar
[|] puts
[|] remove
[|] rename
[|] rewind
[|] scanf
[|] setbuf
[|] setvbuf

[|] snprintf
[|] sprintf
[|] sscanf
[|] tmpfile
[|] tmpname
[|] ungetc
[|] vfprintf
[|] vprintf

[|] vscanf
[|] vsnprintf
[|] vsprintf
[|] vsscanf

[table:end]

[para]
[:en] Calls to the function [`tmpnam] with an argument of [`NULL] may introduce
a data race ([#res.on.data.races]) with other calls to [`tmpnam] with an
argument of [`NULL].

[para:xref]
[:en] ISO C 7.9, Amendment 1 4.6.2.

[para]
[:en] Table [#tab:iostreams.hdr.cinttypes] describes header [`<cinttypes>].

[enter:note]
[:en] The macros defined by [`<cinttypes>] are provided unconditionally.

[:en] In particular, the symbol [`__STDC_FORMAT_MACROS], mentioned in footnote
182 of the C standard, plays no role in [=Cpp].
[exit:note]

[table:listing#tab:iostreams.hdr.cinttypes
    [:en] Header [`<cinttypes>] synopsis
    [columns
        [column@headercenter@code
            [:en] Type
        ]
        [column@headercenter@code
            [:en] Name(s)
        ]
        [column@header~@code]
        [column@header~@code]
    ]
    [border:group@both]
]

[-]
[|@colspan=all] [=Macros]

[|@colspan=all] PRI{d i o u x X}[=[]FAST LEAST[=]]{8 16 32 64}
[|@colspan=all] PRI{d i o u x X}{MAX PTR}
[|@colspan=all] SCN{d i o u x X}[=[]FAST LEAST[=]]{8 16 32 64}
[|@colspan=all] SCN{d i o u x X}{MAX PTR}

[-]
[|] [=Types]

[|] imaxdiv_t

[-]
[|@colspan=all] [=Functions]

[|] abs
[|] div
[|] imaxabs
[|] imaxdiv
[|] strtoimax
[|] strtoumax
[|] wcstoimax
[|] wcstoumax

[table:end]

[para]
[:en] The contents of header [`<cinttypes>] are the same as the Standard C
Library header [`<inttypes.h>], with the following changes:

[list]
[item]
[:en] the header [`<cinttypes>] includes the header [`<cstdint>] instead of
[`<stdint.h>], and

[item]
[:en@~] if and only if the type [`intmax_t] designates an extended integer
type ([#basic.fundamental]), the following function signatures are added:

[codeblock:synopsis]
intmax_t abs(intmax_t);
imaxdiv_t div(intmax_t, intmax_t);
[codeblock:end]

[:en@~] which shall have the same semantics as the function signatures
[`intmax_t imaxabs(intmax_t)] and [`imaxdiv_t imaxdiv(intmax_t, intmax_t)],
respectively.
[list:end]
