[section:chapter#iterators
    [:en] Iterators library
]

[include iterators.general]

[include iterator.requirements]

[include iterator.synopsis]

[/     1[iterator.primitives]{Iterator primitives}/]
[section#iterator.primitives
    [:en] Iterator primitives
]

[para]
[:en] To simplify the task of defining iterators, the library provides several
classes and functions:

[/     2[iterator.traits]{Iterator traits}/]
[section#iterator.traits
    [:en] Iterator traits
]

[para]
[:en] To implement algorithms only in terms of iterators, it is often necessary
to determine the value and difference types that correspond to a particular
iterator type.

[:en] Accordingly, it is required that if [`Iterator] is the type of an
iterator, the types

[codeblock:notation]
iterator_traits<Iterator>::difference_type
iterator_traits<Iterator>::value_type
iterator_traits<Iterator>::iterator_category
[codeblock:end]

[:en@~] be defined as the iterator[=']s difference type, value type and iterator
category, respectively.

[:en] In addition, the types

[codeblock:notation]
iterator_traits<Iterator>::reference
iterator_traits<Iterator>::pointer
[codeblock:end]

[:en@~] shall be defined as the iterator[=']s reference and pointer types, that
is, for an iterator object [`a], the same type as the type of [`*a] and [`a->],
respectively.

[:en] In the case of an output iterator, the types

[codeblock:notation]
iterator_traits<Iterator>::difference_type
iterator_traits<Iterator>::value_type
iterator_traits<Iterator>::reference
iterator_traits<Iterator>::pointer
[codeblock:end]

[:en@~] may be defined as [`void].

[para]
[:en] If [`Iterator] has valid ([#temp.deduct]) member types [`difference_type],
[`value_type], [`pointer], [`reference], and [`iterator_category],
[`iterator_traits<Iterator>] shall have the following as publicly accessible
members and shall have no other members:

[codeblock:notation]
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
  typedef typename Iterator::iterator_category iterator_category;
[codeblock:end]

[:en] Otherwise, [`iterator_traits<Iterator>] shall have no members.

[para]
[:en] It is specialized for pointers as

[codeblock:synopsis]
namespace std {
  template<class T> struct iterator_traits<T*> {
    typedef ptrdiff_t difference_type;
    typedef T value_type;
    typedef T* pointer;
    typedef T& reference;
    typedef random_access_iterator_tag iterator_category;
  };
}
[codeblock:end]

[:en@~] and for pointers to const as

[codeblock:synopsis]
namespace std {
  template<class T> struct iterator_traits<const T*> {
    typedef ptrdiff_t difference_type;
    typedef T value_type;
    typedef const T* pointer;
    typedef const T& reference;
    typedef random_access_iterator_tag iterator_category;
  };
}
[codeblock:end]

[para]
[enter:example]
[:en] To implement a generic [`reverse] function, a [=Cpp] program can do the
following:

[codeblock]
template <class BidirectionalIterator>
void reverse(BidirectionalIterator first, BidirectionalIterator last) {
  typename iterator_traits<BidirectionalIterator>::difference_type n =
    distance(first, last);
  --n;
  while(n > 0) {
    typename iterator_traits<BidirectionalIterator>::value_type
     tmp = *first;
    *first++ = *--last;
    *last = tmp;
    n -= 2;
  }
}
[codeblock:end]
[exit:example]

[/     2[iterator.basic]{Basic iterator}/]
[section#iterator.basic
    [:en] Basic iterator
]

[para]
[:en] The [`iterator] template may be used as a base class to ease the
definition of required types for new iterators.

[codeblock:synopsis]
namespace std {
  template<class Category, class T, class Distance = ptrdiff_t,
    class Pointer = T*, class Reference = T&>
  struct iterator {
    typedef T         value_type;
    typedef Distance  difference_type;
    typedef Pointer   pointer;
    typedef Reference reference;
    typedef Category  iterator_category;
  };
}
[codeblock:end]

[/     2[std.iterator.tags]{Standard iterator tags}/]
[section#std.iterator.tags
    [:en] Standard iterator tags
]

[para]
[%@library input_iterator_tag]
[%@library output_iterator_tag]
[%@library forward_iterator_tag]
[%@library bidirectional_iterator_tag]
[%@library random_access_iterator_tag]
[:en] It is often desirable for a function template specialization to find out
what is the most specific category of its iterator argument, so that the
function can select the most efficient algorithm at compile time.

[:en] To facilitate this, the library introduces [+category tag] classes which
are used as compile time tags for algorithm selection.

[:en] They are: [`input_iterator_tag], [`output_iterator_tag],
[`forward_iterator_tag], [`bidirectional_iterator_tag] and
[`random_access_iterator_tag].

[:en] For every iterator of type [`Iterator],
[`iterator_traits<Iterator>::iterator_category] shall be defined to be the most
specific category tag that describes the iterator[=']s behavior.

[codeblock:synopsis]
namespace std {
  struct input_iterator_tag { };
  struct output_iterator_tag { };
  struct forward_iterator_tag: public input_iterator_tag { };
  struct bidirectional_iterator_tag: public forward_iterator_tag { };
  struct random_access_iterator_tag: public bidirectional_iterator_tag { };
}
[codeblock:end]

[para]
[%@library empty]
[%@library input_iterator_tag]
[%@library output_iterator_tag]
[%@library forward_iterator_tag]
[%@library bidirectional_iterator_tag]
[%@library random_access_iterator_tag]
[enter:example]
[:en] For a program-defined iterator [`BinaryTreeIterator], it could be included
into the bidirectional iterator category by specializing the [`iterator_traits]
template:

[codeblock:synopsis]
template<class T> struct iterator_traits<BinaryTreeIterator<T> > {
  typedef std::ptrdiff_t difference_type;
  typedef T value_type;
  typedef T* pointer;
  typedef T& reference;
  typedef bidirectional_iterator_tag iterator_category;
};
[codeblock:end]

[:en] Typically, however, it would be easier to derive [`BinaryTreeIterator<T>]
from [`iterator<bidirectional_iterator_tag,T,ptrdiff_t,T*,T&>].
[exit:example]

[para]
[enter:example]
[:en] If [`evolve()] is well defined for bidirectional iterators, but can be
implemented more efficiently for random access iterators, then the
implementation is as follows:

[codeblock]
template <class BidirectionalIterator>
inline void
evolve(BidirectionalIterator first, BidirectionalIterator last) {
  evolve(first, last,
    typename iterator_traits<BidirectionalIterator>::iterator_category());
}

template <class BidirectionalIterator>
void evolve(BidirectionalIterator first, BidirectionalIterator last,
  bidirectional_iterator_tag) {
  // [:en] more generic, but less efficient algorithm
}

template <class RandomAccessIterator>
void evolve(RandomAccessIterator first, RandomAccessIterator last,
  random_access_iterator_tag) {
  // [:en] more efficient, but less generic algorithm
}
[codeblock:end]
[exit:example]

[para]
[enter:example]
[:en] If a [=Cpp] program wants to define a bidirectional iterator for some data
structure containing [`double] and such that it works on a large memory model of
the implementation, it can do so with:

[codeblock]
class MyIterator :
  public iterator<bidirectional_iterator_tag, double, long, T*, T&> {
  // [:en] code implementing [`++], etc.
};
[codeblock:end]

[para]
[:en] Then there is no need to specialize the [`iterator_traits] template.
[exit:example]

[/     2[iterator.operations]{Iterator operations}/]
[section#iterator.operations
    [:en] Iterator operations
]

[para]
[:en] Since only random access iterators provide [`+] and [`-] operators, the
library provides two function templates [`advance] and [`distance].

[:en] These function templates use [`+] and [`-] for random access iterators
(and are, therefore, constant time for them); for input, forward and
bidirectional iterators they use [`++] to provide linear time implementations.

[%@library advance]
[codeblock:declaration]
template <class InputIterator, class Distance>
  void advance(InputIterator& i, Distance n);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`n] shall be negative only for bidirectional and random access iterators.

[para:effects]
[:en] Increments (or decrements for negative [`n]) iterator reference [`i] by
[`n].
[exit:description]

[%@library distance]
[codeblock:declaration]
template <class InputIterator>
  typename iterator_traits<InputIterator>::difference_type
    distance(InputIterator first, InputIterator last);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`InputIterator] meets the requirements of random access iterator,
returns [`(last - first)]; otherwise, returns the number of increments needed to
get from [`first] to [`last].

[para:requires]
[:en] If [`InputIterator] meets the requirements of random access iterator,
[`last] shall be reachable from [`first] or [`first] shall be reachable from
[`last]; otherwise, [`last] shall be reachable from [`first].
[exit:description]

[%@library next]
[codeblock:declaration]
template <class ForwardIterator>
  ForwardIterator next(ForwardIterator x,
    typename std::iterator_traits<ForwardIterator>::difference_type n = 1);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Equivalent to [`advance(x, n); return x;]
[exit:description]

[%@library prev]
[codeblock:declaration]
template <class BidirectionalIterator>
  BidirectionalIterator prev(BidirectionalIterator x,
    typename std::iterator_traits<BidirectionalIterator>::difference_type n = 1);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Equivalent to [`advance(x, -n); return x;]
[exit:description]

[/     1[predef.iterators]{Iterator adaptors}/]
[section#predef.iterators
    [:en] Iterator adaptors
]

[/     2[reverse.iterators]{Reverse iterators}/]
[section#reverse.iterators
    [:en] Reverse iterators
]

[para]
[:en] Class template [`reverse_iterator] is an iterator adaptor that iterates
from the end of the sequence defined by its underlying iterator to the beginning
of that sequence.

[:en] The fundamental relation between a reverse iterator and its corresponding
iterator [`i] is established by the identity:
[`&*(reverse_iterator(i)) == &*(i - 1)].

[/     3[reverse.iterator]{Class template [`reverse_iterator}}/]
[section#reverse.iterator
    [:en] Class template [`reverse_iterator]
]

[%@library reverse_iterator]
[codeblock:synopsis [special unspecified] ]
namespace std {
  template <class Iterator>
  class reverse_iterator : public
        iterator<typename iterator_traits<Iterator>::iterator_category,
        typename iterator_traits<Iterator>::value_type,
        typename iterator_traits<Iterator>::difference_type,
        typename iterator_traits<Iterator>::pointer,
        typename iterator_traits<Iterator>::reference> {
  public:
    typedef Iterator                                            iterator_type;
    typedef typename iterator_traits<Iterator>::difference_type difference_type;
    typedef typename iterator_traits<Iterator>::reference       reference;
    typedef typename iterator_traits<Iterator>::pointer         pointer;

    reverse_iterator();
    explicit reverse_iterator(Iterator x);
    template <class U> reverse_iterator(const reverse_iterator<U>& u);
    template <class U> reverse_iterator& operator=(const reverse_iterator<U>& u);

    Iterator base() const;      // [:en] explicit
    reference operator*() const;
    pointer   operator->() const;

    reverse_iterator& operator++();
    reverse_iterator  operator++(int);
    reverse_iterator& operator--();
    reverse_iterator  operator--(int);

    reverse_iterator  operator+ (difference_type n) const;
    reverse_iterator& operator+=(difference_type n);
    reverse_iterator  operator- (difference_type n) const;
    reverse_iterator& operator-=(difference_type n);
    unspecified operator[](difference_type n) const;
  protected:
    Iterator current;
  };

  template <class Iterator1, class Iterator2>
    bool operator==(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template <class Iterator1, class Iterator2>
    bool operator<(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template <class Iterator1, class Iterator2>
    bool operator!=(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template <class Iterator1, class Iterator2>
    bool operator>(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template <class Iterator1, class Iterator2>
    bool operator>=(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template <class Iterator1, class Iterator2>
    bool operator<=(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y);
  template <class Iterator1, class Iterator2>
    auto operator-(
      const reverse_iterator<Iterator1>& x,
      const reverse_iterator<Iterator2>& y) -> decltype(y.base() - x.base());
  template <class Iterator>
    reverse_iterator<Iterator> operator+(
      typename reverse_iterator<Iterator>::difference_type n,
      const reverse_iterator<Iterator>& x);

  template <class Iterator>
    reverse_iterator<Iterator> make_reverse_iterator(Iterator i);      
}
[codeblock:end]

[/     3[reverse.iter.requirements]{[`reverse_iterator} requirements}/]
[section#reverse.iter.requirements
    [:en] [`reverse_iterator] requirements
]

[para]
[:en] The template parameter [`Iterator] shall meet all the requirements of
a Bidirectional Iterator ([#bidirectional.iterators]).

[para]
[:en] Additionally, [`Iterator] shall meet the requirements of a Random Access
Iterator ([#random.access.iterators]) if any of the members [`operator+]
([#reverse.iter.op+]), [`operator-] ([#reverse.iter.op-]), [`operator+=]
([#reverse.iter.op+=]), [`operator-=] ([#reverse.iter.op-=]), [`operator[`]]
([#reverse.iter.opindex]), or the global operators [`operator<]
([#reverse.iter.op<]), [`operator>] ([#reverse.iter.op>]), [`operator<=]
([#reverse.iter.op<=]), [`operator>=] ([#reverse.iter.op>=]), [`operator-]
([#reverse.iter.opdiff]) or [`operator+] ([#reverse.iter.opsum]) are referenced
in a way that requires instantiation ([#temp.inst]).

[/     3[reverse.iter.ops]{[`reverse_iterator} operations}/]
[section#reverse.iter.ops
    [:en] [`reverse_iterator] operations
]

[/     4[reverse.iter.cons]{[`reverse_iterator} constructor}/]
[section#reverse.iter.cons
    [:en] [`reverse_iterator] constructor
]

[%@library reverse_iterator[!reverse_iterator]]
[codeblock:declaration]
reverse_iterator();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Value initializes [`current].

[:en] Iterator operations applied to the resulting iterator have defined
behavior if and only if the corresponding operations are defined on a
value-initialized iterator of type [`Iterator].
[exit:description]

[%@library reverse_iterator[![:en]constructor]]

[codeblock:declaration]
explicit reverse_iterator(Iterator x);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`current] with [`x].
[exit:description]

[%@library reverse_iterator[![:en]constructor]]

[codeblock:declaration]
template <class U> reverse_iterator(const reverse_iterator<U> &u);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`current] with [`u.current].
[exit:description]

[/     4[reverse.iter.op=]{[`reverse_iterator::operator=}}/]
[section#reverse.iter.op=
    [:en] [`reverse_iterator::operator=]
]

[%@library operator=[!reverse_iterator]]
[codeblock:declaration]
template <class U>
reverse_iterator&
  operator=(const reverse_iterator<U>& u);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Assigns [`u.base()] to current.

[para:returns]
[:en] [`*this].
[exit:description]

[/     4[reverse.iter.conv]{Conversion}/]
[section#reverse.iter.conv
    [:en] Conversion
]

[%@library base[!reverse_iterator]]
[%@library reverse_iterator[!base]]
[codeblock:declaration]
Iterator base() const;          // [:en] explicit
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`current].
[exit:description]

[/     4[reverse.iter.op.star]{[`operator*}}/]
[section#reverse.iter.op.star
    [:en] [`operator*]
]

[%@library operator*[!reverse_iterator]]
[codeblock:declaration]
reference operator*() const;
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
Iterator tmp = current;
return *--tmp;
[codeblock:end]

[exit:description]

[/     4[reverse.iter.opref]{[`operator->}}/]
[section#reverse.iter.opref
    [:en] [`operator->]
]

[%@library operator->[!reverse_iterator]]
[codeblock:declaration]
pointer operator->() const;
[codeblock:end]

[enter:description]
[para:returns] [`std::addressof(operator*())].
[exit:description]

[/     4[reverse.iter.op++]{[`operator++}}/]
[section#reverse.iter.op++
    [:en] [`operator++]
]

[%@library operator++[!reverse_iterator]]
[codeblock:declaration]
reverse_iterator& operator++();
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`--current;]

[para:returns]
[:en] [`*this].
[exit:description]

[%@library operator++[!reverse_iterator]]
[%@library reverse_iterator[!operator++]]
[codeblock:declaration]
reverse_iterator operator++(int);
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
reverse_iterator tmp = *this;
--current;
return tmp;
[codeblock:end]
[exit:description]

[/     4[reverse.iter.op\dcr]{[`operator\dcr}}/]
[section#reverse.iter.op--
    [:en] [`operator--]
]

[%@library operator--[!reverse_iterator]]
[codeblock:declaration]
reverse_iterator& operator--();
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`++current]

[para:returns]
[:en] [`*this].
[exit:description]

[%@library operator--[!reverse_iterator]]
[%@library reverse_iterator[!operator--]]
[codeblock:declaration]
reverse_iterator operator--(int);
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
reverse_iterator tmp = *this;
++current;
return tmp;
[codeblock:end]
[exit:description]

[/     4[reverse.iter.op+]{[`operator+}}/]
[section#reverse.iter.op+
    [:en] [`operator+]
]

[%@library operator+[!reverse_iterator]]
[codeblock:declaration]
reverse_iterator
operator+(typename reverse_iterator<Iterator>::difference_type n) const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`reverse_iterator(current-n)].
[exit:description]

[/     4[reverse.iter.op+=]{[`operator+=}}/]
[section#reverse.iter.op+=
    [:en] [`operator+=]
]

[%@library operator+=[!reverse_iterator]]
[codeblock:declaration]
reverse_iterator&
operator+=(typename reverse_iterator<Iterator>::difference_type n);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`current -= n;]

[para:returns]
[:en] [`*this].
[exit:description]

[/     4[reverse.iter.op-]{[`operator-}}/]
[section#reverse.iter.op-
    [:en] [`operator-]
]

[%@library operator-[!reverse_iterator]]
[codeblock:declaration]
reverse_iterator
operator-(typename reverse_iterator<Iterator>::difference_type n) const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`reverse_iterator(current+n)].
[exit:description]

[/     4[reverse.iter.op-=]{[`operator-=}}/]
[section#reverse.iter.op-=
    [:en] [`operator-=]
]

[%@library operator-=[!reverse_iterator]]
[codeblock:declaration]
reverse_iterator&
operator-=(typename reverse_iterator<Iterator>::difference_type n);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`current += n;]

[para:returns]
[:en] [`*this].
[exit:description]

[/     4[reverse.iter.opindex]{[`operator[]}}/]
[section#reverse.iter.opindex
    [:en] [`operator[`]]
]

[%@library operator['][!reverse_iterator]]
[codeblock:declaration [special unspecified] ]
unspecified operator[](
    typename reverse_iterator<Iterator>::difference_type n) const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`current[-n-1`]].
[exit:description]

[/     4[reverse.iter.op==]{[`operator==}}/]
[section#reverse.iter.op==
    [:en] [`operator==]
]

[%@library operator==[!reverse_iterator]]
[codeblock:declaration]
template <class Iterator1, class Iterator2>
  bool operator==(
    const reverse_iterator<Iterator1>& x,
    const reverse_iterator<Iterator2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.current == y.current].
[exit:description]

[/     4[reverse.iter.op<]{[`operator<}}/]
[section#reverse.iter.op<
    [:en] [`operator<]
]

[%@library operator<[!reverse_iterator]]
[codeblock:declaration]
template <class Iterator1, class Iterator2>
  bool operator<(
    const reverse_iterator<Iterator1>& x,
    const reverse_iterator<Iterator2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.current > y.current].
[exit:description]

[/     4[reverse.iter.op!=]{[`operator!=}}/]
[section#reverse.iter.op!=
    [:en] [`operator!=]
]

[%@library operator!=[!reverse_iterator]]
[codeblock:declaration]
template <class Iterator1, class Iterator2>
  bool operator!=(
    const reverse_iterator<Iterator1>& x,
    const reverse_iterator<Iterator2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.current != y.current].
[exit:description]

[/     4[reverse.iter.op>]{[`operator>}}/]
[section#reverse.iter.op
    [:en] [`operator>]
]

[%@library operator>[!reverse_iterator]]
[codeblock:declaration]
template <class Iterator1, class Iterator2>
  bool operator>(
    const reverse_iterator<Iterator1>& x,
    const reverse_iterator<Iterator2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.current < y.current].
[exit:description]

[/     4[reverse.iter.op>=]{[`operator>=}}/]
[section#reverse.iter.op>=
    [:en] [`operator>=]
]

[%@library operator>=[!reverse_iterator]]
[codeblock:declaration]
template <class Iterator1, class Iterator2>
  bool operator>=(
    const reverse_iterator<Iterator1>& x,
    const reverse_iterator<Iterator2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.current <= y.current].
[exit:description]

[/     4[reverse.iter.op<=]{[`operator<=}}/]
[section#reverse.iter.op<=
    [:en] [`operator<=]
]

[%@library operator<=[!reverse_iterator]]
[codeblock:declaration]
template <class Iterator1, class Iterator2>
  bool operator<=(
    const reverse_iterator<Iterator1>& x,
    const reverse_iterator<Iterator2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.current >= y.current].
[exit:description]

[/     4[reverse.iter.opdiff]{[`operator-}}/]
[section#reverse.iter.opdiff
    [:en] [`operator-]
]

[%@library operator-[!reverse_iterator]]
[codeblock:declaration]
template <class Iterator1, class Iterator2>
    auto operator-(
    const reverse_iterator<Iterator1>& x,
    const reverse_iterator<Iterator2>& y) -> decltype(y.base() - x.base());
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`y.current - x.current].
[exit:description]

[/     4[reverse.iter.opsum]{[`operator+}}/]
[section#reverse.iter.opsum
    [:en] [`operator+]
]

[%@library operator+[!reverse_iterator]]
[codeblock:declaration]
template <class Iterator>
  reverse_iterator<Iterator> operator+(
    typename reverse_iterator<Iterator>::difference_type n,
    const reverse_iterator<Iterator>& x);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`reverse_iterator<Iterator> (x.current - n)].
[exit:description]

[/     4[reverse.iter.make]{Non-member function [`make_reverse_iterator()}}/]
[section#reverse.iter.make
    [:en] Non-member function [`make_reverse_iterator()]
]

[%@library reverse_iterator[!make_reverse_iterator [:en] non-member function]]
[%@library make_reverse_iterator]
[codeblock:declaration]
template <class Iterator>
  reverse_iterator<Iterator> make_reverse_iterator(Iterator i);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`reverse_iterator<Iterator>(i)].
[exit:description]

[/     2[insert.iterators]{Insert iterators}/]
[section#insert.iterators
    [:en] Insert iterators
]

[para]
[:en] To make it possible to deal with insertion in the same way as writing into
an array, a special kind of iterator adaptors, called [+insert iterators], are
provided in the library.

[:en] With regular iterator classes,

[codeblock:notation]
while (first != last) *result++ = *first++;
[codeblock:end]

[:en@~] causes a range [=range[first,last)] to be copied into a range starting
with result.

[:en] The same code with [`result] being an insert iterator will insert
corresponding elements into the container.

[:en] This device allows all of the copying algorithms in the library to work in
the [+insert mode] instead of the [+regular overwrite] mode.

[para]
[:en] An insert iterator is constructed from a container and possibly one of its
iterators pointing to where insertion takes place if it is neither at the
beginning nor at the end of the container.

[:en] Insert iterators satisfy the requirements of output iterators.

[:en] [`operator*] returns the insert iterator itself.

[:en] The assignment [`operator=(const T& x)] is defined on insert iterators to
allow writing into them, it inserts [`x] right before where the insert iterator
is pointing.

[:en] In other words, an insert iterator is like a cursor pointing into the
container where the insertion takes place.

[:en] [`back_insert_iterator] inserts elements at the end of a container,
[`front_insert_iterator] inserts elements at the beginning of a container, and
[`insert_iterator] inserts elements where the iterator points to in a container.

[:en] [`back_inserter], [`front_inserter], and [`inserter] are three functions
making the insert iterators out of a container.

[/     3[back.insert.iterator]{Class template [`back_insert_iterator}}/]
[section#back.insert.iterator
    [:en] Class template [`back_insert_iterator]
]

[%@library back_insert_iterator]
[codeblock:synopsis]
namespace std {
  template <class Container>
  class back_insert_iterator :
    public iterator<output_iterator_tag,void,void,void,void> {
  protected:
    Container* container;

  public:
    typedef Container container_type;
    explicit back_insert_iterator(Container& x);
    back_insert_iterator& operator=(const typename Container::value_type& value);
    back_insert_iterator& operator=(typename Container::value_type&& value);

    back_insert_iterator& operator*();
    back_insert_iterator& operator++();
    back_insert_iterator  operator++(int);
  };

  template <class Container>
    back_insert_iterator<Container> back_inserter(Container& x);
}
[codeblock:end]

[/     3[back.insert.iter.ops]{[`back_insert_iterator} operations}/]
[section#back.insert.iter.ops
    [:en] [`back_insert_iterator] operations
]

[/     4[back.insert.iter.cons]{[`back_insert_iterator} constructor}/]
[section#back.insert.iter.cons
    [:en] [`back_insert_iterator] constructor
]

[%@library back_insert_iterator[!back_insert_iterator]]
[codeblock:declaration]
explicit back_insert_iterator(Container& x);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`container] with [`std::addressof(x)].
[exit:description]

[/     4[back.insert.iter.op=]{[`back_insert_iterator::operator=}}/]
[section#back.insert.iter.op=
    [:en] [`back_insert_iterator::operator=]
]

[%@library operator=[!back_insert_iterator]]
[codeblock:declaration]
back_insert_iterator& operator=(const typename Container::value_type& value);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`container->push_back(value);]

[para:returns]
[:en] [`*this].
[exit:description]

[%@library operator=[!back_insert_iterator]]
[codeblock:declaration]
back_insert_iterator& operator=(typename Container::value_type&& value);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`container->push_back(std::move(value));]

[para:returns]
[:en] [`*this].
[exit:description]

[/     4[back.insert.iter.op*]{[`back_insert_iterator::operator*}}/]
[section#back.insert.iter.op*
    [:en] [`back_insert_iterator::operator*]
]

[%@library operator*[!back_insert_iterator]]
[codeblock:declaration]
back_insert_iterator& operator*();
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`*this].
[exit:description]

[/     4[back.insert.iter.op++]{[`back_insert_iterator::operator++}}/]
[section#back.insert.iter.op++
    [:en] [`back_insert_iterator::operator++]
]

[%@library operator++[!back_insert_iterator]]
[codeblock:declaration]
back_insert_iterator& operator++();
back_insert_iterator  operator++(int);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`*this].
[exit:description]

[/     4[back.inserter]{ [`back_inserter}}/]
[section#back.inserter
    [:en] [`back_inserter]
]

[%@library back_inserter]
[codeblock:declaration]
template <class Container>
  back_insert_iterator<Container> back_inserter(Container& x);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`back_insert_iterator<Container>(x)].
[exit:description]

[/     3[front.insert.iterator]{Class template [`front_insert_iterator}}/]
[section#front.insert.iterator
    [:en] Class template [`front_insert_iterator]
]

[%@library front_insert_iterator]
[codeblock:synopsis]
namespace std {
  template <class Container>
  class front_insert_iterator :
    public iterator<output_iterator_tag,void,void,void,void> {
  protected:
    Container* container;

  public:
    typedef Container container_type;
    explicit front_insert_iterator(Container& x);
    front_insert_iterator& operator=(const typename Container::value_type& value);
    front_insert_iterator& operator=(typename Container::value_type&& value);

    front_insert_iterator& operator*();
    front_insert_iterator& operator++();
    front_insert_iterator  operator++(int);
  };

  template <class Container>
    front_insert_iterator<Container> front_inserter(Container& x);
}
[codeblock:end]

[/     3[front.insert.iter.ops]{[`front_insert_iterator} operations}/]
[section#front.insert.iter.ops
    [:en] [`front_insert_iterator] operations
]

[/     4[front.insert.iter.cons]{[`front_insert_iterator} constructor}/]
[section#front.insert.iter.cons
    [:en] [`front_insert_iterator] constructor
]

[%@library front_insert_iterator[!front_insert_iterator]]
[codeblock:declaration]
explicit front_insert_iterator(Container& x);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`container] with [`std::addressof(x)].
[exit:description]

[/     4[front.insert.iter.op=]{[`front_insert_iterator::operator=}}/]
[section#front.insert.iter.op=
    [:en] [`front_insert_iterator::operator=]
]

[%@library operator=[!front_insert_iterator]]
[codeblock:declaration]
front_insert_iterator& operator=(const typename Container::value_type& value);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`container->push_front(value);]

[para:returns]
[:en] [`*this].
[exit:description]

[%@library operator=[!front_insert_iterator]]
[codeblock:declaration]
front_insert_iterator& operator=(typename Container::value_type&& value);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`container->push_front(std::move(value));]

[para:returns]
[:en] [`*this].
[exit:description]

[/     4[front.insert.iter.op*]{[`front_insert_iterator::operator*}}/]
[section#front.insert.iter.op*
    [:en] [`front_insert_iterator::operator*]
]

[%@library operator*[!front_insert_iterator]]
[codeblock:declaration]
front_insert_iterator& operator*();
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`*this].
[exit:description]

[/     4[front.insert.iter.op++]{[`front_insert_iterator::operator++}}/]
[section#front.insert.iter.op++
    [:en] [`front_insert_iterator::operator++]
]

[%@library operator++[!front_insert_iterator]]
[codeblock:declaration]
front_insert_iterator& operator++();
front_insert_iterator  operator++(int);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`*this].
[exit:description]

[/     4[front.inserter]{[`front_inserter}}/]
[section#front.inserter
    [:en] [`front_inserter]
]

[%@library front_inserter]
[codeblock:declaration]
template <class Container>
  front_insert_iterator<Container> front_inserter(Container& x);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`front_insert_iterator<Container>(x)].
[exit:description]

[/     3[insert.iterator]{Class template [`insert_iterator}}/]
[section#insert.iterator
    [:en] Class template [`insert_iterator]
]

[%@library insert_iterator]
[codeblock:synopsis]
namespace std {
  template <class Container>
  class insert_iterator :
    public iterator<output_iterator_tag,void,void,void,void> {
  protected:
    Container* container;
    typename Container::iterator iter;

  public:
    typedef Container container_type;
    insert_iterator(Container& x, typename Container::iterator i);
    insert_iterator& operator=(const typename Container::value_type& value);
    insert_iterator& operator=(typename Container::value_type&& value);

    insert_iterator& operator*();
    insert_iterator& operator++();
    insert_iterator& operator++(int);
  };

  template <class Container>
    insert_iterator<Container> inserter(Container& x, typename Container::iterator i);
}
[codeblock:end]

[/     3[insert.iter.ops]{[`insert_iterator} operations}/]
[section#insert.iter.ops
    [:en] [`insert_iterator] operations
]

[/     4[insert.iter.cons]{[`insert_iterator} constructor}/]
[section#insert.iter.cons
    [:en] [`insert_iterator] constructor
]

[%@library insert_iterator[!insert_iterator]]
[codeblock:declaration]
insert_iterator(Container& x, typename Container::iterator i);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [`container] with [`std::addressof(x)] and [`iter] with [`i].
[exit:description]

[/     4[insert.iter.op=]{[`insert_iterator::operator=}}/]
[section#insert.iter.op=
    [:en] [`insert_iterator:operator=]
]

[%@library operator=[!insert_iterator]]
[codeblock:declaration]
insert_iterator& operator=(const typename Container::value_type& value);
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
iter = container->insert(iter, value);
++iter;
[codeblock:end]

[para:returns]
[:en] [`*this].
[exit:description]

[%@library operator=[!insert_iterator]]
[codeblock:declaration]
insert_iterator& operator=(typename Container::value_type&& value);
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
iter = container->insert(iter, std::move(value));
++iter;
[codeblock:end]

[para:returns]
[:en] [`*this].
[exit:description]

[/     4[insert.iter.op*]{[`insert_iterator::operator*}}/]
[section#insert.iter.op*
    [:en] [`insert_iterator::operator*]
]

[%@library operator*[!insert_iterator]]
[codeblock:declaration]
insert_iterator& operator*();
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`*this].
[exit:description]

[/     4[insert.iter.op++]{[`insert_iterator::operator++}}/]
[section#insert.iter.op++
    [:en] [`insert_iterator::operator++]
]

[%@library operator++[!insert_iterator]]
[codeblock:declaration]
insert_iterator& operator++();
insert_iterator& operator++(int);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`*this].
[exit:description]

[/     4[inserter]{[`inserter}}/]
[section#inserter
    [:en] [`inserter]
]

[%@library inserter]
[codeblock:declaration]
template <class Container>
  insert_iterator<Container> inserter(Container& x, typename Container::iterator i);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`insert_iterator<Container>(x, i)].
[exit:description]

[/     2[move.iterators]{Move iterators}/]
[section#move.iterators
    [:en] Move iterators
]

[para]
[:en] Class template [`move_iterator] is an iterator adaptor with the same
behavior as the underlying iterator except that its indirection operator
implicitly converts the value returned by the underlying iterator[=']s
indirection operator to an rvalue.

[:en] Some generic algorithms can be called with move iterators to replace
copying with moving.

[para]
[enter:example]

[codeblock]
list<string> s;
// [:en] populate the list [`s]
vector<string> v1(s.begin(), s.end());          // [:en] copies strings into [`v1]
vector<string> v2(make_move_iterator(s.begin()),
                  make_move_iterator(s.end())); // [:en] moves strings into [`v2]
[codeblock:end]

[exit:example]

[/     3[move.iterator]{Class template [`move_iterator}}/]
[section#move.iterator
    [:en] Class template [`move_iterator]
]

[%@library move_iterator]
[codeblock:synopsis [special unspecified] ]
namespace std {
  template <class Iterator>
  class move_iterator {
  public:
    typedef Iterator                                              iterator_type;
    typedef typename iterator_traits<Iterator>::difference_type   difference_type;
    typedef Iterator                                              pointer;
    typedef typename iterator_traits<Iterator>::value_type        value_type;
    typedef typename iterator_traits<Iterator>::iterator_category iterator_category;
    typedef [=Seebelow]                                             reference;

    move_iterator();
    explicit move_iterator(Iterator i);
    template <class U> move_iterator(const move_iterator<U>& u);
    template <class U> move_iterator& operator=(const move_iterator<U>& u);

    iterator_type base() const;
    reference operator*() const;
    pointer operator->() const;

    move_iterator& operator++();
    move_iterator operator++(int);
    move_iterator& operator--();
    move_iterator operator--(int);

    move_iterator operator+(difference_type n) const;
    move_iterator& operator+=(difference_type n);
    move_iterator operator-(difference_type n) const;
    move_iterator& operator-=(difference_type n);
    unspecified operator[](difference_type n) const;

  private:
    Iterator current;   // [=Expos]
  };

  template <class Iterator1, class Iterator2>
    bool operator==(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template <class Iterator1, class Iterator2>
    bool operator!=(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template <class Iterator1, class Iterator2>
    bool operator<(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template <class Iterator1, class Iterator2>
    bool operator<=(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template <class Iterator1, class Iterator2>
    bool operator>(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
  template <class Iterator1, class Iterator2>
    bool operator>=(
      const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);

  template <class Iterator1, class Iterator2>
    auto operator-(
      const move_iterator<Iterator1>& x,
      const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());
  template <class Iterator>
    move_iterator<Iterator> operator+(
      typename move_iterator<Iterator>::difference_type n, const move_iterator<Iterator>& x);
  template <class Iterator>
    move_iterator<Iterator> make_move_iterator(Iterator i);
}
[codeblock:end]

[para]
[:en] Let [$R] be [`iterator_traits<Iterator>::reference].

[:en] If [`is_reference<][$R][`>::value] is [`true], the template specialization
[`move_iterator<Iterator>] shall define the nested type named [`reference] as a
synonym for [`remove_reference<][$R][`>::type&&], otherwise as a synonym for
[$R].

[/     3[move.iter.requirements]{[`move_iterator} requirements}/]
[section#move.iter.requirements
    [:en] [`move_iterator] requirements
]

[para]
[:en] The template parameter [`Iterator] shall meet the requirements for an
Input Iterator ([#input.iterators]).

[:en] Additionally, if any of the bidirectional or random access traversal
functions are instantiated, the template parameter shall meet the requirements
for a Bidirectional Iterator ([#bidirectional.iterators]) or a Random Access
Iterator ([#random.access.iterators]), respectively.

[/     3[move.iter.ops]{[`move_iterator} operations}/]
[section#move.iter.ops
    [:en] [`move_iterator] operations
]

[/     4[move.iter.op.const]{[`move_iterator} constructors}/]
[section#move.iter.op.const
    [:en] [`move_iterator] constructors
]

[%@library move_iterator[!move_iterator]]
[codeblock:declaration]
move_iterator();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a [`move_iterator], value initializing [`current].

[:en] Iterator operations applied to the resulting iterator have defined
behavior if and only if the corresponding operations are defined on a
value-initialized iterator of type [`Iterator].
[exit:description]


[%@library move_iterator[![:en]constructor]]
[codeblock:declaration]
explicit move_iterator(Iterator i);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a [`move_iterator], initializing [`current] with [`i].
[exit:description]


[%@library move_iterator[![:en]constructor]]
[codeblock:declaration]
template <class U> move_iterator(const move_iterator<U>& u);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a [`move_iterator], initializing [`current] with [`u.base()].

[para:requires]
[:en] [`U] shall be convertible to [`Iterator].
[exit:description]

[/     4[move.iter.op=]{[`move_iterator::operator=}}/]
[section#move.iter.op=
    [:en] [`move_iterator::operator=]
]

[%@library operator=[!move_iterator]]
[%@library move_iterator[!operator=]]
[codeblock:declaration]
template <class U> move_iterator& operator=(const move_iterator<U>& u);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Assigns [`u.base()] to [`current].

[para:requires]
[:en] [`U] shall be convertible to [`Iterator].
[exit:description]

[/     4[move.iter.op.conv]{[`move_iterator} conversion}/]
[section#move.iter.op.conv
    [:en] [`move_iterator] conversion
]

[%@library base[!move_iterator]]
[%@library move_iterator[!base]]
[codeblock:declaration]
Iterator base() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`current].
[exit:description]

[/     4[move.iter.op.star]{[`move_iterator::operator*}}/]
[section#move.iter.op.star
    [:en] [`move_iterator::operator*]
]

[%@library operator*[!move_iterator]]
[%@library move_iterator[!operator*]]
[codeblock:declaration]
reference operator*() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`static_cast<reference>(*current)].
[exit:description]

[/     4[move.iter.op.ref]{[`move_iterator::operator->}}/]
[section#move.iter.op.ref
    [:en] [`move_iterator::operator->]
]

[%@library operator->[!move_iterator]]
[%@library move_iterator[!operator->]]
[codeblock:declaration]
pointer operator->() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`current].
[exit:description]

[/     4[move.iter.op.incr]{[`move_iterator::operator++}}/]
[section#move.iter.op.incr
    [:en] [`move_iterator::operator++]
]

[%@library operator++[!move_iterator]]
[%@library move_iterator[!operator++]]
[codeblock:declaration]
move_iterator& operator++();
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`++current].

[para:returns]
[:en] [`*this].
[exit:description]

[%@library operator++[!move_iterator]]
[%@library move_iterator[!operator++]]
[codeblock:declaration]
move_iterator operator++(int);
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
move_iterator tmp = *this;
++current;
return tmp;
[codeblock:end]
[exit:description]

[/     4[move.iter.op.decr]{[`move_iterator::operator-{-}}}/]
[section#move.iter.op.decr
    [:en] [`move_iterator::operator--]
]

[%@library operator--[!move_iterator]]
[%@library move_iterator[!operator--]]
[codeblock:declaration]
move_iterator& operator--();
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`--current].

[para:returns]
[:en] [`*this].
[exit:description]

[%@library operator--[!move_iterator]]
[%@library move_iterator[!operator--]]
[codeblock:declaration]
move_iterator operator--(int);
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation]
move_iterator tmp = *this;
--current;
return tmp;
[codeblock:end]
[exit:description]

[/     4[move.iter.op.+]{[`move_iterator::operator+}}/]
[section#move.iter.op.+
    [:en] [`move_iterator::operator+]
]

[%@library operator+[!move_iterator]]
[%@library move_iterator[!operator+]]
[codeblock:declaration]
move_iterator operator+(difference_type n) const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`move_iterator(current + n)].
[exit:description]

[/     4[move.iter.op.+=]{[`move_iterator::operator+=}}/]
[section#move.iter.op.+=
    [:en] [`move_iterator::operator+=]
]

[%@library operator+=[!move_iterator]]
[%@library move_iterator[!operator+=]]
[codeblock:declaration]
move_iterator& operator+=(difference_type n);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`current += n].

[para:returns]
[:en] [`*this].
[exit:description]

[/     4[move.iter.op.-]{[`move_iterator::operator-}}/]
[section#move.iter.op.-
    [:en] [`move_iterator::operator-]
]

[%@library operator-[!move_iterator]]
[%@library move_iterator[!operator-]]
[codeblock:declaration]
move_iterator operator-(difference_type n) const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`move_iterator(current - n)].
[exit:description]

[/     4[move.iter.op.-=]{[`move_iterator::operator-=}}/]
[section#move.iter.op.-=
    [:en] [`move_iterator::operator-=]
]

[%@library operator-=[!move_iterator]]
[%@library move_iterator[!operator-=]]
[codeblock:declaration]
move_iterator& operator-=(difference_type n);
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`current -= n].

[para:returns]
[:en] [`*this].
[exit:description]

[/     4[move.iter.op.index]{[`move_iterator::operator[]}}/]
[section#move.iter.op.index
    [:en] [`move_iterator::operator[`]]
]

[%@library operator['][!move_iterator]]
[%@library move_iterator[!operator[']]]
[codeblock:declaration [special unspecified] ]
unspecified operator[](difference_type n) const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`std::move(current[n`])].
[exit:description]

[/     4[move.iter.op.comp]{[`move_iterator} comparisons}/]
[section#move.iter.op.comp
    [:en] [`move_iterator] comparisons
]

[%@library operator==[!move_iterator]]
[%@library move_iterator[!operator==]]
[codeblock:declaration]
template <class Iterator1, class Iterator2>
bool operator==(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.base() == y.base()].
[exit:description]

[%@library operator!=[!move_iterator]]
[%@library move_iterator[!operator!=]]
[codeblock:declaration]
template <class Iterator1, class Iterator2>
bool operator!=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`!(x == y)].
[exit:description]

[%@library operator<[!move_iterator]]
[%@library move_iterator[!operator<]]
[codeblock:declaration]
template <class Iterator1, class Iterator2>
bool operator<(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.base() < y.base()].
[exit:description]

[%@library operator<=[!move_iterator]]
[%@library move_iterator[!operator<=]]
[codeblock:declaration]
template <class Iterator1, class Iterator2>
bool operator<=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`!(y < x)].
[exit:description]

[%@library operator>[!move_iterator]]
[%@library move_iterator[!operator>]]
[codeblock:declaration]
template <class Iterator1, class Iterator2>
bool operator>(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`y < x].
[exit:description]

[%@library operator>=[!move_iterator]]
[%@library move_iterator[!operator>=]]
[codeblock:declaration]
template <class Iterator1, class Iterator2>
bool operator>=(const move_iterator<Iterator1>& x, const move_iterator<Iterator2>& y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`!(x < y)].
[exit:description]

[/     4[move.iter.nonmember]{[`move_iterator} non-member functions}/]
[section#move.iter.nonmember
    [:en] [`move_iterator] non-member functions
]

[%@library operator-[!move_iterator]]
[%@library move_iterator[!operator-]]
[codeblock:declaration]
template <class Iterator1, class Iterator2>
    auto operator-(
    const move_iterator<Iterator1>& x,
    const move_iterator<Iterator2>& y) -> decltype(x.base() - y.base());
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.base() - y.base()].
[exit:description]

[%@library operator+[!move_iterator]]
[%@library move_iterator[!operator+]]
[codeblock:declaration]
template <class Iterator>
  move_iterator<Iterator> operator+(
    typename move_iterator<Iterator>::difference_type n, const move_iterator<Iterator>& x);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x + n].
[exit:description]

[%@library make_move_iterator]
[codeblock:declaration]
template <class Iterator>
move_iterator<Iterator> make_move_iterator(Iterator i);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`move_iterator<Iterator>(i)].
[exit:description]

[/     1[stream.iterators]{Stream iterators}/]
[section#stream.iterators
    [:en] Stream iterators
]

[para]
[:en] To make it possible for algorithmic templates to work directly with
input/output streams, appropriate iterator-like class templates are provided.

[enter:example]
[codeblock]
partial_sum(istream_iterator<double, char>(cin),
  istream_iterator<double, char>(),
  ostream_iterator<double, char>(cout, "\n"));
[codeblock:end]

[:en@~] reads a file containing floating point numbers from [`cin], and prints
the partial sums onto [`cout].
[exit:example]

[/     2[istream.iterator]{Class template [`istream_iterator}}/]
[section#istream.iterator
    [:en] Class template [`istream_iterator]
]

[para]
[%@library istream_iterator]
[:en] The class template [`istream_iterator] is an input iterator
([#input.iterators]) that reads (using [`operator>>]) successive elements from
the input stream for which it was constructed.

[:en] After it is constructed, and every time [`++] is used, the iterator reads
and stores a value of [`T].

[:en] If the iterator fails to read and store a value of [`T] ([`fail()] on the
stream returns [`true]), the iterator becomes equal to the [+end-of-stream]
iterator value.

[:en] The constructor with no arguments [`istream_iterator()] always constructs
an end-of-stream input iterator object, which is the only legitimate iterator to
be used for the end condition.

[:en] The result of [`operator*] on an end-of-stream iterator is not defined.

[:en] For any other iterator value a [`const T&] is returned.

[:en] The result of [`operator->] on an end-of-stream iterator is not defined.

[:en] For any other iterator value a [`const T*] is returned.

[:en] The behavior of a program that applies [`operator++()] to an end-of-stream
iterator is undefined.

[:en] It is impossible to store things into istream iterators.

[para]
[:en] Two end-of-stream iterators are always equal.

[:en] An end-of-stream iterator is not equal to a non-end-of-stream iterator.

[:en] Two non-end-of-stream iterators are equal when they are constructed from
the same stream.

[codeblock:synopsis]
namespace std {
  template <class T, class charT = char, class traits = char_traits<charT>,
      class Distance = ptrdiff_t>
  class istream_iterator:
    public iterator<input_iterator_tag, T, Distance, const T*, const T&> {
  public:
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_istream<charT,traits> istream_type;
    [=Seebelow] istream_iterator();
    istream_iterator(istream_type& s);
    istream_iterator(const istream_iterator& x) = default;
   ~istream_iterator() = default;

    const T& operator*() const;
    const T* operator->() const;
    istream_iterator& operator++();
    istream_iterator  operator++(int);
  private:
    basic_istream<charT,traits>* in_stream; // [=Expos]
    T value;                                // [=Expos]
  };

  template <class T, class charT, class traits, class Distance>
    bool operator==(const istream_iterator<T,charT,traits,Distance>& x,
            const istream_iterator<T,charT,traits,Distance>& y);
  template <class T, class charT, class traits, class Distance>
    bool operator!=(const istream_iterator<T,charT,traits,Distance>& x,
            const istream_iterator<T,charT,traits,Distance>& y);
}
[codeblock:end]

[/     3[istream.iterator.cons]{[`istream_iterator} constructors and destructor}/]
[section#istream.iterator.cons
    [:en] [`istream_iterator] constructors and destructor
]


[%@library istream_iterator[![:en]constructor]]
[codeblock:declaration]
[=Seebelow] istream_iterator();
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs the end-of-stream iterator.

[:en] If [`T] is a literal type, then this constructor shall be a [`constexpr]
constructor.

[para:postcondition]
[:en] [`in_stream == 0].
[exit:description]


[%@library istream_iterator[![:en]constructor]]
[codeblock:declaration]
istream_iterator(istream_type& s);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [$in_stream] with [`&s]. [$value] may be initialized during
construction or the first time it is referenced.

[para:postcondition]
[:en] [`in_stream == &s].
[exit:description]


[%@library istream_iterator[![:en]constructor]]
[codeblock:declaration]
istream_iterator(const istream_iterator& x) = default;
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a copy of [`x]. If [`T] is a literal type, then this
constructor shall be a trivial copy constructor.

[para:postcondition]
[:en] [`in_stream == x.in_stream].
[exit:description]

[%@library istream_iterator[![:en]destructor]]
[codeblock:declaration]
~istream_iterator() = default;
[codeblock:end]

[enter:description]
[para:effects]
[:en] The iterator is destroyed. If [`T] is a literal type, then this destructor
shall be a trivial destructor.
[exit:description]

[/     3[istream.iterator.ops]{[`istream_iterator} operations}/]
[section#istream.iterator.ops
    [:en] [`istream_iterator] operations
]

[%@library operator*[!istream_iterator]]
[%@library istream_iterator[!operator*]]
[codeblock:declaration]
const T& operator*() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [$value].
[exit:description]

[%@library operator->[!istream_iterator]]
[%@library istream_iterator[!operator->]]
[codeblock:declaration]
const T* operator->() const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`&(operator*())].
[exit:description]

[%@library operator++[!istream_iterator]]
[%@library istream_iterator[!operator++]]
[codeblock:declaration]
istream_iterator& operator++();
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`in_stream != 0].

[para:effects]
[:en] [`*in_stream >> value].

[para:returns]
[:en] [`*this].
[exit:description]

[%@library operator++[!istream_iterator]]
[%@library istream_iterator[!operator++]]
[codeblock:declaration]
istream_iterator operator++(int);
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`in_stream != 0].

[para:effects]
[codeblock:notation]
istream_iterator tmp = *this;
*in_stream >> value;
return (tmp);
[codeblock:end]
[exit:description]

[%@library operator==[!istream_iterator]]
[%@library istream_iterator[!operator==]]
[codeblock:declaration]
template <class T, class charT, class traits, class Distance>
  bool operator==(const istream_iterator<T,charT,traits,Distance> &x,
                  const istream_iterator<T,charT,traits,Distance> &y);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`x.in_stream == y.in_stream].
[%@library istream_iterator[!operator==]]
[exit:description]

[%@library operator!=[!istream_iterator]]
[%@library istream_iterator[!operator!=]]
[codeblock:declaration]
template <class T, class charT, class traits, class Distance>
  bool operator!=(const istream_iterator<T,charT,traits,Distance> &x,
                  const istream_iterator<T,charT,traits,Distance> &y);
[codeblock:end]

[%@library istream_iterator[!operator!=]]
[enter:description]
[para:returns]
[:en] [`!(x == y)]
[exit:description]

[/     2[ostream.iterator]{Class template [`ostream_iterator}}/]
[section#ostream.iterator
    [:en] Class template [`ostream_iterator]
]

[para]
[%@library ostream_iterator]
[:en] [`ostream_iterator] writes (using [`operator<<]) successive elements onto
the output stream from which it was constructed.

[:en] If it was constructed with [`charT*] as a constructor argument, this
string, called a [+delimiter string], is written to the stream after every [`T]
is written.

[:en] It is not possible to get a value out of the output iterator.

[:en] Its only use is as an output iterator in situations like

[codeblock:notation]
while (first != last)
  *result++ = *first++;
[codeblock:end]

[para]
[:en] [`ostream_iterator] is defined as:

[codeblock:synopsis]
namespace std {
  template <class T, class charT = char, class traits = char_traits<charT> >
  class ostream_iterator:
    public iterator<output_iterator_tag, void, void, void, void> {
  public:
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_ostream<charT,traits> ostream_type;
    ostream_iterator(ostream_type& s);
    ostream_iterator(ostream_type& s, const charT* delimiter);
    ostream_iterator(const ostream_iterator& x);
   ~ostream_iterator();
    ostream_iterator& operator=(const T& value);

    ostream_iterator& operator*();
    ostream_iterator& operator++();
    ostream_iterator& operator++(int);
  private:
    basic_ostream<charT,traits>* out_stream;  // [=Expos]
    const charT* delim;                       // [=Expos]
  };
}
[codeblock:end]

[/     3[ostream.iterator.cons.des]{[`ostream_iterator} constructors and destructor}/]
[section#ostream.iterator.cons.des
    [:en] [`ostream_iterator] constructors and destructor
]


[%@library ostream_iterator[![:en]constructor]]
[codeblock:declaration]
ostream_iterator(ostream_type& s);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [$out_stream] with [`&s] and [$delim] with null.
[exit:description]

[%@library ostream_iterator[![:en]constructor]]
[codeblock:declaration]
ostream_iterator(ostream_type& s, const charT* delimiter);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Initializes [$out_stream] with [`&s] and [$delim] with [`delimiter].
[exit:description]

[%@library ostream_iterator[![:en]constructor]]
[codeblock:declaration]
ostream_iterator(const ostream_iterator& x);
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a copy of [`x].
[exit:description]

[%@library ostream_iterator[![:en]destructor]]
[codeblock:declaration]
~ostream_iterator();
[codeblock:end]

[enter:description]
[para:effects]
[:en] The iterator is destroyed.
[exit:description]

[/     3[ostream.iterator.ops]{[`ostream_iterator} operations}/]
[section#ostream.iterator.ops
    [:en] [`ostream_iterator] operations
]

[%@library operator=[!ostream_iterator]]
[%@library ostream_iterator[!operator=]]
[codeblock:declaration]
ostream_iterator& operator=(const T& value);
[codeblock:end]

[enter:description]
[para:effects]
[codeblock:notation [special out_stream delim] ]
*out_stream << value;
if (delim != 0)
  *out_stream << delim;
return *this;
[codeblock:end]
[exit:description]

[%@library operator*[!ostream_iterator]]
[%@library ostream_iterator[!operator*]]
[codeblock:declaration]
ostream_iterator& operator*();
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`*this].
[exit:description]

[%@library operator++[!ostream_iterator]]
[%@library ostream_iterator[!operator++]]
[codeblock:declaration]
ostream_iterator& operator++();
ostream_iterator& operator++(int);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`*this].
[exit:description]

[/     2[istreambuf.iterator]{Class template [`istreambuf_iterator}}/]
[section#istreambuf.iterator
    [:en] Class template [`istreambuf_iterator]
]

[para]
[:en] The class template [`istreambuf_iterator] defines an input iterator
([#input.iterators]) that reads successive [$characters] from the streambuf for
which it was constructed.

[:en] [`operator*] provides access to the current input character, if any.

[enter:note]
[:en] [`operator->] may return a proxy.
[exit:note]

[:en] Each time [`operator++] is evaluated, the iterator advances to the next
input character.

[:en] If the end of stream is reached ([`streambuf_type::sgetc()] returns
[`traits::eof()]), the iterator becomes equal to the [+end-of-stream] iterator
value.

[:en] The default constructor [`istreambuf_iterator()] and the constructor
[`istreambuf_iterator(0)] both construct an end-of-stream iterator object
suitable for use as an end-of-range.

[:en] All specializations of [`istreambuf_iterator] shall have a trivial copy
constructor, a [`constexpr] default constructor, and a trivial destructor.

[para]
[:en] The result of [`operator*()] on an end-of-stream iterator is
[%behavior[!undefined]] undefined.

[:en] For any other iterator value a [`char_type] value is returned.

[:en] It is impossible to assign a character via an input iterator.

[%@library istreambuf_iterator]
[codeblock:synopsis [special unspecified] ]
namespace std {
  template<class charT, class traits = char_traits<charT> >
  class istreambuf_iterator
     : public iterator<input_iterator_tag, charT,
                       typename traits::off_type, unspecified, charT> {
  public:
    typedef charT                         char_type;
    typedef traits                        traits_type;
    typedef typename traits::int_type     int_type;
    typedef basic_streambuf<charT,traits> streambuf_type;
    typedef basic_istream<charT,traits>   istream_type;

    class proxy;                          // [=Expos]

    constexpr istreambuf_iterator() noexcept;
    istreambuf_iterator(const istreambuf_iterator&) noexcept = default;
    ~istreambuf_iterator() = default;
    istreambuf_iterator(istream_type& s) noexcept;
    istreambuf_iterator(streambuf_type* s) noexcept;
    istreambuf_iterator(const proxy& p) noexcept;
    charT operator*() const;
    pointer operator->() const;
    istreambuf_iterator& operator++();
    proxy operator++(int);
    bool equal(const istreambuf_iterator& b) const;
  private:
    streambuf_type* sbuf_;                // [=Expos]
  };

  template <class charT, class traits>
    bool operator==(const istreambuf_iterator<charT,traits>& a,
            const istreambuf_iterator<charT,traits>& b);
  template <class charT, class traits>
    bool operator!=(const istreambuf_iterator<charT,traits>& a,
            const istreambuf_iterator<charT,traits>& b);
}
[codeblock:end]

[/     3[istreambuf.iterator::proxy]{Class template [`istreambuf_iterator::proxy}}/]
[section#istreambuf.iterator::proxy
    [:en] Class template [`istreambuf_iterator::proxy]
]

[%@library proxy[!istreambuf_iterator]]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT> >
  class istreambuf_iterator<charT, traits>::proxy { // [=Expos]
    charT keep_;
    basic_streambuf<charT,traits>* sbuf_;
    proxy(charT c, basic_streambuf<charT,traits>* sbuf)
      : keep_(c), sbuf_(sbuf) { }
  public:
    charT operator*() { return keep_; }
  };
}
[codeblock:end]

[para]
[:en] Class [`istreambuf_iterator<charT,traits>::proxy] is for exposition only.

[:en] An implementation is permitted to provide equivalent functionality without
providing a class with this name.

[:en] Class [`istreambuf_iterator<charT, traits>::proxy] provides a temporary
placeholder as the return value of the post-increment operator ([`operator++]).

[:en] It keeps the character pointed to by the previous value of the iterator
for some possible future access to get the character.

[/     3[istreambuf.iterator.cons]{[`istreambuf_iterator} constructors}/]
[section#istreambuf.iterator.cons
    [:en] [`istreambuf_iterator] constructors
]


[%@library istreambuf_iterator[![:en]constructor]]
[codeblock:declaration]
constexpr istreambuf_iterator() noexcept;
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs the end-of-stream iterator.
[exit:description]

[%@library istreambuf_iterator[![:en]constructor]]
[codeblock:declaration]
istreambuf_iterator(basic_istream<charT,traits>& s) noexcept;
istreambuf_iterator(basic_streambuf<charT,traits>* s) noexcept;
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs an [`istreambuf_iterator<>] that uses the [`basic_streambuf<>]
object [`*(s.rdbuf())], or [`*s], respectively.

[:en] Constructs an end-of-stream iterator if [`s.rdbuf()] is null.
[exit:description]

[%@library istreambuf_iterator[![:en]constructor]]
[codeblock:declaration]
istreambuf_iterator(const proxy& p) noexcept;
[codeblock:end]

[enter:description]
[para:effects]
[:en] Constructs a [`istreambuf_iterator<>] that uses the [`basic_streambuf<>]
object pointed to by the [`proxy] object[=']s constructor argument [`p].
[exit:description]

[/     3[istreambuf.iterator::op*]{[`istreambuf_iterator::operator*}}/]
[section#istreambuf.iterator::op*
    [:en] [`istreambuf_iterator::operator*]
]

[%@library operator*[!istreambuf_iterator]]
[codeblock:declaration]
charT operator*() const
[codeblock:end]

[enter:description]
[para:returns]
[:en] The character obtained via the [`streambuf] member [`sbuf_->sgetc()].
[exit:description]

[/     3[istreambuf.iterator::op++]{[`istreambuf_iterator::operator++}}/]
[section#istreambuf.iterator::op++
    [:en] [`istreambuf_iterator::operator++]
]

[%@library operator++[!istreambuf_iterator]]
[codeblock:declaration]
istreambuf_iterator& operator++();
[codeblock:end]

[enter:description]
[para:effects]
[:en] [`sbuf_->sbumpc()].

[para:returns]
[:en] [`*this].
[exit:description]

[%@library operator++[!istreambuf_iterator]]
[%@library istreambuf_iterator[!operator++]]
[codeblock:declaration]
proxy operator++(int);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`proxy(sbuf_->sbumpc(), sbuf_)].
[exit:description]

[/     3[istreambuf.iterator::equal]{[`istreambuf_iterator::equal}}/]
[section#istreambuf.iterator::equal
    [:en] [`istreambuf_iterator::equal]
]

[%@library equal[!istreambuf_iterator]]
[codeblock:declaration]
bool equal(const istreambuf_iterator& b) const;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`true] if and only if both iterators are at end-of-stream, or neither is
at end-of-stream, regardless of what [`streambuf] object they use.
[exit:description]

[/     3[istreambuf.iterator::op==]{[`operator==}}/]
[section#istreambuf.iterator::op==
    [:en] [`operator==]
]

[%@library operator==[!istreambuf_iterator]]
[codeblock:declaration]
template <class charT, class traits>
  bool operator==(const istreambuf_iterator<charT,traits>& a,
                  const istreambuf_iterator<charT,traits>& b);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`a.equal(b)].
[exit:description]

[/     3[istreambuf.iterator::op!=]{[`operator!=}}/]
[section#istreambuf.iterator::op!=
    [:en] [`operator!=]
]

[%@library operator!=[!istreambuf_iterator]]
[codeblock:declaration]
template <class charT, class traits>
  bool operator!=(const istreambuf_iterator<charT,traits>& a,
                  const istreambuf_iterator<charT,traits>& b);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`!a.equal(b)].
[exit:description]

[/     2[ostreambuf.iterator]{Class template [`ostreambuf_iterator}}/]
[section#ostreambuf.iterator
    [:en] Class template [`ostreambuf_iterator]
]

[%@library ostreambuf_iterator]
[codeblock:synopsis]
namespace std {
  template <class charT, class traits = char_traits<charT> >
  class ostreambuf_iterator :
    public iterator<output_iterator_tag, void, void, void, void> {
  public:
    typedef charT                         char_type;
    typedef traits                        traits_type;
    typedef basic_streambuf<charT,traits> streambuf_type;
    typedef basic_ostream<charT,traits>   ostream_type;

  public:
    ostreambuf_iterator(ostream_type& s) noexcept;
    ostreambuf_iterator(streambuf_type* s) noexcept;
    ostreambuf_iterator& operator=(charT c);

    ostreambuf_iterator& operator*();
    ostreambuf_iterator& operator++();
    ostreambuf_iterator& operator++(int);
    bool failed() const noexcept;

  private:
    streambuf_type* sbuf_;                // [=Expos]
  };
}
[codeblock:end]

[para]
[:en] The class template [`ostreambuf_iterator] writes successive [$characters]
onto the output stream from which it was constructed.

[:en] It is not possible to get a character value out of the output iterator.

[/     3[ostreambuf.iter.cons]{[`ostreambuf_iterator} constructors}/]
[section#ostreambuf.iter.cons
    [:en] [`ostreambuf_iterator] constructors
]


[%@library ostreambuf_iterator[![:en]constructor]]
[codeblock:declaration]
ostreambuf_iterator(ostream_type& s) noexcept;
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`s.rdbuf()] shall not be a null pointer.

[para:effects]
[:en] Initializes [`sbuf_] with [`s.rdbuf()].
[exit:description]

[%@library ostreambuf_iterator[![:en]constructor]]
[codeblock:declaration]
ostreambuf_iterator(streambuf_type* s) noexcept;
[codeblock:end]

[enter:description]
[para:requires]
[:en] [`s] shall not be a null pointer.

[para:effects]
[:en] Initializes [`sbuf_] with [`s].
[exit:description]

[/     3[ostreambuf.iter.ops]{[`ostreambuf_iterator} operations}/]
[section#ostreambuf.iter.ops
    [:en] [`ostreambuf_iterator] operations
]

[%@library operator=[!ostreambuf_iterator]]
[codeblock:declaration]
ostreambuf_iterator& operator=(charT c);
[codeblock:end]

[enter:description]
[para:effects]
[:en] If [`failed()] yields [`false], calls [`sbuf_->sputc(c)]; otherwise has no
effect.

[para:returns]
[:en] [`*this].
[exit:description]

[%@library operator*[!ostreambuf_iterator]]
[codeblock:declaration]
ostreambuf_iterator& operator*();
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`*this].
[exit:description]

[%@library operator++[!ostreambuf_iterator]]
[codeblock:declaration]
ostreambuf_iterator& operator++();
ostreambuf_iterator& operator++(int);
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`*this].
[exit:description]

[%@library failed[!ostreambuf_iterator]]
[codeblock:declaration]
bool failed() const noexcept;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`true] if in any prior use of member [`operator=], the call to
[`sbuf_->sputc()] returned [`traits::eof()]; or [`false] otherwise.
[exit:description]

[/     1[iterator.range]{Range access}/]
[section#iterator.range
    [:en] Range access
]

[para]
[:en] In addition to being available via inclusion of the [`<iterator>] header,
the function templates in [#iterator.range] are available when any of the
following headers are included: [`<array>], [`<deque>], [`<forward_list>],
[`<list>], [`<map>], [`<regex>], [`<set>], [`<string>], [`<unordered_map>],
[`<unordered_set>], and [`<vector>].

[%@library begin(C&)]
[codeblock:declaration]
template <class C> auto begin(C& c) -> decltype(c.begin());
template <class C> auto begin(const C& c) -> decltype(c.begin());
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`c.begin()].
[exit:description]

[%@library end(C&)]
[codeblock:declaration]
template <class C> auto end(C& c) -> decltype(c.end());
template <class C> auto end(const C& c) -> decltype(c.end());
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`c.end()].
[exit:description]

[%@library begin(T (&)[N'])]
[codeblock:declaration]
template <class T, size_t N> constexpr T* begin(T (&array)[N]) noexcept;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`array].
[exit:description]

[%@library end(T (&)[N'])]
[codeblock:declaration]
template <class T, size_t N> constexpr T* end(T (&array)[N]) noexcept;
[codeblock:end]

[enter:description]
[para:returns]
[:en] [`array + N].
[exit:description]

[%@library cbegin(const C&)]
[codeblock:declaration]
template <class C> constexpr auto cbegin(const C& c) noexcept(noexcept(std::begin(c)))
  -> decltype(std::begin(c));
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`std::begin(c)].
[exit:description]

[%@library cend(const C&)]
[codeblock:declaration]
template <class C> constexpr auto cend(const C& c) noexcept(noexcept(std::end(c)))
  -> decltype(std::end(c));
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`std::end(c)].
[exit:description]

[%@library rbegin(C&)]
[codeblock:declaration]
template <class C> auto rbegin(C& c) -> decltype(c.rbegin());
template <class C> auto rbegin(const C& c) -> decltype(c.rbegin());
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`c.rbegin()].
[exit:description]

[%@library rend(const C&)]
[codeblock:declaration]
template <class C> auto rend(C& c) -> decltype(c.rend());
template <class C> auto rend(const C& c) -> decltype(c.rend());
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`c.rend()].
[exit:description]

[%@library rbegin(T (&array)[N'])]
[codeblock:declaration]
template <class T, size_t N> reverse_iterator<T*> rbegin(T (&array)[N]);
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`reverse_iterator<T*>(array + N)].
[exit:description]

[%@library rend(T (&array)[N'])]
[codeblock:declaration]
template <class T, size_t N> reverse_iterator<T*> rend(T (&array)[N]);
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`reverse_iterator<T*>(array)].
[exit:description]

[%@library rbegin(initializer_list<E>)]
[codeblock:declaration]
template <class E> reverse_iterator<const E*> rbegin(initializer_list<E> il);
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`reverse_iterator<const E*>(il.end())].
[exit:description]

[%@library rend(initializer_list<E>)]
[codeblock:declaration]
template <class E> reverse_iterator<const E*> rend(initializer_list<E> il);
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`reverse_iterator<const E*>(il.begin())].
[exit:description]

[%@library crbegin(const C& c)]
[codeblock:declaration]
template <class C> auto crbegin(const C& c) -> decltype(std::rbegin(c));
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`std::rbegin(c)].
[exit:description]

[%@library crend(const C& c)]
[codeblock:declaration]
template <class C> auto crend(const C& c) -> decltype(std::rend(c));
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`std::rend(c)].
[exit:description]

[/     1[iterator.container]{Container access}/]
[section#iterator.container
    [:en] Container access
]

[para]
[:en] In addition to being available via inclusion of the [`<iterator>] header,
the function templates in [#iterator.container] are available when any of the
following headers are included: [`<array>], [`<deque>], [`<forward_list>],
[`<list>], [`<map>], [`<regex>], [`<set>], [`<string>], [`<unordered_map>],
[`<unordered_set>], and [`<vector>].

[codeblock:declaration]
template <class C> constexpr auto size(const C& c) -> decltype(c.size());
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`c.size()].
[exit:description]

[codeblock:declaration]
template <class T, size_t N> constexpr size_t size(const T (&array)[N]) noexcept;
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`N].
[exit:description]

[codeblock:declaration]
template <class C> constexpr auto empty(const C& c) -> decltype(c.empty());
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`c.empty()].
[exit:description]

[codeblock:declaration]
template <class T, size_t N> constexpr bool empty(const T (&array)[N]) noexcept;
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`false].
[exit:description]

[codeblock:declaration]
template <class E> constexpr bool empty(initializer_list<E> il) noexcept;
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`il.size() == 0].
[exit:description]

[codeblock:declaration]
template <class C> constexpr auto data(C& c) -> decltype(c.data());
template <class C> constexpr auto data(const C& c) -> decltype(c.data());
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`c.data()].
[exit:description]

[codeblock:declaration]
template <class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`array].
[exit:description]

[codeblock:declaration]
template <class E> constexpr const E* data(initializer_list<E> il) noexcept;
[codeblock:end]
[enter:description]
[para:returns]
[:en] [`il.begin()].
[exit:description]
