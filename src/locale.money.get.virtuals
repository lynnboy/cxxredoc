[section#locale.money.get.virtuals
    [:en] [`money_get] virtual functions
]

[%@library money_get[!do_get]]
[%@library do_get[!money_get]]
[codeblock:declaration]
iter_type do_get(iter_type s, iter_type end, bool intl,
                 ios_base& str, ios_base::iostate& err,
                 long double& units) const;
iter_type do_get(iter_type s, iter_type end, bool intl,
                 ios_base& str, ios_base::iostate& err,
                 string_type& digits) const;
[codeblock:end]

[enter:description]
[para:effects]
[:en] Reads characters from [`s] to parse and construct a monetary value
according to the format specified by a [`moneypunct<charT,Intl>] facet reference
[`mp] and the character mapping specified by a [`ctype<charT>] facet reference
[`ct] obtained from the locale returned by [`str.getloc()], and [`str.flags()].

[:en] If a valid sequence is recognized, does not change [`err]; otherwise, sets
[`err] to [`(err|str.failbit)], or [`(err|str.failbit|str.eofbit)] if no more
characters are available, and does not change [`units] or [`digits].

[:en] Uses the pattern returned by [`mp.neg_format()] to parse all values.

[:en] The result is returned as an integral value stored in [`units] or as a
sequence of digits possibly preceded by a minus sign (as produced by
[`ct.widen(c)] where [`c] is [`'-'] or in the range from [`'0'] through [`'9'],
inclusive) stored in [`digits].

[enter:example]
[:en] The sequence [`$1,056.23] in a common United States locale would yield,
for [`units], [`105623], or, for [`digits], [`"105623"].
[exit:example]

[:en] If [`mp.grouping()] indicates that no thousands separators are permitted,
any such characters are not read, and parsing is terminated at the point where
they first appear.

[:en] Otherwise, thousands separators are optional; if present, they are checked
for correct placement only after all format components have been read.

[para]
[:en] Where [`money_base::space] or [`money_base::none] appears as the last
element in the format pattern, no white space is consumed.

[:en] Otherwise, where [`money_base::space] appears in any of the initial
elements of the format pattern, at least one white space character is required.

[:en] Where [`money_base::none] appears in any of the initial elements of the
format pattern, white space is allowed but not required.

[:en] If [`(str.flags() & str.showbase)] is false, the currency symbol is
optional and is consumed only if other characters are needed to complete the
format; otherwise, the currency symbol is required.

[para]
[:en] If the first character (if any) in the string [`pos] returned by
[`mp.positive_sign()] or the string [`neg] returned by [`mp.negative_sign()] is
recognized in the position indicated by [`sign] in the format pattern, it is
consumed and any remaining characters in the string are required after all the
other format components.

[enter:example]
[:en] If [`showbase] is off, then for a [`neg] value of [`"()"] and a currency
symbol of [`"L"], in [`"(100 L)"] the [`"L"] is consumed; but if [`neg] is
[`"-"], the [`"L"] in [`"-100 L"] is not consumed.
[exit:example]

[:en] If [`pos] or [`neg] is empty, the sign component is optional, and if no
sign is detected, the result is given the sign that corresponds to the source of
the empty string.

[:en] Otherwise, the character in the indicated position must match the first
character of [`pos] or [`neg], and the result is given the corresponding sign.

[:en] If the first character of [`pos] is equal to the first character of
[`neg], or if both strings are empty, the result is given a positive sign.

[para]
[:en] Digits in the numeric monetary component are extracted and placed in
[`digits], or into a character buffer [`buf1] for conversion to produce a value
for [`units], in the order in which they appear, preceded by a minus sign if and
only if the result is negative.

[:en] The value [`units] is produced as if by

[footnote]
[:en] The semantics here are different from [`ct.narrow].
[footnote:end]

[codeblock]
for (int i = 0; i < n; ++i)
  buf2[i] = src[find(atoms, atoms+sizeof(src), buf1[i]) - atoms];
buf2[n] = 0;
sscanf(buf2, "%Lf", &units);
[codeblock:end]

[:en@~] where [`n] is the number of characters placed in [`buf1], [`buf2] is a
character buffer, and the values [`src] and [`atoms] are defined as if by

[codeblock]
static const char src[] = "0123456789-";
charT atoms[sizeof(src)];
ct.widen(src, src + sizeof(src) - 1, atoms);
[codeblock:end]

[para:returns]
[:en] An iterator pointing immediately beyond the last character recognized
as part of a valid monetary quantity.
[exit:description]
