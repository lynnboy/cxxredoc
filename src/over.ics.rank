[section#over.ics.rank
    [:en] Ranking implicit conversion sequences
]

[para]
[:en]
[#over.ics.rank] defines a partial ordering of implicit conversion sequences
based on the relationships [+better conversion sequence] and [+better
conversion].

[:en]
If an implicit conversion sequence S1 is defined by these rules to be a better
conversion sequence than S2, then it is also the case that S2 is a [+worse
conversion sequence] than S1.

[:en]
If conversion sequence S1 is neither better than nor worse than conversion
sequence S2, S1 and S2 are said to be [+indistinguishable conversion sequences].

[para]
[:en]
When comparing the basic forms of implicit conversion sequences (as defined in
[#over.best.ics])

[list]
[item]
[:en@~]
a standard conversion sequence ([#over.ics.scs]) is a better conversion sequence
than a user-defined conversion sequence or an ellipsis conversion sequence, and
[item]
[:en@~]
a user-defined conversion sequence ([#over.ics.user]) is a better conversion
sequence than an ellipsis conversion sequence ([#over.ics.ellipsis]).
[list:end]

[para]
[:en]
Two implicit conversion sequences of the same form are indistinguishable
conversion sequences unless one of the following rules applies:

[list]
[item]
[:en]
List-initialization sequence [`L1] is a better conversion sequence than
list-initialization sequence [`L2] if

[list]
[item]
[:en@~]
[`L1] converts to [`std::initializer_list<X>] for some [`X] and [`L2] does not,
or, if not that,

[item]
[:en@~]
[`L1] converts to type ["array of [`N1 T]], [`L2] converts to type ["array of
[`N2 T]], and [`N1] is smaller than [`N2],
[list:end]

[:en@~]
even if one of the other rules in this paragraph would otherwise apply.

[enter:example]
[codeblock]
  void f1(int);                                 // #1
  void f1(std::initializer_list<long>);         // #2
  void g1() { f1({42}); }                       // [:en] chooses #2

  void f2(std::pair<const char*, const char*>); // #3
  void f2(std::initializer_list<std::string>);  // #4
  void g2() { f2({"foo","bar"}); }              // [:en] chooses #4
[codeblock:end]
[exit:example]

[item]
[:en]
Standard conversion sequence [`S1] is a better conversion sequence than standard
conversion sequence [`S2] if

[list]
[item]
[:en]
[%subsequence rule[!overloading]]
[`S1] is a proper subsequence of [`S2] (comparing the conversion sequences in
the canonical form defined by [#over.ics.scs], excluding any Lvalue
Transformation; the identity conversion sequence is considered to be a
subsequence of any non-identity conversion sequence) or, if not that,

[item]
[:en]
the rank of [`S1] is better than the rank of [`S2], or [`S1] and [`S2] have the
same rank and are distinguishable by the rules in the paragraph below, or, if
not that,

[item]
[:en]
[`S1] and [`S2] are reference bindings ([#dcl.init.ref]) and neither refers to
an implicit object parameter of a non-static member function declared without a
[~ref-qualifier], and [`S1] binds an rvalue reference to an rvalue and [`S2]
binds an lvalue reference.

[para:~]
[enter:example]
[codeblock]
int i;
int f1();
int&& f2();
int g(const int&);
int g(const int&&);
int j = g(i);                   // [:en] calls [`g(const int&)]
int k = g(f1());                // [:en] calls [`g(const int&&)]
int l = g(f2());                // [:en] calls [`g(const int&&)]

struct A {
  A& operator<<(int);
  void p() &;
  void p() &&;
};
A& operator<<(A&&, char);
A() << 1;                       // [:en] calls [`A::operator<<(int)]
A() << 'c';                     // [:en] calls [`operator<<(A&&, char)]
A a;
a << 1;                         // [:en] calls [`A::operator<<(int)]
a << 'c';                       // [:en] calls [`A::operator<<(int)]
A().p();                        // [:en] calls [`A::p()&&]
a.p();                          // [:en] calls [`A::p()&]
[codeblock:end]
[exit:example]

[:en@~]
or, if not that,

[item]
[:en]
[`S1] and [`S2] are reference bindings ([#dcl.init.ref]) and [`S1] binds an
lvalue reference to a function lvalue and [`S2] binds an rvalue reference to a
function lvalue.

[enter:example]
[codeblock]
int f(void(&)());               // #1
int f(void(&&)());              // #2
void g();
int i1 = f(g);                  // [:en] calls #1
[codeblock:end]
[exit:example]

[:en@~]
or, if not that,

[item]
[:en]
[`S1] and [`S2] differ only in their qualification conversion and yield similar
types [`T1] and [`T2] ([#conv.qual]), respectively, and the cv-qualification
signature of type [`T1] is a proper subset of the cv-qualification signature of
type [`T2].

[enter:example]
[codeblock]
int f(const volatile int *);
int f(const int *);
int i;
int j = f(&i);                  // [:en] calls [`f(const int*)]
[codeblock:end]
[exit:example]

[:en@~]
or, if not that,

[item]
[:en]
[`S1] and [`S2] are reference bindings ([#dcl.init.ref]), and the types to which
the references refer are the same type except for top-level cv-qualifiers, and
the type to which the reference initialized by [`S2] refers is more cv-qualified
than the type to which the reference initialized by [`S1] refers.

[enter:example]
[codeblock]
int f(const int &);
int f(int &);
int g(const int &);
int g(int);

int i;
int j = f(i);                   // [:en] calls [`f(int &)]
int k = g(i);                   // [:en] ambiguous

struct X {
  void f() const;
  void f();
};
void g(const X& a, X b) {
  a.f();                        // [:en] calls [`X::f() const]
  b.f();                        // [:en] calls [`X::f()]
}
[codeblock:end]
[exit:example]
[list:end]

[item]
[:en]
User-defined conversion sequence [`U1] is a better conversion sequence than
another user-defined conversion sequence [`U2] if they contain the same
user-defined conversion function or constructor or they initialize the same
class in an aggregate initialization and in either case the second standard
conversion sequence of [`U1] is better than the second standard conversion
sequence of [`U2].

[enter:example]
[codeblock]
struct A {
  operator short();
} a;
int f(int);
int f(float);
int i = f(a);                   // [:en] calls [`f(int)], because [`short] [=to] [`int] is
                                // [:en@~] better than [`short] [=to] [`float].
[codeblock:end]
[exit:example]

[list:end]

[para]
[:en]
Standard conversion sequences are ordered by their ranks: an Exact Match is a
better conversion than a Promotion, which is a better conversion than a
Conversion.

[:en]
Two conversion sequences with the same rank are indistinguishable unless one of
the following rules applies:

[list]
[item]
[:en]
A conversion that does not convert a pointer, a pointer to member, or
[`std::nullptr_t] to [`bool] is better than one that does.

[item]
[:en]
A conversion that promotes an enumeration whose underlying type is fixed to its
underlying type is better than one that promotes to the promoted underlying
type, if the two are different.

[item]
[:en]
If class [`B] is derived directly or indirectly from class [`A], conversion of
[`B*] to [`A*] is better than conversion of [`B*] to [`void*], and conversion of
[`A*] to [`void*] is better than conversion of [`B*] to [`void*].

[item]
[:en]
If class [`B] is derived directly or indirectly from class [`A] and class [`C]
is derived directly or indirectly from [`B],

[list]
[item]
[:en]
conversion of [`C*] to [`B*] is better than conversion of [`C*] to [`A*],

[enter:example]
[codeblock]
struct A {};
struct B : public A {};
struct C : public B {};
C* pc;
int f(A*);
int f(B*);
int i = f(pc);                  // [:en] calls [`f(B*)]
[codeblock:end]
[exit:example]

[item]
[:en]
binding of an expression of type [`C] to a reference to type [`B] is better than
binding an expression of type [`C] to a reference to type [`A],

[item]
[:en]
conversion of [`A::*] to [`B::*] is better than conversion of [`A::*] to
[`C::*],

[item]
[:en]
conversion of [`C] to [`B] is better than conversion of [`C] to [`A],

[item]
[:en]
conversion of [`B*] to [`A*] is better than conversion of [`C*] to [`A*],

[item]
[:en]
binding of an expression of type [`B] to a reference to type [`A] is better than
binding an expression of type [`C] to a reference to type [`A],

[item]
[:en]
conversion of [`B::*] to [`C::*] is better than conversion of [`A::*] to
[`C::*], and

[item]
[:en]
conversion of [`B] to [`A] is better than conversion of [`C] to [`A].
[list:end]

[enter:note]
[:en]
Compared conversion sequences will have different source types only in the
context of comparing the second standard conversion sequence of an
initialization by user-defined conversion (see [#over.match.best]); in all other
contexts, the source types will be the same and the target types will be
different.
[exit:note]

[list:end]
