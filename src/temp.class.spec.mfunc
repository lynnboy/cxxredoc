[section#temp.class.spec.mfunc
    [:en] Members of class template specializations
]

[para]
[:en]
The template parameter list of a member of a class template partial
specialization shall match the template parameter list of the class template
partial specialization.

[:en]
The template argument list of a member of a class template partial
specialization shall match the template argument list of the class template
partial specialization.

[:en]
A class template specialization is a distinct template.

[:en]
The members of the class template partial specialization are unrelated to the
members of the primary template.

[:en]
Class template partial specialization members that are used in a way that
requires a definition shall be defined; the definitions of members of the
primary template are never used as definitions for members of a class template
partial specialization.

[:en]
An explicit specialization of a member of a class template partial
specialization is declared in the same way as an explicit specialization of
the primary template.

[enter:example]
[codeblock]
// [:en] primary template
template<class T, int I> struct A {
  void f();
};

template<class T, int I> void A<T,I>::f() { }

// [:en] class template partial specialization
template<class T> struct A<T,2> {
  void f();
  void g();
  void h();
};

// [:en] member of class template partial specialization
template<class T> void A<T,2>::g() { }

// [:en] explicit specialization
template<> void A<char,2>::h() { }

int main() {
  A<char,0> a0;
  A<char,2> a2;
  a0.f();                       // [:en] OK, uses definition of primary template[=']s member
  a2.g();                       // [:en] OK, uses definition of
                                // [:en@~] partial specialization[=']s member
  a2.h();                       // [:en] OK, uses definition of
                                // [:en@~] explicit specialization[=']s member
  a2.f();                       // [:en] ill-formed, no definition of [`f] for [`A<T,2>]
                                // [:en@~] the primary template is not used here
}
[codeblock:end]
[exit:example]

[para]
[:en]
If a member template of a class template is partially specialized, the member
template partial specializations are member templates of the enclosing class
template; if the enclosing class template is instantiated ([#temp.inst],
[#temp.explicit]), a declaration for every member template partial
specialization is also instantiated as part of creating the members of the class
template specialization.

[:en]
If the primary member template is explicitly specialized for a given (implicit)
specialization of the enclosing class template, the partial specializations of
the member template are ignored for this specialization of the enclosing class
template.

[:en]
If a partial specialization of the member template is explicitly specialized for
a given (implicit) specialization of the enclosing class template, the primary
member template and its other partial specializations are still considered for
this specialization of the enclosing class template.

[enter:example]
[codeblock]
template<class T> struct A {
  template<class T2> struct B {};                     // #1
  template<class T2> struct B<T2*> {};                // #2
};

template<> template<class T2> struct A<short>::B {};  // #3

A<char>::B<int*>  abcip;  // [:en] uses #2
A<short>::B<int*> absip;  // [:en] uses #3
A<char>::B<int>  abci;    // [:en] uses #1
[codeblock:end]
[exit:example]
