[section#temp.deduct.type
    [:en] Deducing template arguments from a type
]

[para]
[:en]
Template arguments can be deduced in several different contexts, but in each
case a type that is specified in terms of template parameters (call it [`P]) is
compared with an actual type (call it [`A]), and an attempt is made to find
template argument values (a type for a type parameter, a value for a non-type
parameter, or a template for a template parameter) that will make [`P], after
substitution of the deduced values (call it the deduced [`A]), compatible with
[`A].

[para]
[:en]
In some cases, the deduction is done using a single set of types [`P] and [`A],
in other cases, there will be a set of corresponding types [`P] and [`A].

[:en]
Type deduction is done independently for each [`P/A] pair, and the deduced
template argument values are then combined.

[:en]
If type deduction cannot be done for any [`P/A] pair, or if for any pair the
deduction leads to more than one possible set of deduced values, or if different
pairs yield different deduced values, or if any template argument remains
neither deduced nor explicitly specified, template argument deduction fails.

[para]
[:en]
A given type [`P] can be composed from a number of other types, templates, and
non-type values:

[list]
[item]
[:en]
A function type includes the types of each of the function parameters and the
return type.
[item]
[:en]
A pointer to member type includes the type of the class object pointed to and
the type of the member pointed to.
[item]
[:en]
A type that is a specialization of a class template (e.g., [`A<int>]) includes
the types, templates, and non-type values referenced by the template argument
list of the specialization.
[item]
[:en]
An array type includes the array element type and the value of the array bound.
[list:end]

[para]
[:en]
In most cases, the types, templates, and non-type values that are used to
compose [`P] participate in template argument deduction.

[:en]
That is, they may be used to determine the value of a template argument, and the
value so determined must be consistent with the values determined elsewhere.

[:en]
In certain contexts, however, the value does not participate in type deduction,
but instead uses the values of template arguments that were either deduced
elsewhere or explicitly specified.

[:en]
If a template parameter is used only in non-deduced contexts and is not
explicitly specified, template argument deduction fails.

[para]
[:en]
The non-deduced contexts are:

[:en]
[%context[!non-deduced]]
[list]
[item]
[:en] The [~nested-name-specifier] of a type that was specified using a
[~qualified-id].
[item]
[:en] The [~expression] of a [~decltype-specifier].
[item]
[:en] A non-type template argument or an array bound in which a subexpression
references a template parameter.
[item]
[:en] A template parameter used in the parameter type of a function parameter
that has a default argument that is being used in the call for which argument
deduction is being done.

[item]
[:en] A function parameter for which argument deduction cannot be done because
the associated function argument is a function, or a set of overloaded functions
([#over.over]), and one or more of the following apply:

[list]
[item]
[:en@~] more than one function matches the function parameter type (resulting in
an ambiguous deduction), or
[item]
[:en@~] no function matches the function parameter type, or
[item]
[:en@~] the set of functions supplied as an argument contains one or more
function templates.
[list:end]

[item]
[:en] A function parameter for which the associated argument is an initializer
list ([#dcl.init.list]) but the parameter does not have a type for which
deduction from an initializer list is specified ([#temp.deduct.call]).

[enter:example]
[codeblock]
template<class T> void g(T);
g({1,2,3});                 // [:en] error: no argument deduced for [`T]
[codeblock:end]
[exit:example]

[item]
[:en] A function parameter pack that does not occur at the end of the 
[~parameter-declaration-list].
[list:end]

[para]
[:en]
When a type name is specified in a way that includes a non-deduced context, all
of the types that comprise that type name are also non-deduced.

[:en]
However, a compound type can include both deduced and non-deduced types.

[enter:example]
[:en]
If a type is specified as [`A<T>::B<T2>], both [`T] and [`T2] are non-deduced.

[:en]
Likewise, if a type is specified as [`A<I+J>::X<T>], [`I], [`J], and [`T] are
non-deduced.

[:en]
If a type is specified as [`void f(typename A<T>::B, A<T>)], the [`T] in
[`A<T>::B] is non-deduced but the [`T] in [`A<T>] is deduced.
[exit:example]

[para]
[enter:example]
[:en]
Here is an example in which different parameter/argument pairs produce
inconsistent template argument deductions:

[codeblock]
template<class T> void f(T x, T y) { /* ... */ }
struct A { /* ... */ };
struct B : A { /* ... */ };
void g(A a, B b) {
  f(a,b);           // [:en] error: [`T] could be [`A] or [`B]
  f(b,a);           // [:en] error: [`T] could be [`A] or [`B]
  f(a,a);           // [:en] OK: [`T] is [`A]
  f(b,b);           // [:en] OK: [`T] is [`B]
}
[codeblock:end]

[:en]
Here is an example where two template arguments are deduced from a single
function parameter/argument pair.

[:en]
This can lead to conflicts that cause type deduction to fail:

[codeblock]
template <class T, class U> void f(  T (*)( T, U, U )  );

int g1( int, float, float);
char g2( int, float, float);
int g3( int, char, float);

void r() {
  f(g1);            // [:en] OK: [`T] is [`int] and [`U] is [`float]
  f(g2);            // [:en] error: [`T] could be [`char] or [`int]
  f(g3);            // [:en] error: [`U] could be [`char] or [`float]
}
[codeblock:end]

[:en]
Here is an example where a qualification conversion applies between the argument
type on the function call and the deduced template argument type:

[codeblock]
template<class T> void f(const T*) { }
int* p;
void s() {
  f(p);             // [`f(const int*)]
}
[codeblock:end]

[:en]
Here is an example where the template argument is used to instantiate a derived
class type of the corresponding function parameter type:

[codeblock]
template <class T> struct B { };
template <class T> struct D : public B<T> {};
struct D2 : public B<int> {};
template <class T> void f(B<T>&){}
void t() {
  D<int> d;
  D2     d2;
  f(d);             // [:en] calls [`f(B<int>&)]
  f(d2);            // [:en] calls [`f(B<int>&)]
}
[codeblock:end]
[exit:example]

[para]
[:en]
A template type argument [`T], a template template argument [`TT] or a template
non-type argument [`i] can be deduced if [`P] and [`A] have one of the following
forms:

[codeblock:notation
    [special:grammar cv-list integer-constant template-name type]
]
T
cv-list T
T*
T&
T&&
T[integer-constant]
template-name<T>  (where template-name refers to a class template)
type(T)
T()
T(T)
T type::*
type T::*
T T::*
T (type::*)()
type (T::*)()
type (type::*)(T)
type (T::*)(T)
T (type::*)(T)
T (T::*)()
T (T::*)(T)
type[i]
template-name<i>  (where template-name refers to a class template)
TT<T>
TT<i>
TT<>
[codeblock:end]

[:en@~]
where [`(T)] represents a [~parameter-type-list] where at least one parameter
type contains a [`T], and [`()] represents a [~parameter-type-list] where no
parameter type contains a [`T].

[:en]
Similarly, [`<T>] represents template argument lists where at least one argument
contains a [`T], [`<i>] represents template argument lists where at least one
argument contains an [`i] and [`<>] represents template argument lists where no
argument contains a [`T] or an [`i].

[para]
[:en]
If [`P] has a form that contains [`<T>] or [`<i>], then each argument
[$[`P][_i]] of the respective template argument list [`P] is compared with the
corresponding argument [$[`A][_i]] of the corresponding template argument list
of [`A].

[:en]
If the template argument list of [`P] contains a pack expansion that is not the
last template argument, the entire template argument list is a non-deduced
context.

[:en]
If [$[`P][_i]] is a pack expansion, then the pattern of [$[`P][_i]] is compared
with each remaining argument in the template argument list of [`A].

[:en]
Each comparison deduces template arguments for subsequent positions in the
template parameter packs expanded by [$[`P][_i]].

[:en]
During partial ordering ([#temp.deduct.partial]), if [$[`A][_i]] was originally
a pack expansion:

[list]
[item]
[:en] if [`P] does not contain a template argument corresponding to
[$[`A][_i]] then [$[`A][_i]] is ignored;

[item]
[:en] otherwise, if [$[`P][_i]] is not a pack expansion, template argument
deduction fails.
[list:end]

[enter:example]
[codeblock]
template<class T1, class... Z> class S;                               // #1
template<class T1, class... Z> class S<T1, const Z&...> { };          // #2
template<class T1, class T2>   class S<T1, const T2&> { };            // #3
S<int, const int&> s;         // [:en] both #2 and #3 match; #3 is more specialized

template<class T, class... U>            struct A { };                // #1
template<class T1, class T2, class... U> struct A<T1, T2*, U...> { }; // #2
template<class T1, class T2>             struct A<T1, T2> { };        // #3
template struct A<int, int*>; // [:en] selects #2
[codeblock:end]
[exit:example]

[para]
[:en]
Similarly, if [`P] has a form that contains [`(T)], then each parameter type
[$[`P][_i]] of the respective [~parameter-type-list] of [`P] is compared with
the corresponding parameter type [$[`A][_i]] of the corresponding
[~parameter-type-list] of [`A].

[:en]
If [`P] and [`A] are function types that originated from deduction when taking
the address of a function template ([#temp.deduct.funcaddr]) or when deducing
template arguments from a function declaration ([#temp.deduct.decl]) and
[$[`P][_i]] and [$[`A][_i]] are parameters of the top-level
[~parameter-type-list] of [`P] and [`A], respectively, [$[`P][_i]] is adjusted
if it is a forwarding reference ([#temp.deduct.call]) and [$[`A][_i]] is an
lvalue reference, in which case the type of [$[`P][_i]] is changed to be the
template parameter type (i.e., [`T&&] is changed to simply [`T]).

[enter:note]
[:en]
As a result, when [$[`P][_i]] is [`T&&] and [$[`A][_i]] is [`X&], the adjusted
[$[`P][_i]] will be [`T], causing [`T] to be deduced as [`X&].
[exit:note]

[enter:example]
[codeblock]
template <class T> void f(T&&);
template <> void f(int&) { }  // #1
template <> void f(int&&) { } // #2
void g(int i) {
  f(i);                       // [:en] calls [`f<int&>(int&)], i.e., #1
  f(0);                       // [:en] calls [`f<int>(int&&)], i.e., #2
}
[codeblock:end]
[exit:example]

[para:~]
[:en]
If the [~parameter-declaration] corresponding to [$[`P][_i]] is a function
parameter pack, then the type of its [~declarator-id] is compared with each
remaining parameter type in the [~parameter-type-list] of [`A].

[:en]
Each comparison deduces template arguments for subsequent positions in the
template parameter packs expanded by the function parameter pack.

[:en]
During partial ordering ([#temp.deduct.partial]), if [$[`A][_i]] was originally
a function parameter pack:

[list]
[item]
[:en] if [`P] does not contain a function parameter type corresponding to
[$[`A][_i]] then [$[`A][_i]] is ignored;

[item]
[:en] otherwise, if [$[`P][_i]] is not a function parameter pack, template
argument deduction fails.
[list:end]

[enter:example]
[codeblock]
template<class T, class... U> void f(T*, U...) { }    // #1
template<class T>             void f(T) { }           // #2
template void f(int*);      // [:en] selects #1
[codeblock:end]
[exit:example]

[para]
[:en]
These forms can be used in the same way as [`T] is for further composition of
types.

[enter:example]
[codeblock]
X<int> (*)(char[6])
[codeblock:end]

[:en@~]
is of the form

[codeblock:notation [special:grammar template-name type] ]
template-name<T> (*)(type[i])
[codeblock:end]

[:en@~]
which is a variant of

[codeblock:notation [special:grammar type] ]
type (*)(T)
[codeblock:end]

[:en@~]
where type is [`X<int>] and [`T] is [`char[6`]].
[exit:example]

[para]
[:en]
Template arguments cannot be deduced from function arguments involving
constructs other than the ones specified above.

[para]
[:en]
A template type argument cannot be deduced from the type of a non-type
[~template-argument].

[para]
[enter:example]
[codeblock]
template<class T, T i> void f(double a[10][i]);
int v[10][20];
f(v);               // [:en] error: argument for template-parameter [`T] cannot be deduced
[codeblock:end]
[exit:example]

[para]
[enter:note]
[:en]
Except for reference and pointer types, a major array bound is not part of a
function parameter type and cannot be deduced from an argument:

[codeblock]
template<int i> void f1(int a[10][i]);
template<int i> void f2(int a[i][20]);
template<int i> void f3(int (&a)[i][20]);

void g() {
  int v[10][20];
  f1(v);            // [:en] OK: [`i] deduced to be [`20]
  f1<20>(v);        // OK
  f2(v);            // [:en] error: cannot deduce template-argument [`i]
  f2<10>(v);        // OK
  f3(v);            // [:en] OK: [`i] deduced to be [`10]
}
[codeblock:end]

[para]
[:en]
If, in the declaration of a function template with a non-type template
parameter, the non-type template parameter is used in a subexpression in the
function parameter list, the expression is a non-deduced context as specified
above.

[enter:example]
[codeblock]
template <int i> class A { /* ... */ };
template <int i> void g(A<i+1>);
template <int i> void f(A<i>, A<i+1>);
void k() {
  A<1> a1;
  A<2> a2;
  g(a1);            // [:en] error: deduction fails for expression [`i+1]
  g<0>(a1);         // OK
  f(a1, a2);        // OK
}
[codeblock:end]
[exit:example]
[exit:note]

[enter:note]
[:en]
Template parameters do not participate in template argument deduction if they
are used only in non-deduced contexts.

[:en]
For example,

[codeblock]
template<int i, typename T>
T deduce(typename A<T>::X x,    // [:en] [`T] is not deduced here
  T t,                          // [:en] but [`T] is deduced here
  typename B<i>::Y y);          // [:en] [`i] is not deduced here
A<int> a;
B<77>  b;

int    x = deduce<77>(a.xm, 62, b.ym);
// [:en] [`T] is deduced to be [`int], [`a.xm] must be convertible to
// [:en@~] [`A<int>::X]
// [:en] [`i] is explicitly specified to be [`77], [`b.ym] must be convertible
// [:en@~] to [`B<77>::Y]
[codeblock:end]
[exit:note]

[para]
[:en]
If [`P] has a form that contains [`<i>], and if the type of the corresponding
value of [`A] differs from the type of [`i], deduction fails.

[:en]
If [`P] has a form that contains [`[i]], and if the type of [`i] is not an
integral type, deduction fails.

[footnote]
[:en]
Although the [~template-argument] corresponding to a [~template-parameter] of
type [`bool] may be deduced from an array bound, the resulting value will always
be [`true] because the array bound will be non-zero.
[footnote:end]

[enter:example]
[codeblock]
template<int i> class A { /* ... */ };
template<short s> void f(A<s>);
void k1() {
  A<1> a;
  f(a);             // [:en] error: deduction fails for conversion from [`int] to [`short]
  f<1>(a);          // OK
}

template<const short cs> class B { };
template<short s> void g(B<s>);
void k2() {
  B<1> b;
  g(b);             // [:en] OK: cv-qualifiers are ignored on template parameter types
}
[codeblock:end]
[exit:example]

[para]
[:en]
A [~template-argument] can be deduced from a function, pointer to function, or
pointer to member function type.

[para:~]
[enter:example]
[codeblock]
template<class T> void f(void(*)(T,int));
template<class T> void foo(T,int);
void g(int,int);
void g(char,int);

void h(int,int,int);
void h(char,int);
int m() {
  f(&g);            // [:en] error: ambiguous
  f(&h);            // [:en] OK: void [`h(char,int)] is a unique match
  f(&foo);          // [:en] error: type deduction fails because [`foo] is a template
}
[codeblock:end]
[exit:example]

[para]
[:en]
A template [~type-parameter] cannot be deduced from the type of a function
default argument.

[enter:example]
[codeblock]
template <class T> void f(T = 5, T = 7);
void g() {
  f(1);             // [:en] OK: call [`f<int>(1,7)]
  f();              // [:en] error: cannot deduce [`T]
  f<int>();         // [:en] OK: call [`f<int>(5,7)]
}
[codeblock:end]
[exit:example]

[para]
[:en]
The [~template-argument] corresponding to a template [~template-parameter] is
deduced from the type of the [~template-argument] of a class template
specialization used in the argument list of a function call.

[enter:example]
[codeblock]
template <template <class T> class X> struct A { };
template <template <class T> class X> void f(A<X>) { }
template<class T> struct B { };
A<B> ab;
f(ab);              // [:en] calls [`f(A<B>)]
[codeblock:end]
[exit:example]

[para]
[enter:note]
[:en]
Template argument deduction involving parameter packs ([#temp.variadic]) can
deduce zero or more arguments for each parameter pack.
[exit:note]

[enter:example]
[codeblock]
template<class> struct X { };
template<class R, class ... ArgTypes> struct X<R(int, ArgTypes ...)> { };
template<class ... Types> struct Y { };
template<class T, class ... Types> struct Y<T, Types& ...> { };

template<class ... Types> int f(void (*)(Types ...));
void g(int, float);

X<int> x1;                      // [:en] uses primary template
X<int(int, float, double)> x2;  // [:en] uses partial specialization; [`ArgTypes] contains [`float], [`double]
X<int(float, int)> x3;          // [:en] uses primary template
Y<> y1;                         // [:en] use primary template; [`Types] is empty
Y<int&, float&, double&> y2;    // [:en] uses partial specialization; [`T] is [`int&], [`Types] contains [`float], [`double]
Y<int, float, double> y3;       // [:en] uses primary template; [`Types] contains [`int], [`float], [`double]
int fv = f(g);                  // [:en] OK; [`Types] contains [`int], [`float]
[codeblock:end]
[exit:example]
