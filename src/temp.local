[section#temp.local
    [:en] Locally declared names
]

[para]
[:en]
Like normal (non-template) classes, class templates have an injected-class-name
(Clause [#class]).

[:en]
The injected-class-name can be used as a [~template-name] or a [~type-name].

[:en]
When it is used with a [~template-argument-list], as a [~template-argument] for
a template [~template-parameter], or as the final identifier in the
[~elaborated-type-specifier] of a friend class template declaration, it refers
to the class template itself.

[:en]
Otherwise, it is equivalent to the [~template-name] followed by the
[~template-parameter]s of the class template enclosed in [`<>].

[para]
[:en]
Within the scope of a class template specialization or partial specialization,
when the injected-class-name is used as a [~type-name], it is equivalent to the
[~template-name] followed by the [~template-argument]s of the class template
specialization or partial specialization enclosed in [`<>].

[enter:example]
[codeblock]
template<template<class> class T> class A { };
template<class T> class Y;
template<> class Y<int> {
  Y* p;                               // [:en] meaning [`Y<int>]
  Y<char>* q;                         // [:en] meaning [`Y<char>]
  A<Y>* a;                            // [:en] meaning [`A<::Y>]
  class B {
    template<class> friend class Y;   // [:en] meaning [`::Y]
  };
};
[codeblock:end]
[exit:example]

[para]
[:en]
The injected-class-name of a class template or class template specialization can
be used either as a [~template-name] or a [~type-name] wherever it is in scope.

[enter:example]
[codeblock]
template <class T> struct Base {
  Base* p;
};

template <class T> struct Derived: public Base<T> {
  typename Derived::Base* p;    // [:en] meaning [`Derived::Base<T>]
};

template<class T, template<class> class U = T::template Base> struct Third { };
Third<Base<int> > t;            // [:en] OK: default argument uses injected-class-name as a template
[codeblock:end]
[exit:example]

[para]
[:en]
A lookup that finds an injected-class-name ([#class.member.lookup]) can result
in an ambiguity in certain cases (for example, if it is found in more than one
base class).

[:en]
If all of the injected-class-names that are found refer to specializations of
the same class template, and if the name is used as a [~template-name], the
reference refers to the class template itself and not a specialization thereof,
and is not ambiguous.

[enter:example]
[codeblock]
template <class T> struct Base { };
template <class T> struct Derived: Base<int>, Base<char> {
  typename Derived::Base b;             // [:en] error: ambiguous
  typename Derived::Base<double> d;     // OK
};
[codeblock:end]
[exit:example]

[para]
[:en]
When the normal name of the template (i.e., the name from the enclosing scope,
not the injected-class-name) is used, it always refers to the class template
itself and not a specialization of the template.

[enter:example]
[codeblock]
template<class T> class X {
  X* p;             // [:en] meaning [`X<T>]
  X<T>* p2;
  X<int>* p3;
  ::X* p4;          // [:en] error: missing template argument list
                    // [:en@~] [`::X] does not refer to the injected-class-name
};
[codeblock:end]
[exit:example]

[para]
[:en]
A [~template-parameter] shall not be redeclared within its scope (including
nested scopes).

[:en]
A [~template-parameter] shall not have the same name as the template name.

[enter:example]
[codeblock]
template<class T, int i> class Y {
  int T;            // [:en] error: template-parameter redeclared
  void f() {
    char T;         // [:en] error: template-parameter redeclared
  }
};

template<class X> class X;      // [:en] error: template-parameter redeclared
[codeblock:end]
[exit:example]

[para]
[:en]
In the definition of a member of a class template that appears outside of the
class template definition, the name of a member of the class template hides the
name of a [~template-parameter] of any enclosing class templates (but not a
[~template-parameter] of the member if the member is a class or function
template).

[enter:example]
[codeblock]
template<class T> struct A {
  struct B { /* ... */ };
  typedef void C;
  void f();
  template<class U> void g(U);
};

template<class B> void A<B>::f() {
  B b;              // [:en] [`A][=']s [`B], not the template parameter
}

template<class B> template<class C> void A<B>::g(C) {
  B b;              // [:en] [`A][=']s [`B], not the template parameter
  C c;              // [:en] the template parameter [`C], not [`A][=']s [`C]
}
[codeblock:end]
[exit:example]

[para]
[:en]
In the definition of a member of a class template that appears outside of the
namespace containing the class template definition, the name of a
[~template-parameter] hides the name of a member of this namespace.

[enter:example]
[codeblock]
namespace N {
  class C { };
  template<class T> class B {
    void f(T);
  };
}
template<class C> void N::B<C>::f(C) {
  C b;              // [:en] [`C] is the template parameter, not [`N::C]
}
[codeblock:end]
[exit:example]

[para]
[:en]
In the definition of a class template or in the definition of a member of such
a template that appears outside of the template definition, for each
non-dependent base class ([#temp.dep.type]), if the name of the base class or
the name of a member of the base class is the same as the name of a
[~template-parameter], the base class name or member name hides the
[~template-parameter] name ([#basic.scope.hiding]).

[enter:example]
[codeblock]
struct A {
  struct B { /* ... */ };
  int a;
  int Y;
};

template<class B, class a> struct X : A {
  B b;              // [:en] [`A][=']s [`B]
  a b;              // [:en] error: [`A][=']s [`a] isn[=']t a type name
};
[codeblock:end]
[exit:example]
