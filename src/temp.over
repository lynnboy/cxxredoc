[section#temp.over
    [:en] Overload resolution
]

[para]
[%overloading[!resolution[!function template]]]
A function template can be overloaded either by (non-template) functions of its
name or by (other) function templates of the same name.

[:en]
When a call to that name is written (explicitly, or implicitly using the
operator notation), template argument deduction ([#temp.deduct]) and checking of
any explicit template arguments ([#temp.arg]) are performed for each function
template to find the template argument values (if any) that can be used with
that function template to instantiate a function template specialization that
can be invoked with the call arguments.

[:en]
For each function template, if the argument deduction and checking succeeds, the
[~template-argument]s (deduced and/or explicit) are used to synthesize the
declaration of a single function template specialization which is added to the
candidate functions set to be used in overload resolution.

[:en]
If, for a given function template, argument deduction fails, no such function is
added to the set of candidate functions for that template.

[:en]
The complete set of candidate functions includes all the synthesized
declarations and all of the non-template overloaded functions of the same name.

[:en]
The synthesized declarations are treated like any other functions in the
remainder of overload resolution, except as explicitly noted in
[#over.match.best].

[footnote]
[:en]
The parameters of function template specializations contain no template
parameter types.

[:en]
The set of conversions allowed on deduced arguments is limited, because the
argument deduction process produces function templates with parameters that
either match the call arguments exactly or differ only in ways that can be
bridged by the allowed limited conversions.

[:en]
Non-deduced arguments allow the full range of conversions.

[:en]
Note also that [#over.match.best] specifies that a non-template function will
be given preference over a template specialization if the two functions are
otherwise equally good candidates for an overload match.
[footnote:end]

[para:~]
[enter:example]
[codeblock]
template<class T> T max(T a, T b) { return a>b?a:b; }

void f(int a, int b, char c, char d) {
  int m1 = max(a,b);            // [`max(int a, int b)]
  char m2 = max(c,d);           // [`max(char a, char b)]
  int m3 = max(a,c);            // [:en] error: cannot generate [`max(int,char)]
}
[codeblock:end]

[para]
[:en]
Adding the non-template function

[codeblock]
int max(int,int);
[codeblock:end]

[:en@~]
to the example above would resolve the third call, by providing a function that
could be called for [`max(a,c)] after using the standard conversion of [`char]
to [`int] for [`c].

[para]
[:en]
Here is an example involving conversions on a function argument involved in
[~template-argument] deduction:

[codeblock]
template<class T> struct B { /* ... */ };
template<class T> struct D : public B<T> { /* ... */ };
template<class T> void f(B<T>&);

void g(B<int>& bi, D<int>& di) {
  f(bi);            // [`f(bi)]
  f(di);            // [`f((B<int>&)di)]
}
[codeblock:end]

[para]
[:en]
Here is an example involving conversions on a function argument not involved in
[~template-parameter] deduction:

[codeblock]
template<class T> void f(T*,int);       // #1
template<class T> void f(T,char);       // #2

void h(int* pi, int i, char c) {
  f(pi,i);          // #1: [`f<int>(pi,i)]
  f(pi,c);          // #2: [`f<int*>(pi,c)]

  f(i,c);           // #2: [`f<int>(i,c);]
  f(i,i);           // #2: [`f<int>(i,char(i))]
}
[codeblock:end]
[exit:example]

[para]
[:en]
Only the signature of a function template specialization is needed to enter the
specialization in a set of candidate functions.

[:en]
Therefore only the function template declaration is needed to resolve a call
for which a template specialization is a candidate.

[enter:example]
[codeblock]
template<class T> void f(T);    // [:en] declaration

void g() {
  f("Annemarie");               // [:en] call of [`f<const char*>]
}
[codeblock:end]

[para]
[:en]
The call of [`f] is well-formed even if the template [`f] is only declared and
not defined at the point of the call.

[:en]
The program will be ill-formed unless a specialization for [`f<const char*>],
either implicitly or explicitly generated, is present in some translation unit.
[exit:example]
