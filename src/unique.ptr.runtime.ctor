[section#unique.ptr.runtime.ctor
    [:en] [`unique_ptr] constructors
]

[%@library unique_ptr[!constructor]]
[codeblock:declaration]
template <class U> explicit unique_ptr(U p) noexcept;
template <class U> unique_ptr(U p, [=Seebelow] d) noexcept;
template <class U> unique_ptr(U p, [=Seebelow] d) noexcept;
[codeblock:end]

[enter:description]
[para]
[:en] These constructors behave the same as the constructors that take a
[`pointer] parameter in the primary template except that they shall not
participate in overload resolution unless either

[list]
[item]
[:en] [`U] is the same type as [`pointer], or
[item]
[:en] [`pointer] is the same type as [`element_type*], [`U] is a pointer type
[`V*], and [`V(*)[`]] is convertible to [`element_type(*)[`]].
[list:end]
[exit:description]

[%@library unique_ptr[!constructor]]
[codeblock:declaration]
template <class U, class E>
  unique_ptr(unique_ptr<U, E>&& u) noexcept;
[codeblock:end]

[enter:description]
[para]
[:en]
This constructor behaves the same as in the primary template, except that it
shall not participate in overload resolution unless all of the following
conditions hold, where [`UP] is [`unique_ptr<U, E>]:

[list]
[item]
[:en] [`U] is an array type, and
[item]
[:en] [`pointer] is the same type as {element_type*], and
[item]
[:en] [`UP::pointer] is the same type as [`UP::element_type*], and
[item]
[:en] [`UP::element_type(*)[`]] is convertible to [`element_type(*)[`]], and
[item]
[:en] either [`D] is a reference type and [`E] is the same type as [`D], or [`D]
is not a reference type and [`E] is implicitly convertible to [`D].
[list:end]

[enter:note]
[:en]
this replaces the overload-resolution specification of the primary template
[exit:note]
[exit:description]
